VAKOVERSCHRIJDEND PROJECT
ALGEMEEN
TIJDSCHEMA
TEAMS
TECHNOLOGIE
OPGAVE
CONTACT







Opgave

De presentatie die de klant op 13 februari gegeven heeft kan hier gevonden worden: presentatie.pdf.

De presentaties met een samenvatting van de algemene afspraken kunnen hier gevonden worden: algemene_afspraken1.pdf en algemene_afspraken2.pdf.

De UML 2.4.1 superstructure specification vind je op deze URL

Use Case Model

Presentatie: usecasemodel.pdf

De rejuse library (nodig als dependency)
git repository: https://github.ugent.be/mcvdoore/rejuse
javadoc: http://users.ugent.be/~mcvdoore/javadoc/rejuse/
Het Chameleon framework
git repository: https://github.ugent.be/mcvdoore/chameleon
javadoc: http://users.ugent.be/~mcvdoore/javadoc/chameleon/
Het use case model
git repository: https://github.ugent.be/mcvdoore/functionalanalysis
Je kan deze repository clonen en erop verder werken. Je kan ze ook via een git submodule included in je repository.
Als je wijzigingen wil doorgeven die best toegepast worden op mijn repository, pas ze dan altijd toe in een aparte branch van de master branch, en merge ze in je eigen branch. Dat maakt het mogelijk om voor mijn repository een eenvoudige pull te doen.
Binary modules
compile group: ‘markovandooren’, name: ‘rejuse’, version: ‘1.3.1’
compile group: ‘markovandooren’, name: ‘chameleon’, version: ‘1.1.22’
compile group: ‘markovandooren’, name: ‘funky’, version: ‘0.1.2’
Milestone 3

Herberekenen van de planning Om nieuwe use cases toe te kennen en/of de prioriteiten aan te passen van use cases die nog niet zijn uitgewerkt, heeft een projectleider de mogelijkheid om een nieuwe planning te maken. De projectleider geeft de datum op vanaf wanneer de planning herberekend moet worden (als de weekplanning b.v. al gemaakt is, dan moet die mogelijk behouden blijven, en gebeurt de herplanning vanaf de volgende week). Alle use cases die vanaf die dag nog niet zijn uitgewerkt en alle use cases die nog niet zijn toegekend worden opnieuw toegekend aan analysten. De use cases die volgens de vorige planning al uitgewerkt hadden moeten zijn op de opgegeven datum en de use cases waarvan de uitwerking op die dag nog bezig is blijven ongewijzigd.

update 2 Het is uiteraard nog altijd de bedoeling om een automatische toewijzing te doen van analysten aan use cases op basis van de prioriteiten en de beschikbare tijd. Elke use case moet zo snel mogelijk afgewerkt worden, maar use cases met een hogere prioriteit moeten afgewerkt worden voor use cases met een lagere prioriteit. Je hoeft geen mooie grafische voorstelling te maken van het resultaat, zoals een Gantt chart. Het volstaat om een tabel te tonen, en de toekenning door de eprojectleider te laten bevestigen. De tabel toont wie aan welke use case werkt, in welke tijdsperiode.

We veronderstellen hierbij dat er maar 1 analyst gelijktijdig op een use case werkt. Verder veronderstellen we dat er niet wordt gewerkt aan een use case voordat deze is toegekend. De projectleider moet opgeven vanaf welke dag de planning moet ingaan. Als een toekenning gedaan wordt: analyst X werkt N uur op use case Y, dan wil dat zeggen dat analyst X nog N uur moet werken aan use case Y vanaf de opgegeven startdatum. Als vereenvoudiging houden we geen rekening met andere projecten waar een analyst op werkt.

Ik stuur nog een mail naar Deloitte om te vragen wat er moet gebeuren indien er use cases bijkomen en een nieuwe planning opgesteld moet worden, of indien prioriteiten veranderen.

update Op basis van de feedback van Deloitte wordt de opgave voor milestone 3 gewijzigd. De wijzigingen staan in de volgende lijst beschreven. De delen die niet gewijzigd zijn staan in de lijst daaronder.

We hebben beslist om buiten het gemeenschappelijke deel geen extra functionaliteit meer toe te voegen. In plaats daarvan lijkt het ons aangewezen om te focussen op de gebruikersinterface en de kwaliteit van de documentatie en de software. De kwaliteit van de implementatie en documentatie is belangrijk voor de personen die de software verder zullen ontwikkelen. De kwaliteit van de gebruikersinterface is belangrijk voor de eindgebruikers. Overtuig Deloitte om jullie systeem te kiezen!

Voor het toewijzen van analysten aan use cases
De volgorde waarin use cases worden uitgevoerd wordt bepaald voor hun plaats in een proces. Een proces heeft een naam, en bevat de namen van de use cases die onderdeel zijn van het proces. De volgorde van deze namen bepaalt de volgorde waarin de use cases worden uitgevoerd. Bij het tonen en editeren van een use case moet deze informatie ook getoond en/of gewijzigd kunnen worden.
Naast het opgeven van de werklast van een use case, kan ook een prioriteit toegekend worden aan een use case. Deze prioriteit is een positie geheel getal. Ook aan een proces kan een prioriteit toegekend worden. Bij het toekennen van use cases aan analysten wordt deze informatie als volgt gebruikt (dit is een conceptuele beschrijving, en niet noodzakelijk het exacte algoritme om het te implementeren).
Eerst worden processen geselecteerd.
De processen worden gesorteed op volorde van prioriteit
Vervolgens worden de use cases toegevoegd. Een use case wordt ondergebracht bij het proces waartoe het behoort. Indien een use case in meerdere processen gebruikt wordt, wordt het ondergebracht bij het proces met de hoogste prioriteit.
Bij de planning worden de use cases behandeld in volgorde van de prioriteit van het proces waarbij ze zijn ondergebracht. Binnen die groep worden de use cases behandeld op basisvan de prioriteiten van de use cases binnen die groep.
Voor iedere analysten die op een project werkt kan opgegeven worden hoeveel uren die analyst kan werken aan het project.
ongewijzigde delen Voor de derde milestone bestaat de gemeenschappelijke opgave ondermeer uit de onderstaande functionaliteit. Op basis van feedback van Deloitte beslissen we hoe we de opgave aanvullen.

Als onderdeel van de beschrijving van een use case stap moet verwezen kunnen worden naar concepten.
Bij een concept moet het mogelijk zijn om alle use cases op te vragen die verwijzen naar het concept.
Een projectleider heeft ondersteuning nodig voor het toewijzen van use cases aan analysten. Hiervoor moet het mogelijk zijn om de geschatte werklast voor een use case te kunnen opgeven. Deze werklast wordt uitgedrukt in persoonuren.
Milestone 2

*Nieuwe versies van Chameleon en rejuse zijn beschikbaar. De namen van de modules en de laatste versienummers staan in een lijst in de vorige sectie. Je kan funky nu ook als binary module gebruiken (maar je mag ook je eigen fork aanpassen).

Om een document te verwijderen roep je de remove(DocumentLoader) methode op op een DocumentScanner. Om de overeenkomstige rij uit de database te verwijderen, moet je DocumentLoader.destroy() overschrijven (vergeen de super call niet te doen!).
Om een element te zoeken in het model kan je nu ook lambda’s gebruiken. B.v: view.defaultNamespace.descendants(Step.class, step -> step.executingEntity().sameAs(entity))
In de javadoc van DocumentLoader en Namespace zijn een aantal diagrammen toegevoegd ter verduidelijking. Als je dergelijke diagrammen in je javadoc wil zetten: de zijn gemaakt met plantuml. Zie build.gradle van Chameleon voor de nodige Gradle instructies. Voorbeelden van het gebruik vind je in source code van DocumentLoader en Namespace. Plantuml ondersteunt geen communicatie diagrammen, enkel sequence diagrammen. Een voorbeeld vind je bij DocumentLoader.setNamespace().
Als er klassen of methodes zijn waar je denkt dat diagrammen nodig zijn (of nodig waren indien je het al uitgezocht hebt), dan mag je dat altijd doorgeven. Ik heb maar beperkte tijd om hieraan te spenderen, dus dan kan ik beter diagrammen toevoegen die nuttig zijn voor jullie.
De opdracht voor de tweede milestone bestaat uit een gezamenlijk deel (ongeveer 2/3) dat voor alle groepen het zelfde is, en een deel dat iedere groep zelf kan kiezen (ongeveer 1/3).

Het gezamenlijke deel bestaat uit:

Het voorzien van een web GUI
Het voorzien van functionaliteit om stories te genereren. Een story is een instantie van een use case waarbij een pad doorheen de use case gevolgd wordt. Afhankelijk van eventuele vertakkingen in een use case kunnen er meerdere stories per use case gegenereerd worden. Het lichaam van een while loop kan 0,1, of meerdere keren worden uitgevoerd; het lichaam van een repeat loop 1 of meerdere keren. Zorg ervoor dat de bovengrens voor het aantal iteraties van een lus gemakkelijk, en op een modulaire manier ingesteld kan worden (dus niet via een static veld). In de presentatie omtrent Funky staat een hint omtrent een mogelijk ontwerp voor deze functionaliteit.
Zorg ervoor dat de functionaliteit die je zelf kiest zoveel mogelijk los staat van de rest. Deloitte wil achteraf stukken kunnen combineren. We verwachten niet dat dit voor alle functionaliteit mogelijk is op een perfect modulair manier. Voor sommige uitbreidingen zal je wellicht best het Funky model aanpassen om onnodige hoeveelheden casts en instanceof testen te vermijden. Ook is het goed mogelijk dat we in milestone 3 vragen om al enkele features van andere groepen te integreren.

Kies voor minstens 6 punten functionaliteit uit de volgende lijst.

2 punten: HATEOAS ondersteuning. Een REST interface mag eigenlijk geen REST interface genoemd worden als ze geen HATEOAS gebruikt. Het gebruik van HATEOAS zorgt ervoor dat de URL patronen voor het aanspreken van het systeem niet meer hardcoded in de clients zitten. De API voor de eerste milestone voldoet hier niet aan. Aangezien we nog niet weten of Deloitte de REST standaard volledig volgt, moet de gezamenlijke “REST” API ook blijven werken naar de HATEOAS versie. Aangezien de communicatielaag geen andere verantwoordelijkheid zou mogen hebben, zou dat weinig tot geen overhead mogen geven qua werk. Zie onder andere de volgende links voor meer informatie:
“REST APIs must be hypertext-driven” van de uitvinder van REST
http://en.wikipedia.org/wiki/HATEOAS
http://martinfowler.com/articles/richardsonMaturityModel.html
http://restcookbook.com/Basics/hateoas/
1 punt: importeren van elementen (b.v. use cases) uit andere projecten. Hierbij worden de elementen gekopieerd naar het huidige project. Het is dus geen import zoals in Funky gebruikt kan worden om b.v. actoren uit een bepaalde namespace te importeren. De klant wil niet dat er nog een connectie is met de oorsprong van het gekopieerde element.
2 punten: het zoeken van elementen op basis van de inhoud (use case namen, gebruikte actors of concepten,…)
3 punten: ook file storage als backend toelaten zodat je ook een lokale IDE kan gebruiken om de files te editeren (een tekst editor, of de Chameleon IDE (Eclipse plugin)).
3 punten: analysten en teams toevoegen
Een admin kan analysten toevoegen.
Een analyst of team kan verantwoordelijk gemaakt worden voor het uitwerken van een use case of een project.
2 punten: domein concepten uitbreiden met relaties tussen concepten. Ook moeten er in de beschrijving van gedrag verwijzingen naar domein concepten gebruikt kunnen worden.
3 punten: automatisch zoeken naar het gebruik van domein concepten in tekst, en ze vervangen door gestructureerde referenties. Een domein concept kan dan ook synoniemen hebben (die in Funky beschreven zijn). Hou rekening met het gebruik van hoofdletters en meervouden. Die wil je niet allemaal modelleren, maar de tool zou ze wel zoveel mogelijk moeten detecteren.
3 punten: use case specialisatie en extensies
Je mag ook zelf features voorstellen. Als je dat doet, bespreek ze dan kort tijdens de presentatie van de eerste milestone. We zullen dan evalueren hoeveel punten ze waard zijn, en of ze niet te zwaar zijn.
Je mag ook een uitbreiding voorstellen op features uit de bovenstaande lijst. Dan verhogen we het aantal punten dat we daaraan toekennen.
Milestone 1

Voor de eerste milestone vragen we nog geen web GUI. We willen dat iedereen focust op het uitwerken van een goede architectuur voor de backend die via REST aangesproken kan worden. Hiermee willen we voorkomen dat functionaliteit die daar niet thuishoort in de frontend terecht komt. Hier volgt een kort overzicht van de belangrijkste functionaliteit van elke component / laag:

De UI dient enkel om de gegevens te visualiseren. Business logica / data processing etc. hoort hier dus niet thuis.
Het webframework heeft enkel de verantwoordelijkheid om te zorgen voor de communicatie met clients van de REST API.
Controllers zoals die in MVC gebruikt worden vormen een aparte laag die achter het web framework ligt. Deze controllers moeten onafhankelijk zijn van het web framework zodat ze ook gebruikt kunnen worden in een standalone applicatie.
De domein laag ligt achter de controllers, en focust enkel op het modelleren van het probleemdomein. Deze laag zal verder onderverdeeld worden in modules. Zo staan projecten met use cases, actoren, en domein concepten volledig los van het al dan niet aanwezig zijn van gebruikers, teams, en permissies.
De persistentie laag focust op het opslaan van de gegevens.
Wijziging: Je mag wel ORM gebruiken (b.v. JPA) als je gebruik maakt van externe configuratie files voor de mapping. Je mag dus geen persistentie annotaties gebruiken in de domeinklassen.
Spreek met de andere groepen een gemeenschappelijke REST API af voor de basis features die hieronder beschreven staan. (Latere meer geavanceerdere features zullen wellicht geen deel uitmaken van deze gemeenschappelijke API).

Voor het beschrijven, documenteren, en experimenteren met de REST API kan je gebruik maken van Swagger
Om automatische tests uit te voeren op de REST API kan je gebruik maken van SoapUI
Schrijf fully-dressed use cases voor alle functionaliteit die jullie voorstellen. Door zelf use cases uit te werken, zullen jullie een beter inzicht krijgen in deze materie en zullen jullie hieruit ongetwijfeld ook nieuwe geavanceerdere features kunnen afleiden.

De applicatie die jullie voor deze milestone opleveren dient volgende functionaliteit te ondersteunen (er dient dus nog geen web GUI voorzien te worden; het volstaat voorlopig om de gebruiker zelf de REST commando’s te laten invoeren – bijvoorbeeld via Swagger UI):

Basic functionaliteit voor projecten:
Project aanmaken
Naam van project wijzigen
Project verwijderen
Lijst van alle projecten weergeven
Basic functionaliteit voor domein model / glossary:
Concept aanmaken. Voorlopig heeft een concept enkel een naam, definitie en een lijst van attributen. Relaties tussen concepten horen nog niet bij de eerste milestone.
Concept weergeven
Concept wijzigen
Concept verwijderen
Lijst van alle concepten weergeven
Basis functionaliteit voor use cases:
Use case aanmaken
Use case weergeven
Use case wijzigen
Use case verwijderen
Validatie van een use case. Het use case model biedt hiervoor wel ondersteuning, maar het resultaat van de analyse kan je niet zonder meer aan een client geven. Meer uitleg hierover volgt in de sessie over het use case model.
Lijst van alle use cases van een project weergeven
Use case zoeken op basis van een titel
Basis functionaliteit voor actors (hiermee bedoelen we: een actor in een use case):
Actor aanmaken. Een actor heeft voorlopig enkel een naam.
Actor weergeven
Actor wijzigen
Actor verwijderen
Lijst weergeven van alle actors
Voor de eerste milestone is er dus bijvoorbeeld nog geen user- of rollenbeheer nodig.

Zorg verder ook voor een goede en volledige test suite:

Unit tests
Integratie testen
Test de verschillende lagen zoveel mogelijk afzonderlijk.
Documenteer het architectuur ontwerp van jullie project, met ondere andere:

Een deployment diagram: een overzicht van de verschillende lagen/tiers (persistence laag, domein laag,…), welke technologie jullie voor elke laag gebruiken (b.v. PostgreSQL voor persistence laag) en hoe de verschillende lagen met elkaar communiceren.
Een component/module overview: een overzicht + korte beschrijving van de belangrijkste componenten/modules/services in jullie ontwerp (b.v. een login service, data access service, Web UI,…) en in welke laag elke service zich bevindt en met welke andere services er gecommuniceerd wordt.
Documenteer het ontwerp van jullie project, met onder andere:

Klassendiagrammen, waarop de structuur van belangrijkste klassen getoond wordt. Maak hiervoor niet 1 groot diagram, maar maak een aantal diagrammen die elk focussen op een bepaald aspect van de software.
Interactie diagrammen, waarop de belangrijkste object interacties getoond worden. Als meerdere interacties essentieel hetzelfde verlopen, dan volstaat het om 1 diagram te maken, en te vermelden dat de overige interacties zeer gelijkaardig zijn. Indien er een belangrijk verschil is in interacties die voor de rest gelijkaardig zijn, dan kan je het diagram opsplitsen zodat het gemeenschappelijke deel apart beschreven is.
© 2015 UGent.

Bepalingen der Drankspel Drieman
Art 1. Drieman wordt gespeeld met minstens vier personen. Niet drie of eender welk getal onder
vier. Vier zal het getal zijn voor het aantal spelers, alsook elk natuurlijk getal groter dan vier. Twee is
volledig uit den boze. Eens het aantal spelers vier telt, zijnde het vierde getal, kan men driemannen.
Art 2. Drieman wordt gespeeld met twee standaard zesvlakkige dobbelstenen aan een tafel of een
voorwerp dat als tafel kan dienen, zoals een ton of een heel plat dwergenhoofd. Drieman vereist de
consumptie van een alcoholhoudende drank. De deelnemers staan regelmatig verspreid rond het
tafelachtig voorwerp. De alcoholhoudende drank en de drinkeenheid worden bij het begin van het
spel afgesproken. Een voorbeeld van een drinkeenheid is een vinger, een slok of een shot.
Art 3. Wanneer een deelnemer de dobbelstenen zodanig werp, dat de som van de ogen van beide
exact drie is, wordt deze drieman tot een andere deelnemer drie werpt en de rol van drieman
overneemt. De drieman verbindt zich ertoe één eenheid van de afgesproken alcoholhoudende drank
te drinken voor elke drie die op een dobbelsteen verschijnt bij eender welke worp van eender welke
speler.
Art 4. De spelers werpen om beurten de dobbelstenen. De huidige speler blijft dobbelen zolang
eender welke speler door zijn/haar worpen moet drinken. De drieman wordt hier buiten
beschouwing gelaten; men geeft de dobbelstenen ook door wanneer enkel de drieman moet
drinken. De dobbelstenen worden steeds doorgegeven in wijzerzin.
Art 5. Wanneer de som der ogen zeven telt, dient de werper één eenheid alcoholhoudende drank te
drinken volgens de afspraken beschreven in art. 2. De driemanregels beschreven in art 3 blijven van
kracht. In navolging van art. 4 blijft de huidige werper aan de beurt.
Art 6. Wanneer de som der ogen zes telt, dient de deelnemer vóór de werper, t.t.z. de volgende
deelnemer in tegenwijzerzin, die vóór de werper aan de beurt was en dus de vorige werper was, één
eenheid alcoholhoudende drank te drinken volgens de afspraken beschreven in art. 2. De
driemanregels beschreven in art 3 blijven van kracht. In navolging van art. 4 blijft de werper aan de
beurt.
Art 7. Wanneer de som der ogen acht telt, dient de deelnemer na de werper, t.t.z. de volgende
deelnemer in wijzerzin, die uiteindelijk na de werper aan de beurt zal zijn en dus de volgende werper
zal zijn, één eenheid alcoholhoudende drank te drinken volgens de afspraken beschreven in art. 2. De
driemanregels beschreven in art 3 blijven van kracht. In navolging van art. 4 blijft de huidige werper
aan de beurt.
Art 8. Wanneer beide dobbelstenen hetzelfde aantal ogen vertonen, dienen eenheden
alcoholhoudende drank ten getale van het aantal ogen op één dobbelsteen gedronken te worden. De
werper moet deze eenheden naar eigen goeddunken toekennen aan de deelnemers. De
driemanregels beschreven in art 3 blijven van kracht. In navolging van art. 4 blijft de huidige werper
aan de beurt.
Art 9. Wanneer iemand een dobbelsteen van het tafelachtig voorwerp in art 2. werpt, neemt hij/zij
automatisch de rol van drieman over.
Art 10. Een deelnemer mag ten allen tijde het spel tijdelijk verlaten om aan lichamelijke behoeften te
voldoen, op voorwaarde dat alle eventueel opgestapelde eenheden alcoholische drank door
hem/haar geconsumeerd worden alvorens het spel te verlaten. Indien mogelijk, spelen de overige
deelnemers verder, waarbij het aantal eenheden die de afwezige moet drinken worden bijgehouden
ter consummatie bij zijn/haar terugkeer. Een deelnemer mag eveneens ten allen tijde permanent het
spel verlaten op dezelfde voorwaarde, hoewel het spel permanent verlaten als drieman als een
schande beschouwd wordt. De overige deelnemers kunnen een vervanger zoeken of met minder
verder spelen.
Art 11. Het spel duurt voort tot de vooropgestelde hoeveelheid drank opgedronken is. Dit kan zijn tot
de fles, de bak of de emmer leeg is.
Art 12. Wanneer de vooropgestelde hoeveelheid drank - zijnde de fles, bak, emmer of een andere
hoeveelheid - opgedronken is en de deelnemers beslissen het spel verder te zetten met een nieuwe
hoeveelheid drank , begint het spel opnieuw. Dit betekent dat de drieman zijn rol verliest en er dus
geen drieman is tot de gebeurtenissen beschreven in art. 3 zich opnieuw voordoen. De start van het
nieuwe spel moet, net zoals het afgelopen spel, voldoen aan de bepalingen in art. 1 en art. 2.

1 Algemene bepalingen
Art 1. WiNA is de faculteitskring van de studenten in de wiskunde, informatica, fysica en sterrenkunde aan de Universiteit Gent. De vereniging stelt zich tot doel enerzijds informatie te verstrekken aan de studenten, anderzijds via het organiseren van activiteiten contacten te leggen tussen studenten onderling, in een geest van pluralisme en politieke en ideologische ongebondenheid.

Art 2. Alle studenten uit de richtingen wiskunde, informatica en fysica en sterrenkunde en vervolgrichtingen kunnen lid worden van WiNA. Ook anderen kunnen lid worden, tenzij het praesidium, geval per geval, anders beslist. Lid is elke persoon die hieraan voldoet en zijn/haar lidgeld heeft betaald. Het bedrag van het lidgeld wordt door het praesidium vastgelegd voor de aanvang van het volgende academiejaar.

Art 3. Alle personen die met één van de richtingen wiskunde, informatica, fysica en sterrenkunde aan de Universiteit Gent verbonden zijn (professoren, assistenten, oud- studenten...) kunnen erelid worden van WiNA. Eventueel kunnen ook anderen erelid worden van WiNA, indien het praesidium hier zo over beslist. Studenten kunnen geen erelid worden, met uitzondering van pro-senioren. Erelid is elke persoon die voldoet aan deze bepalingen en zijn/haar erelidgeld heeft betaald. Het bedrag van het erelidgeld wordt door het praesidium vastgelegd voor de aanvang van het volgende academiejaar. Elke WiNA-praeses wordt automatisch na zijn praesesjaar erelid met ‘platina’-status. De daarop volgende jaren wordt hij automatisch erelid met ‘gouden’-status tot de dood hem dit recht ontneemt.

Art 4. Alle ereleden van WiNA worden automatisch ook lid (zie Art 2) van WiNA, uiteraard zonder bijkomend lidgeld te betalen. De voordelen die de ereleden krijgen worden door het praesidium vastgelegd voor aanvang van het volgend academiejaar. Dit wordt tijdig en duidelijk bekendgemaakt aan de eventuele ereleden. ’t Strakske, het clubblad van WiNA, wordt gratis aan de ereleden bezorgd.

2 Bestuur
Art 5. Het bestuur (praesidium) is het overkoepelende orgaan van WiNA. Elk lid van het praesidium moet lid zijn van WiNA.

Art 6. Een praesidiumlid mag nooit een persoonlijke opinie als standpunt van WiNA naar voor brengen.

Art 7. De verantwoordelijkheden van elke functie in het praesidium moeten duidelijk omschreven zijn in de statuten.

2.1 Algemene taken van het praesidium.
Art 8. Alle praesidiumleden zijn verplicht aanwezig op de vergaderingen waartoe zij uitgenodigd worden, tenzij ze een geldige reden hebben voor hun afwezigheid.

Art 9. De praesidiumleden moeten helpen bij de organisatie en praktische uitvoering van algemene activiteiten.

Art 10. Aan acties, georganiseerd in samenwerking met of door verenigingen met een politieke of ideologische inslag, kan WiNA slechts deelnemen na een raadpleging van alle studenten van de richtingen wiskunde, informatica en fysica en sterrenkunde. WiNA zal ten aanzien van deze verenigingen trouwens nooit een standpunt innemen, tenzij zij door hun activiteit de werking van WiNA belemmeren of verhinderen.

2.2 Samenstelling
2.2.1 De praeses
Art 11. De praeses is de voorzitter en woordvoerder van WiNA. Hij/zij roept het praesidium samen in vergadering en zit deze voor. Als voorzitter coördineert hij/zij de uitvoering van alle door het praesidium goedgekeurde initiatieven. In het belang van de vereniging neemt hij/zij tevens alle maatregelen waartoe noodwendigheid zich noopt.

Art 12. De praeses vertegenwoordigt WiNA tijdens de algemene vergaderingen van het FK. Zijn/haar stem aldaar is bindend. Hij/zij is verantwoordelijk voor het inschrijven van de leden bij het FK.

Art 13. De praeses staat samen met de quaestor in voor de subsidies.

Art 14. De praeses zit de vergaderingen van het praesidium voor. Hij/zij neemt alle maatregelen om de vergadering ordelijk te laten verlopen. Hij/zij bepaalt de agenda van de vergadering. De agenda dient toegevoegd te worden aan de uitnodiging tot de vergadering. De praesidiumvergaderingen zijn openbaar voor alle WiNA-leden en -ereleden. Hen kan slechts op hun verzoek het woord verleend worden. De vergadering moet achter gesloten deuren verlopen wanneer één derde van de aanwezige praesidiumleden dit wenselijk acht.

Art 15. Wanneer de praeses in de onmogelijkheid verkeert zijn/haar functie uit te oefenen, oefent de vice-praeses diens bevoegdheden ad interim uit, tot de onmogelijkheid heeft opgehouden te bestaan, wat door de praeses wordt vastgesteld. De vice-praeses duidt een ander lid van het praesidium aan die tijdelijk de administratieve taken uitvoert waarvoor de vice-praeses verantwoordelijk is (zie 2.2.2 Vice-praeses ). Wanneer zowel de praeses als de vice-praeses hun bevoegdheden niet kunnen uitoefenen doordat zij in de onmogelijkheid zijn, hun ontslag hebben ingediend of uit hun functie zijn ontzet, behandelt het praesidium enkel de spoedeisende zaken. In zo’n geval oefent het praesidiumlid met de meeste praesidiumervaring de bevoegdheden van praeses uit. Die praeses ad interim duidt een vice-praeses aan die de administratieve taken uitvoert.

Art 16. Indien een praesidiumlid, niet vermeld in Art 15, in de onmogelijkheid verkeert zijn functie uit te voeren, kent de praeses de verantwoordelijkheden van dat praesidiumlid aan zichzelf of aan een ander praesidumlid toe tot wanneer deze onmogelijkheid ophoudt te bestaan.

Art 17. De praeses moet minstens één jaar praesidiumervaring bij WiNA hebben en in de richting wiskunde, informatica of fysica en sterrenkunde (of aansluitende master, zie Art 2) aan de universiteit van Gent ingeschreven zijn. Hij/zij moet gedoopt en ontgroend zijn bij WiNA in een voorafgaand academiejaar.

Art 18. De praeses krijgt een exemplaar van de bankkaart van WiNA toegewezen in het begin van het academiejaar en draagt hiervoor de volle verantwoordelijkheid gedurende het desbetreffende academiejaar.

Art 19. De praeses is waarnemend lid van elk comité dat door WiNA wordt ingericht, met uitzondering van het kiescomité (Zie 2.3.3 Kiescomité).

Art 20. De praeses is verantwoordelijk voor het opvragen van de lijsten van alle studenten uit de 3 richtingen. Bovendien dient hij de lijst van alle derde bachelors twee jaar bij te houden, dit om te kunnen vaststellen wie in een vervolgrichting (zie Art 2) studeert.

2.2.2 De Vice-praeses
Art 21. De vice-praeses verzorgt de algemene administratie van WiNA. Hij/zij helpt de praeses bij de voorbereiding van de vergadering en noteert ook een verslag daarvan. Dat verslag wordt binnen de drie dagen online geplaatst op de WiNA website en de overige praesidiumleden moeten hiervan op de hoogte gesteld worden. Hij/zij nodigt ook alle andere praesidiumleden en, indien nodig, medewerkers (zie 2.2.12.2 Medewerkers) uit voor de vergadering. De voorbereidende documenten welke dienstig kunnen zijn bij de bespreking van de onderscheiden agendapunten, worden door de vice-praeses ter inzage bijgehouden. Elk praesidiumlid kan inzage ervan vorderen.

Art 22. De vice-praeses houdt het ledenbestand bij en staat in voor het tijdig indienen van de noodzakelijke formulieren bij de DSA (Dienst Studenten Activiteiten), welke bijgevoegd zijn bij de jaarlijkse subsidiebrochure. Tevens dient hij/zij een jaarverslag op te maken dat alle openbare activiteiten bevat en dat hij/zij indient bij de DSA voor de vooropgestelde einddatum.

Art 23. De vice-praeses staat in voor het contact met de ereleden en houdt bijgevolg ook de ereledenlijst bij.

Art 24. Wanneer de praeses in de onmogelijkheid verkeert zijn/haar functie uit te oefenen, oefent de vice-praeses diens bevoegdheden ad interim uit, tot de onmogelijkheid heeft opgehouden te bestaan, wat door de praeses wordt vastgesteld (zie Art 15).

Art 25. De vice-praeses moet minstens één jaar praesidiumervaring bij WiNA hebben en in de richting wiskunde, informatica of fysica en sterrenkunde (of aansluitende master, zie Art 2) aan de universiteit van Gent ingeschreven zijn. Hij/zij moet gedoopt en ontgroend zijn bij WiNA in een voorafgaand academiejaar.

Art 26. De vice-praeses krijgt een exemplaar van de bankkaart van WiNA toegewezen in het begin van het academiejaar en draagt hier de volle verantwoordelijkheid over gedurende het desbetreffende academiejaar.

2.2.3 De Quaestor of Penningmeester
Art 27. De quaestor (penningmeester) is de financiële verantwoordelijke van WiNA. Op elke vergadering brengt hij/zij verslag uit over de financiële toestand. De quaestor kan slechts betalingen doen ter uitvoering van de door het praesidium goedgekeurde verrichtingen, behoudens de gevallen van noodwendigheid. De quaestor is verantwoordelijk voor elke betaling die hij/zij onder machtiging heeft verricht.

Art 28. In de uitoefening van zijn/haar functie houdt de quaestor de financiële verrichtingen bij. Elk lid van het praesidium mag de financiële verrichtingen controleren en de quaestor ter verantwoording roepen op de vergaderingen van het praesidium.

Art 29. De quaestor is belast met het bijhouden van de individuele rekeningen van de diverse activiteiten. Hij/zij draagt er zorg voor dat ten laatste twee weken na een activiteit de desbetreffende rekening afgesloten is tenzij verlating van facturen dit onmogelijk maakt.

Art 30. De quaestor kan niet ter verantwoording geroepen worden voor de financiële verrichtingen die voltrokken waren voor hij/zij in functie trad. Hij/zij blijft onverminderd verantwoordelijk voor de wijze van uitvoering van financiële verrichtingen welke voor hij/zij in functie trad een aanvang hebben genomen.

Art 31. De quaestor maakt voor het eind van het academiejaar een financieel jaarverslag op.

Art 32. Het jaarverslag wordt samen met de financiële verrichtingen overhandigd aan de persoon die de functie van quaestor opvolgt voor de aanvang van het nieuwe academiejaar.

Art 33. De quaestor krijgt een exemplaar van de bankkaart van WiNA toegewezen in het begin van het academiejaar en draagt hier de volle verantwoordelijkheid voor gedurende het desbetreffende academiejaar.

Art 34. De quaestor moet minstens één jaar praesidiumervaring bij WiNA hebben en in de richting wiskunde, informatica of fysica en sterrenkunde (of aansluitende master, zie Art 2) aan de universiteit van Gent ingeschreven zijn.

2.2.4 De Schachtentemmer
Art 35. De schachtentemmer is verantwoordelijk voor het samenstellen van het doopcomité dat de doop van de schachten zal organiseren. In het doopcomité kunnen enkel leden zetelen die gedoopt en ontgroend zijn door WiNA en bovendien moet hun aanwezigheid goedgekeurd worden door het praesidium. Het kan vanaf dat moment op eigen initiatief samenkomen en de belangrijke beslissingen in verband met de doop nemen, zolang deze in samenspraak zijn met WiNA en met de regels die door hogere instanties opgelegd werden.

Art 36. De schachtentemmer organiseert de cantussen door tijdig een geschikte zaal te reserveren en voor inkleding en attributen te zorgen. Hij/zij speelt een belangrijke rol op cantussen als woordvoerder van de schachten (zie codex). Zijn/haar aanwezigheid in nuchtere toestand is ten stelligste gewenst.

Art 37. De schachtentemmer staat ook in voor de organisatie van de ontgroening, de tijdige creatie van de doopdiploma’s, het aanschaffen van de dooplintjes en het aan de gedoopten bezorgen van beiden.

Art 38. De schachtentemmer moet minstens één jaar commilito-ervaring bij WiNA hebben.

2.2.5 De Public-Relations (PR)
2.2.5.1 Extern

Art 39. De PR-Extern is verantwoordelijk voor het onderhouden en uitbouwen van de professionele relaties tussen WiNA en de buitenwereld, in het bijzonder met de sponsors. Hij/zij is verantwoordelijk voor alle sponsorovereenkomsten. Hij/zij staat dan ook de feestpraeses bij voor galabalsponsoring. Tevens is hij/zij verantwoordelijk voor de recruitment-diensten voor bedrijven. Dit houd in dat hij/zij het recruitment deel op de WiNA- website dient te onderhouden en organiseert, wanneer toepasbaar, een jaarlijkse jobbeurs.

2.2.5.2 Intern

Art 40. De PR-Intern is verantwoordelijk voor het tijdig bekendmaken van het plaatsgrijpen der activiteiten. Meer bepaald moeten de tijdstippen, locaties en eventueel andere nodige informatie ten laatste één week voor de aanvang van de activiteit gecommuniceerd worden naar de leden alsook de ereleden. Dat dient te gebeuren door middel van het ophangen van de affiches van de opkomende activiteiten op plaatsen waar leden van WiNA regelmatig les hebben. Hij/zij is regelmatig aanwezig op de plaatsen waar leden van WiNA les hebben ter verstrekking des mondelingen publiciteits. Hij/zij verstuurt ook de wekelijkse e-mail bevattende een overzicht van aankomende activiteiten. Dit ten laatste voor het begin van de week. Daarnaast is hij/zij verantwoordelijk voor het maken en ophangen van niet-functiegebonden affiches.

2.2.6 De Cursuspraesides
Art 41. De verantwoordelijken voor de cursusdienst staan in voor de organisatie en de werking van de cursusdienst, die gericht is op het zo snel en goedkoop mogelijk ter beschikking stellen van cursussen, aanvullende notities en dergelijke.

Art 42. De cursusdienst is verantwoordelijk voor het portierslokaaltje (glazen kot) op het gelijkvloers van het gebouw S9. Zij hebben allen toegang tot dit lokaal en zijn hier dus verantwoordelijk voor gedurende het academiejaar dat zij hun functie uitvoeren. De cursusdienst heeft ook de verantwoordelijkheid over de inhoud van de cursussite.

2.2.7 De Scriptor
Art 43. De scriptor is verantwoordelijk voor de redactie van ’t Strakske, het verenigingsblad van WiNA. De mate en de hoedanigheid van de uitgaves worden in samenspraak met het praesidium bepaald

Art 44. De inhoud van ’t Strakske moet aanvaarbaar zijn voor de leden en ereleden en mag geen aanstootgevend materiaal bevatten in navolging van Art 1.

2.2.8 De Cultuurpraeses
Art 45. De cultuurpraeses staat in voor het organiseren van culturele activiteiten voor de leden van WiNA.

2.2.9 De Sportpraeses
Art 46. De sportpraeses organiseert sportactiviteiten voor de leden van WiNA. Hij/zij zorgt tevens dat WiNA deelneemt aan zoveel mogelijk disciplines op facultaire en interfacultaire toernooien en andere sportaangelegenheden.

2.2.10 De Feestpraesides
Art 47. De feestpraesides organiseren diverse feestactiviteiten zoals fuiven. De feestpraesides zijn verantwoordelijk voor het samenstellen van het galabalcomité.

2.2.11 De IT-verantwoordelijke.
Art 48. De IT-verantwoordelijke ontwikkelt en onderhoudt de WiNA website en de server en draagt hier dan ook de volle verantwoordelijkheid voor. De website moet algemene informatie over WiNA bevatten, alsook een systeem dat de andere praesidiumleden toelaat informatie over activiteiten toe te voegen en een cursussite. De IT-verantwoordelijke heeft ten alle tijde de eindverantwoordelijkheid over aanpassingen aan de site en de server.

Art 49. De IT-verantwoordelijke is verantwoordelijk voor het nemen van backups van de gegevens en bestanden. Hij/zij zorgt ervoor dat de praeses toegang krijgt tot de server.

Art 50. De IT-verantwoordelijke moet over de nodige computertechnische competenties beschikken om zijn taak naar behoren uit te voeren. Dit wordt vastgesteld bij de kandidaatstelling door het kiescomité, na advies van de uittredende IT-verantwoordelijke.

2.2.12 Verdere uitbouw van het praesidium
2.2.12.1 De Cantor

Art 51. De cantor assisteert de senior bij het opstellen van de liedjeslijst voor WiNA- cantussen. Hij/zij mag gedurende een jaar het WiNA-cantorlint dragen, net als de verantwoordelijkheid daarvoor. Het lint wordt op de volgende zwanenzangcantus overhandigd aan zijn/haar opvolger.

Art 52. De cantor wordt verkozen op de jaarlijkse zwanenzangcantus. Elk gedoopt en ontgroend lid van WiNA kan zich voor deze functie kandidaat stellen. Kandidaten krijgen de gelegenheid om zich voor te stellen en hun kunnen te bewijzen. De verkiezing gebeurt bij handopsteking en een gewone meerderheid van de aanwezige gedoopte en ontgroende leden van WiNA.

Art 53. Verdere reglementeringen staan in de "blauwe blaadjes" van de Gentse studentencodex. De cantor is enkel in functie tijdens cantussen, hetzij van WiNA, hetzij van een andere studentenvereniging. Daarbuiten heeft hij dus geen verdere verplichtingen ten aanzien van het praesidium.

2.2.12.2 Medewerkers

Art 54. Het praesidium kan, indien nodig, een vacature voor medewerkers open stellen.

Art 55. Medewerkers zijn mensen die geen lid zijn van het praesidium en die door het praesidium worden goedgekeurd.

Art 56. Wanneer een medewerker aan een bepaalde activiteit meewerkt, verkrijgt hij/zij hiervoor enkele voordelen en/of vergoedingen. Deze worden, samen met de verwachtingen van de medewerker op de activiteit, op voorhand duidelijk afgesproken met het praesidium.

2.3 Verkiezing van het praesidium
Art 57. De verkiezing van het praesidium dient jaarlijks te gebeuren.

Art 58. Het praesidium is verantwoordelijk voor het tijdig vastleggen van een datum voor de verkiezingen.

2.3.1 Kiesrecht
Art 59. Alleen personen die binnen de categorie van stemgerechtigen vallen, zijn gerechtigd deel te nemen aan de rechtstreekse verkiezing van het praesidium voor het academiejaar volgend op dat van de verkiezingen. De stemgerechtigden zijn uitsluitend studenten die rechtsgeldig zijn ingeschreven als student in de richting wiskunde, informatica of fysica en sterrenkunde aan de Universiteit Gent, studenten die een bacheloropleiding als student in de richting wiskunde, informatica of fysica en sterrenkunde aan de Universiteit Gent voltooid hebben en opnieuw rechtsgeldig zijn ingeschreven als student aan de Universiteit Gent, leden en ereleden van WiNA.

2.3.2 Verkiesbaarheid
Art 60. Alleen studenten die rechtsgeldig zijn ingeschreven in de richting wiskunde, informatica of fysica en sterrenkunde aan de Universiteit Gent kunnen zich kandidaat stellen voor één van de hierboven omschreven praesidiumfuncties.

Art 60bis. Studenten die rechtsgeldig ingeschreven zijn aan de Universiteit Gent en niet aan Art 60 voldoen, maar wel hun bachelordiploma behaald hebben in een van de richtingen wiskunde, informatica of fysica en sterrenkunde, mogen ook opkomen voor een hierboven omschreven praesidiumfunctie.

Art 61. Het praesidium kan, met een tweederde meerderheid, ten laatste twee weken voor de verkiezingsvergadering (Art 63) beslissen om voor een bepaalde functie het aantal vacatures te wijzigen.

Art 62. Studenten die (Art 60 en Art 60bis) zich kandidaat mogen stellen, kunnen dat doen door op de verkiezingsvergadering (Art 63) aanwezig te zijn. Indien dit niet mogelijk is, kunnen ze hun kandidatuur op voorhand indienen bij het kiescomité (zie 2.3.3 Kiescomité). Het kiescomité stelt zelf de deadline voor het indienen van de kandidaturen.

Art 63. Op de publieke verkiezingsvergadering voorafgaand aan de verkiezingen beoordeelt het kiescomité de ontvankelijkheid van de kandidaturen. Door zich verkiesbaar te stellen, geeft de kandidaat aan de statuten te kennen. Indien nodig kan de kandidaat een beroep doen op het kiescomité om een correcte versie van de statuten te verkrijgen. De ontvankelijkheid van de kandidaturen wordt de volgende dag ad valvas bekend gemaakt.

2.3.3 Kiescomité
Art 64. Minstens 14 dagen voor de bij Art 63 bedoelde verkiezingsvergadering wijst het praesidium het kiescomité aan. Het kiescomité bestaat uit ten minste drie en maximum vijf personen die zelf geen kandidaat zijn bij de verkiezingen. Deze worden verkozen met een gewone meerderheid. Het kiescomité wijst haar voorzitter en secretaris aan.

Art 65. Het kiescomité is belast met de uitvoering van de beslissingen van het praesidium inzake de organisatie van de verkiezingen. Het kiescomité is ervoor verantwoordelijk dat de verkiezingen in goede banen verlopen en kan daarbij op de verkiezingsvergadering (Art 63) de nodige afspraken maken met alle kandidaten. Ook kandidaten die niet op de vergadering aanwezig zijn, dienen zich aan deze afspraken te houden.

Art 66. Het praesidium is belast met de organisatie van de verkiezingen voor het praesidium van het volgend academiejaar. Het kiescomité houdt toezicht op de verkiezingen onder de voorwaarden hieronder bepaald.

Art 67. Het kiescomité krijgt een e-mailadres toegewezen waarin enkel en alleen het kiescomité inzage heeft.

Art 68. De voorzitter van het kiescomité is verantwoordelijk voor het volledige kiescomité en hun taken.

2.3.4 Kiesverrichtingen
Art 69. Het voeren van campagne is toegestaan. Daarbij moet de kandidaat alle bewijzen van kosten bijhouden. WiNA kan voor een deel tussenkomen in de gemaakte kosten. Het praesidium beslist één week voor de verkiezingsvergadering (zie Art 63) een maximum bedrag voor deze tussenkomst. Het kiescomité legt het bedrag van tussenkomst vast, rekening houdend met de door het praesidium vastgelegde maximumbedrag. Dit voor de verkiezingsvergadering.

Art 70. Het kiescomité is verantwoordelijk voor het voldoende voorhanden zijn van stemformulieren tijdens de stemming. Elk stemformulier dient door een lid van het kiescomité afgestempeld of geparafeerd te worden.

Art 71. Het kiescomité zal in samenspraak met het praesidium de exacte data vastleggen waarop de verkiezingen zullen plaatsvinden.

Art 72. Elke stemgerechtige persoon ontvangt, na verificatie van stemgerechtigheid door het kiescomité, aan de hand van de volgens Art 20 bijgehouden documenten en zijn geldige studentenkaart of WiNA-lidkaart, een stemformulier. Het formulier wordt na het stemmen gedeponeerd in de ter plaatse beschikbare en verzegelde stembus.

Art 73. Het kiescomité ziet er op toe dat iedereen slechts één stem kan uitbrengen.

Art 74. Het stemmen is geheim. Het geschiedt schriftelijk, op uniforme stemformulieren. Volmachten worden alleen toegestaan aan mensen in bezit van een toestemming met handtekening en kopie van de identiteits- of studentenkaart van de desbetreffende persoon. Elke stemgerechtige kan voor maximaal één andere stemgerechtigde stemmen via de volmachtprocedure die hierboven beschreven staat.

Art 74bis. Het kiescomité kan het stemmen stemmen per e-mail toestaan aan ereleden en ex- praesidiumleden. Andere leden dienen hiervoor een door het kiesomité goedgekeurde motivatie te hebben.

Art 75. Een stem is geldig wanneer het stemformulier voor elke functie aan de volgende voorwaarden voldoet:

Indien er evenveel of meer vacatures als kandidaten zijn, kan er voor elke kandidaat een voor-, tegen- of blanco-stem uitgebracht worden.
Indien er meer kandidaten dan vacatures zijn, kunnen er maximum n verschillende voor-stemmen uitgebracht worden, met n het aantal vacatures.
Art 76. De stembus wordt door de voorzitter van de verkiezingscommissie verzegeld.

Art 77. Het kiescomité ziet er op toe dat de kandidaten geen invloed uitoefenen op het stemgedrag van de stemgerechtigden tijdens de stemming. Indien overtredingen worden vastgesteld door het kiescomité, kan deze entiteit beslissen de betrokken kandidaat, mits verantwoording, uit te sluiten van de verkiezingen.

Art 78. De telling van de stemmen is openbaar en verloopt volgens volgende procedure: één lid van het kiescomité controleert de geldigheid van de stemformulierenen en leest ze voor; twee andere leden van het kiescomité turven de voorgelezen stemmen. Na het voorlezen van de stemmen worden de geturfde stemmen vergeleken. Indien er zich discrepanties voordoen, worden de stemmen voor de desbetreffende functie opnieuw voorgelezen en herteld. Waarnemers van de telling krijgen geen inzage in de getelde stemmen, het samentellen van de stemmen is geheim.

Art 79. Elke kandidaat heeft het recht de hertelling te vorderen, tenzij hij/zij door het kiescomité werd uitgenodigd om de telling bij te wonen.

Art 80. Indien er even veel of meer vacatures dan kandidaten zijn, is elke kandidaat verkozen die meer voor- dan tegenstemmen heeft ontvangen. Indien er meer kandidaten dan vacatures zijn, zijn de kandidaten met de meeste stemmen verkozen. Bij gelijkheid van stemmen (zie Art 81) volgt een herstemming (zie Art 82).

Art 81. Er is een gelijkheid van stemmen indien het verschil in stemmen tussen twee kandidaten kleiner is dan 5% van het totaal aantal geldig uitgebrachte stemmen op die functie.

Art 82. Indien een herstemming dient plaats te vinden is het kiescomité verantwoordelijk voor het organiseren van een debat binnen een week na de telling. Op dit debat dienen alle kandidaten aanwezig te zijn waarvoor een herstemming wordt uitgevoerd. Na het debat volgt een stemming door alle aanwezige stemgerechtigden waarbij de kandidaat met een gewone meerderheid van de stemmen verkozen wordt.

Art 83. Het kiescomité sluit de kiesverrichtingen af en stelt een schriftelijk verslag op dat een weergave van de kiesverrichtingen op de dag van de verkiezingen bevat, de volledige uitslag van de verkiezingen en elke onregelmatigheid welke door een lid van het kiescomité werd vastgesteld of vernomen. Een kopie van dit verslag wordt ook bezorgd aan het bestuur van het Faculteiten Konvent Gent.

Art 84. Een praesidiumlid dat, nadat hij/zij verkozen is, niet meer zou voldoen aan de voorwaarden gesteld in Art 60 en Art 60bis, neemt automatisch ontslag. Vervolgens gaat het praesidium over tot coöptatie volgens de regels van Art 85.

Art 85. Wanneer een praesidiumlid ontslag heeft genomen, uit zijn/haar functie werd ontzet of wanneer tijdens de rechtstreekse verkiezing geen enkele persoon zich kandidaat heeft gesteld, kan het praesidium overgaan tot coöptatie van een nieuw praesidiumlid. De vacature van de openstaande functie(s) moet worden gemeld aan de leden door middel van affiches als het praesidium besluit de functie(s) in te vullen. Er wordt gestemd door het praesidium bij een gewone meerderheid.

Art 86. Bij coöptatie die niet het gevolg is van een positie in de verkiezingen waarvoor geen kandidaten waren, wordt automatisch voorrang verleend aan een kandidaat die aan Art 60 of Art 60bis voldoet, indien hij/zij aan de beginvoorwaarden voor de functie voldoet en (indien de coöptatie na de start van het betreffende academiejaar valt) het niet om een generatiestudent gaat.

Art 87. Alle geschillen over de verkiezingen die niet opgelost kunnen worden in overleg met het kiescomité, dienen neergelegd te worden bij het FaculteitenKonvent Gent.

Art 88. In geval dat er zich omstandigheden zouden voordoen die niet beschreven zijn in de andere artikelen betreffende verkiezingen (betreffende het gedeelte 2.3 Verkiezingen), treft het kiescomité de nodige beslissingen omtrent deze situaties.

2.4 Werking van het praesidium
2.4.1 De vergadering
Art 89. Het praesidium kan slechts rechtsgeldig vergaderen wanneer een gewone meerderheid van de praesidiumleden aanwezig is.

Art 90. Een stemming geschiedt individueel en bij handopsteking, tenzij het gaat over een motie van wantrouwen (zie 2.4.2 Motie van Wantrouwen).

Art 91. Een voorstel is aangenomen bij een gewone meerderheid van de praesidiumleden, behoudens de tweederde meerderheid welke bij de statuten vereist is ten aanzien van bepaalde beslissingen. Een voorstel dat aangenomen of verworpen is, kan slechts opnieuw behandeld worden in een latere vergadering wanneer een tweederde meerderheid van het praesidium de noodzakelijkheid ervan erkennen.

Art 92. Ieder aanwezig praesidiumlid kan een punt als variapunt toevoegen aan de agenda.

2.4.2 Motie van Wantrouwen
Art 93. Ieder praesidiumlid kan een motie van wantrouwen indienen tegen een praesidiumlid. Een motie van wantrouwen tegen een praesidiumlid wordt ingediend op een praesidiumvergadering. Op dezelfde vergadering wordt er met gewone meerderheid van alle praesidiumleden beslist over de ontvankelijkheid van de motie. Wordt de motie ontvankelijk verklaard, dan wordt de vergadering geschorst en komt ze binnen de zes werkdagen opnieuw samen in buitengewone zitting. Datum, plaats en uur van deze vergadering wordt in overleg met de betrokken partijen bepaald, die tekenen voor akkoord. Op deze buitengewone vergadering krijgen de betrokken partijen de kans om hun standpunten te verdedigen. Na uiteenzetting van de verschillende standpunten, wordt overgegaan tot een geheime stemming. De motie van wantrouwen moet worden goedgekeurd met een tweederde meerderheid van alle praesidiumleden. Tegen de beslissing van deze buitengewone praesidiumvergadering is geen verder beroep mogelijk, behalve wanneer kan aangetoond worden dat de stemming niet statutair correct is verlopen (zie Art 94). Het FK centraal wordt zo snel mogelijk van deze beslissing op de hoogte gebracht.

Art 94. Wanneer kan aangetoond worden dat een stemming over een motie van wantrouwen niet statutair correct is verlopen en wanneer deze klacht met een gewone meerderheid van alle praesidiumleden ontvankelijk is verklaard, dan moet de stemming opnieuw gebeuren. De stappen beschreven in Art 93 worden dan hernomen.

Art 95. Het lid van het praesidium tegen wie een motie van wantrouwen aangenomen is, is meteen ontslagen en dient onmiddellijk zijn/haar praesidiumkaart en lint in bij de praeses, of bij de vice-praeses indien de praeses ontslagen wordt. Art 96. Bij afwezigheid van het praesidiumlid of medewerker tegen wie de motie van wantrouwen wordt ingediend, op de buitengewone zitting beschreven in Art 93, wordt dit agendapunt naar de volgende vergadering verschoven. De vice-praeses maant het bewuste lid bij aangetekend schrijven aan om de eerstvolgende vergadering bij te wonen. In geval van hernieuwde afwezigheid op de eerstvolgende vergadering, wordt de motie toch behandeld.

Art 97. Indien het praesidiumlid of medewerker tegen wie de motie van wantrouwen wordt ingediend na herhaaldelijke pogingen onbereikbaar blijkt te zijn, maant de vice-praeses het bewust lid bij aangetekend schrijven aan om de eerstvolgende vergadering bij te wonen. In geval van hernieuwde onbereikbaarheid of afwezigheid op de eerstvolgende vergadering, wordt de motie toch behandeld.

Art 98. De vervanging van het praesidiumlid dat ten gevolge van een motie van wantrouwen uit zijn/haar functie is ontzet, wordt voorzien door coöptatie en ad valvas bekend gemaakt, tenzij deze vervanging onnodig wordt geacht en iemand anders uit het praesidium de taak op zich wil nemen.

2.5 De statuten
Art 99. De statuten liggen ter inzage in het WiNA-lokaal in de kelder van gebouw S9, Krijgslaan 281, Gent en is ook verkrijgbaar op het secretariaat van de DSA in De Therminal. Ze kunnen tevens geraadpleegd worden op de WiNA-website.

Art 100. Een wijziging van de statuten dient, voor de goedkeuring, minstens zeven werkdagen uit te hangen in het WiNA-lokaal en eventueel ook op andere plaatsen. Indien er leden of ereleden opmerkingen zouden hebben over deze wijzigingen, kunnen zij dit schriftelijk bekend maken aan de praeses. Deze opmerkingen zullen voor de stemming over de wijziging door de praeses voorgelezen worden. Een wijziging wordt aanvaard bij een tweederde meerderheid van alle praesidiumleden, waaronder zeker een vertegenwoordiger van elk van de drie WiNA-richtingen.

Art 101. In geval dat er zich omstandigheden zouden voordoen die niet beschreven zijn in de andere artikelen van de statuten met uitzondering van verkiezingen (betreffende het gedeelte 2.3 Verkiezingen), treft het praesidium de nodige beslissingen omtrent deze situaties.

Supplement: Definities uit Van Dale
Vervolgrichtingen = Aansluitende richtingen die gevolgd kunnen worden na de bacheloropleiding wiskunde, informatica of fysica en sterrenkunde die niet tot één van die richtingen behoren.

Een gewone meerderheid wordt bereikt wanneer het aantal voor-stemmen het aantal tegen- stemmen overtreft.

Een tweederde meerderheid wordt bereikt wanneer het aantal voor-stemmen het dubbel van het aantal tegen-stemmen overtreft.

Commilito-ervaring = Het aantal jaar nadat je ontgroend bent in WiNA.

Ad valvas = Ad valvas bord in S9 en/of de WiNA-website.

Generatiestudent = Een generatiestudent is een student die zich in een bepaald academiejaar voor het eerst inschrijft met een diplomacontract voor een professioneel of academisch gerichte bachelor in het Vlaamse hoger onderwijs. Het statuut van generatiestudent geldt voor dat volledige academiejaar.

Verschillende erelid-statussen opgesomd van laag naar hoog: ‘Zilveren’, ‘Gouden’, ‘Platina’.

Inleiding
In dit opleidingsonderdeel Formele talen en automaten maken we een studie van computermodellen en van de bijhorende talen die zij kunnen aanvaarden.
Als een nieuwe machine gemaakt dient te worden, dan wordt eerst een model voor deze machine opgesteld. Dit model wordt dan bestudeerd om te bekijken of deze machine correct werkt. Pas als het zeker is dat dit model correct werkt, wordt het effectief gemaakt. Hier is het ook belangrijk dat de technologie al zo ver staat dat zij dit model effectief kan maken.
De computer vormt  ́e ́en van de mooiste machines die de mens ooit ge- maakt heeft. Onze hedendaagse maatschappij is ondenkbaar zonder de com- puter.
Mensen hebben al eeuwen gedroomd van een machine die voor hen kon rekenen. Mensen zochten naar machines die hen konden helpen bij het uitvoeren van berekeningen. Een telraam is in feite al een machine die ons helpt bij het uitvoeren van berekeningen.
Maar natuurlijk werd er gezocht naar een heel performante machine die heel veel complexe taken van ons kan overnemen. Dit is onze hedendaagse computer.
Wij zullen drie computermodellen bespreken.
Eerst en vooral bespreken we het eenvoudigste model, de eindige de- terministische automaat. Dit is een automaat zonder geheugen die enkel eenvoudige taken kan vervullen.
Niettemin, deze automaat is heel belangrijk voor de echte computer. Heel veel controles die uitgevoerd worden om een correcte werking van een echte computer te verzekeren, worden uitgevoerd door eindige determinis- tische automaten.
De bijhorende talen die aanvaard kunnen worden door de eindige deter- ministische automaten, zijn gelijk aan de reguliere talen. Dit zijn talen die gedefinieerd kunnen worden door een reguliere uitdrukking.
Na deze studie bespreken we de niet-deterministische stapelautomaat. Deze automaat bezit een geheugen, namelijk een stapel, en kan daardoor
i
complexere talen herkennen dan een eindige deterministische automaat. Een niet-deterministische stapelautomaat kan een contextvrije taal aanvaarden.
Een belangrijk verschil met het eerste en het derde deel is dat deze au- tomaat niet-deterministisch is. Dit betekent dat deze automaat soms kan kiezen welke instructie hij zal uitvoeren. Dit betekent dat zijn gedrag niet zomaar eenvoudig te voorspellen is. Dit impliceert dat een aantal zaken com- plexer zullen zijn om te bestuderen, en moeilijker om op te lossen. Daarnaast impliceert dit niet-deterministisch facet aan de stapelautomaat ook dat een grotere voorzichtigheid geboden is bij het correct formuleren van problemen en hun oplossingen.
Daarna, in deel 3, bespreken we de Turing machine.
Dit model, in 1936, opgesteld door de engelse wiskundige Alan Turing, wordt door heel veel mensen beschouwd als het theoretisch model dat het best correspondeert met een echte computer. Equivalent hiermee, vele men- sen vinden de Turing machine het beste model voor een echte computer. Formeel wordt dit binnen de informatica, de Church-Turing thesis genoemd.
We bespreken dit computermodel. We tonen ook alternatieve Turing machines, en bewijzen dat zij in feite evenveel kunnen als onze originele Turing machine.
Daarna bespreken we de talen die aanvaard kunnen worden door een Turing machine, namelijk de semibeslisbare talen.
Een belangrijk feit betreffende de Turing machines is dat zij niet alle problemen kunnen oplossen. We proberen daarom ook inzicht te krijgen in welke problemen opgelost/niet-opgelost kunnen worden door een Turing machine.
Deze cursusnota’s zijn gebaseerd op het boek
E. Rich, Automata, Computability, and Complexity: Theory and Appli- cations. Prentice Hall. (ISBN 978-0-13-228806-4)
Bij dit handboek horen ppt presentaties die gebruikt worden tijdens de lessen. De cursusnota’s volgen deze ppt presentaties, en geven extra duiding. De meeste figuren komen uit deze ppt presentaties.
ii
Dankwoord
Een hartelijk dankwoord gaat uit naar iedereen die meegeholpen heeft bij het schrijven van deze cursusnota’s.
In het bijzonder naar Prof. Dr. A. Weiermann voor zijn hulp en sugges- ties bij het schrijven van deze cursusnota’s, en voor zijn hulp en suggesties bij het voorbereiden van de lessen.
Ook een bijzonder dankwoord naar J. Van der Meeren voor zijn hulp en suggesties, zowel voor deze cursusnota’s, de theorie als voor de oefeningen.
Verder, hartelijke dank aan Dr. J. De Beule voor zijn hulp bij het op- lossen van verschillende LATEX vragen en problemen.
iii
Prof. Dr. Leo Storme
Hoofdstuk 1
Getallensystemen, verzamelingen en relaties
1.1 Inleiding
In dit hoofdstuk zullen we de fundamentele eigenschappen van de standaard getallensystemen, de natuurlijke, gehele, rationale en re ̈ele getallen her- halen. We zullen hun algebra ̈ısche eigenschappen, alsook hun verschillen, bespreken.
Er wordt kort herhaald wat een algoritme is. We herhalen ook een bewijs- methode, gekend als bewijs door inductie, die fundamenteel is voor iteratieve en recursieve algoritmes.
Daarna herhalen we de basisbegrippen van verzamelingen, relaties, equi- valentierelaties om te komen tot een herhaling van functies.
We geven een gedetailleerde bespreking van het verschil tussen aftelbare en niet-aftelbare verzamelingen.
De reden voor deze gedetailleerde bespreking is dat dit verschil tussen aftelbare en niet-aftelbare verzamelingen een grote rol speelt in het be- komen van inzicht in de vraag of elke functie van de verzameling van de natuurlijke getallen N naar de verzameling van de natuurlijke getallen N ge ̈ımplementeerd kan worden in een computerprogramma.
In dit opleidingsonderdeel zullen we ons de vraag stellen of een computer alle taken voor ons kan doen, of als er taken zijn die de computer niet kan doen voor ons. Een grondig inzicht in het verschil tussen aftelbare en niet- aftelbare verzamelingen is hierdoor van heel groot belang.
1
1.2 Getallensystemen 1.2.1 De natuurlijke getallen
Het is zonder meer duidelijk dat de natuurlijke getallen ons van kindsaf aan ingelepeld zijn, allemaal hebben wij moeten leren tellen en dan klonk het 1,2,3,4,5, . . . . De naam natuurlijke getallen is dan ook niet verkeerd gekozen. Alleen willen wij meer doen met deze getallen. Wij willen ze bijvoorbeeld optellen, wij willen ze ordenen en nog meer dergelijke zaken.
Terug naar de verzameling van de natuurlijke getallen. Als de natuur- lijke getallen verwijzen naar het aantal elementen in een verzameling, dan is het al vlug duidelijk dat we ook het aantal elementen uit een ledige verzame- ling moeten kunnen weergeven. Dit is de aanleiding geweest om een extra element, aangeduid met 0, bij te voegen. Men kan nu discussi ̈eren over het feit of 0 al dan niet een natuurlijk getal is. Internationaal zijn hierover geen afspraken gemaakt. Voor de  ́ene is het getal (of moeten wij zeggen symbool) 0 geen natuurlijk getal, voor anderen wel. Wij willen ons hier echter aan de afspraak houden dat wij de 0 als natuurlijk getal beschouwen; met name
N = {0,1,2,3,...} N0 = {1,2,3,...}
Om verwarring te vermijden, zullen we in plaats van N0 soms N \ {0} ge- bruiken.
1.2.2 De gehele getallen
Eens we kunnen optellen, willen wij ook de symmetrische bewerking (die wij aftrekken noemen) uitvoeren. Uiteraard willen wij binnen onze verzameling van de natuurlijke getallen blijven, maar dit kan echter niet altijd. Wij zijn dus verplicht de verzameling van de natuurlijke getallen uit te breiden met nieuwe getallen, de zogenaamde negatieve gehele getallen. Voegen wij hier de natuurlijke getallen bij, die we dus ook de niet-negatieve gehele getallen kunnen noemen, dan ontstaat de verzameling van de gehele getallen
Z = {...,−4,−3,−2,−1,0,1,2,3,4,...}.
Alhoewel de notatie Z voor de verzameling van de gehele getallen een internationale standaardnotatie is, geldt dit niet voor de notatie van de verzameling van de negatieve gehele getallen en andere deelverzamelingen van Z. In het bijzonder noteren wij
Z− = Z+= Z+0 = Z−0 =
{0,−1,−2,−3,−4,...} {0,1,2,3,4,...} = N {1,2,3,4,...}=N0 {−1,−2,−3,−4,...}.
2
Naar analogie met Z−0 , de verzameling van de negatieve gehele getallen, kan de verzameling Z+0 = {1, 2, 3, 4, . . .} = N0 de verzameling van de posi- tieve gehele getallen genoemd worden en de verzameling Z− de verzameling van de niet-positieve gehele getallen.
Een analoge notatie zal gebruikt worden voor deelverzamelingen van de andere getallenverzamelingen.
1.2.3 De rationale getallen
De gehele getallen werden ingevoerd om de symmetrische bewerking van de optelling steeds mogelijk te maken. Er is echter nog een tweede bewerking, met name de vermenigvuldiging. Indien wij hiervan de inverse bewerking willen uitvoeren, dan blijkt al vlug dat wij terug nieuwe getallen moeten invoeren, met name de (eigenlijke) breuken a/b, met zowel a en b in Z, en met b ̸= 0. Samen met de gehele getallen vormen zij de verzameling van de rationale getallen, die door Q voorgesteld wordt.
De invoering van de deling leidt tot het begrip factor van een natuurlijk getal. Namelijk, als een geheel getal a, verschillend van nul, het product is van twee andere gehele getallen b en c, dus a = bc, dan noemen we b en c factoren van a. Zo heeft het getal 6 als factoren 1, −1, 2, −2, 3, −3, 6, −6, want 6 = 1 · 6 = (−1) · (−6) = 2 · 3 = (−2) · (−3).
De voorstelling van een rationaal getal als breuk is niet uniek.
Zo is 5/10 gelijk aan 1/2. Er is wel een unieke voorstelling voor elk rationaal getal a/b als ge ̈eist wordt dat b > 0 en dat de teller a en de noemer b geen factoren gemeen hebben.
1.2.4 De re ̈ele getallen
De verzameling van de rationale getallen wordt dan nog uitgebreid met de zogenaamde irrationale getallen, om dan de verzameling R van de re ̈ele
getallen te vormen.
Een klassiek voorbeeld van een irrationaal getal is het getal x =
2 als oplossing van de vergelijking X2 = 2. Het is onmogelijk om √2 als quoti ̈ent
√
￼￼van twee gehele getallen te schrijven.
In feite kan de verzameling van de re ̈ele getallen beschouwd worden als
de verzameling van alle decimale getallen zoals bijvoorbeeld: 512.237988032 · · ·
1.2.5 De ordening van de gehele getallen
De natuurlijke ordening (of orde) “kleiner dan of gelijk aan” (≤) van de gehele getallen is op zijn minst even belangrijk als de bewerkingen die we kunnen uitvoeren op de gehele getallen.
3
Deze ordening is opnieuw, als gevolg van ons intu ̈ıtief begrip van tellen, een natuurlijke wetmatigheid voor ons geworden. De volgende 5 axioma’s zijn voldoende om de regels van deze relatie tussen gehele getallen vast te leggen.
(A1)∀a∈Z:a≤a. Derelatie≤isreflexief. (A2)∀a,b∈Z:((a≤b)∧(b≤a))=⇒a=b. Derelatie≤isanti-
symmetrisch.
(A3)∀a,b,c∈Z:((a≤b)∧(b≤c))=⇒a≤c. Derelatie≤istransitief. (A4) ∀a, b, c ∈ Z : a ≤ b =⇒ a + c ≤ b + c.
(A5) ∀a, b ∈ Z ∧ ∀c ∈ N : a ≤ b =⇒ ac ≤ bc.
Gevolgen
1. Veronderstel dat a ≤ b. Uit de voorgaande axioma’s volgt dat −b ≤ −a, of algemeen, uit a ≤ b en c ≤ 0 volgt dat bc ≤ ac.
2. Voorelkgeheelgetalxis0≤x2,eninhetbijzonderis0≤1. 3. Voorelkgeheelgetalnisn≤n+1.
1.3 Wiskundige inductie
Beschouwen we de verzameling van de natuurlijke getallen N en de ordening hierop gedefinieerd. Dan is 0 het kleinste van alle natuurlijke getallen.
Verder geldt er ook dat elk natuurlijk getal n bekomen kan worden door precies n keer  ́e ́en op te tellen bij nul. Met andere woorden
n=1+···+1. 􏰄 􏰃􏰂 􏰅
n keer
Voor wiskundige bewijzen en voor het ontwerpen van algoritmes heeft dit belangrijke gevolgen.
Voor wiskundige bewijzen heeft het geleid tot de methode van wiskun- dige inductie. Dit wordt als volgt omschreven. (In deze formulering is de opvolger van het natuurlijk getal n gelijk aan n + 1).
Als een eigenschap geldt voor het natuurlijk getal nul, en als elke opvol- ger van een natuurlijk getal dat die eigenschap bezit, ook de eigenschap bezit, dan is de eigenschap geldig voor alle natuurlijke getallen.
4
￼￼
1.3.1 Voorbeeld
We zullen bewijzen door inductie dat de volgende formule geldig is
0+1+2+···+n= n(n+1). 2
(1) Eerst en vooral controleren we of de formule geldig is voor n = 0. Dit is hier onmiddellijk duidelijk. Als n = 0, dan staat er zowel rechts als links nul; dus de formule is geldig voor n = 0.
(2) Nu komt de inductiestap. We onderstellen dat de formule correct is als n ingegeven wordt, en we bewijzen dat als de formule geldig is voor n, ze dan ook geldig is voor de opvolger n + 1.
Dus we veronderstellen dat
0+1+2+···+n= n(n+1). (1.1) 2
Is nu
0+1+2+···+n+(n+1) (1.2) gelijk aan (n + 1)(n + 1 + 1)/2?
Door gebruik van formule (1.1) weten we dat in het linkerlid van (1.1) de uitdrukking 0+1+2+···+n zich vereenvoudigt tot n(n+1)/2.
Dus het linkerlid van (1.2) is gelijk aan n(n+1)/2+(n+1) = (n+1)(n+ 2)/2, en dit is precies de uitkomst die gevraagd werd te controleren.
Bijgevolg geldt de formule dus ook voor n + 1.
Uit het principe van bewijs door inductie volgt nu dat de formule
geldig is voor alle natuurlijke getallen n. 1.3.2 De torens van Hanoi
Figuur 1.1: De torens van Hanoi
5
￼￼￼￼
De puzzel De torens van Hanoi werd in 1883 door Eduard Lucas onder de naam M. Claus gepubliceerd en een jaar later voorzien van een boeiende maar volkomen verzonnen geschiedenis.
In de grote tempel van Benares, onder de koepel die het middelpunt der aarde markeert, ligt een koperen plaat waarin drie diamanten naalden zijn aangebracht,  ́e ́en el hoog en even dik als het lichaam van een bij. Op  ́e ́en van deze naalden heeft God ten tijde van de schepping 64 schijven van zuiver goud geplaatst, zodanig dat de grootste schijf op de koperen plaat en elke andere schijf op een grotere rust. Dit is de Toren van Brahma. Dag en nacht verplaatsen de priesters onophoudelijk schijven van de ene diamanten naald naar de andere in overeenstemming met de vaste en onveranderlijke wetten van Brahma, die vereisen dat de dienstdoende priester niet meer dan  ́e ́en schijf tegelijk verplaatst en dat hij deze schijf zodanig op een naald legt dat zich geen kleinere schijf daaronder bevindt. Als de 64 schijven op deze wijze zijn overgebracht van de naald waarop zij door God bij de schepping zijn geplaatst naar  ́e ́en van de andere naalden, dan zullen toren, tempel en Brahmanen gelijkelijk tot stof vergaan, en met een donderslag zal de wereld verdwijnen.
We zullen hierna zien dat de Brahmaanse priesters 264 − 1 of 18 446 744 073 709 551 615 zetten nodig hebben om hun taak te voltooien; dat komt, als zeven da- gen per week 24 uur per dag elke seconde  ́e ́en zet wordt gedaan, overeen met bijna 600 000 000 000 jaar.
Uit: Woordenboek van eigenaardige en merkwaardige getallen van David Wells.
Het spelletje van De torens van Hanoi gaat als volgt. Er zijn drie staafjes, waarover schijfjes van verschillende grootte geschoven kunnen worden (zie Figuur 1.1).
In het spelletje mogen de schijfjes slechts  ́e ́en voor  ́e ́en van het  ́ene op het andere staafje worden geschoven. Verder is het nooit toegestaan dat een schijfje bovenop een schijfje komt dat kleiner is. De bedoeling is nu de hele toren schijfjes van staafje A naar staafje B te verplaatsen, waarbij we staafje C mogen gebruiken om de schijfjes tijdelijk op te schuiven.
De vraag is nu, hoe vaak er een schijfje op een ander staafje moet worden geschoven, als we een toren van n schijfjes willen verplaatsen. We noemen dit aantal an. Om an te berekenen, redeneren we als volgt:
(i) We moeten an−1 keer een schijfje om een ander staafje schuiven om de bovenste n − 1 schijfjes van staafje A naar staafje C te verplaatsen. Staafje B dient hierbij als hulp.
(ii) In  ́e ́en keer schuiven we nu het onderste schijfje van staafje A om staafje B.
(iii) Als laatste verplaatsen we nu de n−1 schijfjes van staafje C naar staafje 6
B, waarbij we staafje A als hulp gebruiken. We moeten daarvoor an−1 keer een schijfje om een ander schijfje schuiven.
Om de toren van n schijfjes te verplaatsen, moeten we dus
an =2·an−1 +1 (1.3)
keer een schijfje om een ander staafje plaatsen.
Nu tonen we via bewijs door inductie aan dat an = 2n − 1.
(1) Eerst en vooral controleren we of de formule geldig is voor n = 0. Dit is hier onmiddellijk duidelijk. Als n = 0, dan staan er geen schijfjes op staafje A; dus we moeten niks verplaatsen naar staafje B; dus a0 = 20 − 1 = 0 is correct.
Analoog kan ook n = 1 gecontroleerd worden. Als er slechts  ́e ́en schijfje op staafje A staat, dan kunnen we die onmiddellijk verplaatsen naar staafjeB. Dusa1 =21−1=1isookcorrect.
(2) Nu komt de inductiestap. We onderstellen dat de formule correct is als n ingegeven wordt, en we bewijzen dat als de formule geldig is voor n, ze dan ook geldig is voor de opvolger n + 1.
Dus we veronderstellen dat
Is nu
an = 2n − 1. an+1 = 2n+1 − 1?
(1.4) (1.5)
Door gebruik van Formule (1.3) weten we dat an+1 = 2 · an + 1. Door gebruik te maken van (1.4) vinden we
an+1 = 2·an +1 = 2·(2n −1)+1 = 2n+1 −1
en dit is precies de uitkomst die gevraagd werd te controleren. Bijgevolg geldt de formule dus ook voor n + 1.
Uit het principe van bewijs door inductie volgt nu dat de formule geldig is voor alle natuurlijke getallen n.
Voor een toepassing van wiskundige inductie voor het bewijzen van de correctheid van een recursief programma, verwijzen we naar Sectie 1.4.7.
7
1.3.3 Augustus De Morgan
Alhoewel Augustus De Morgan beter bekend is voor de regels van De Morgan uit de propositielogica, is hij ook de wiskundige die de bewijsmethode van wiskundige inductie op exacte wijze beschreven heeft. Daarom volgt hierna zijn biografie.
Figuur 1.2: Augustus De Morgan
Augustus De Morgan’s vader John was een luitenant-kolonel werkzaam in India. Tijdens zijn verblijf in India werd op 27 juni 1806 te Madura, Madras Presidency, zijn vijfde kind Augustus geboren. Augustus verloor kort na zijn geboorte het zicht in zijn rechteroog. Toen Augustus 7 maanden oud was, keerde John met zijn gezin terug naar Engeland. John De Morgan stierf toen Augustus 10 jaar oud was.
Op school blonk Augustus niet uit. Zestien jaar oud, ging hij in 1823 naar Trinity College Cambridge waar hij les kreeg van Peacock en Whewell; zij drie werden vrienden voor het leven. Hij behaalde zijn Bachelor of Arts, maar daar een theologische test nodig was voor Master of Arts; iets waartegen De Morgan grote bezwaren had niettegenstaande hij lid was van de Church of England, kon hij niet verder verblijven in Cambridge daar hij geen recht had op een beurs als hij zijn Master’s diploma niet had.
In 1826 keerde hij terug naar London, en ging naar Lincoln’s Inn om rechten te gaan studeren. In 1827, toen hij 21 jaar oud was, postuleerde hij voor een wiskun- deplaats in het nieuw opgerichte University College London, en, niettegenstaande hij geen wiskundige publikaties had, werd hij daar benoemd.
In 1828 werd De Morgan de eerste wiskundeprofessor aan University College London. Zijn inaugurale rede was getiteld: On the Study of Mathematics. De Morgan gaf zijn ontslag, over een princiepskwestie, in 1831. Hij werd opnieuw benoemd in 1836, en behield deze positie tot 1866, toen hij opnieuw zijn ontslag indiende, opnieuw over een princiepskwestie.
Zijn boek Elements of Arithmetic (1830) was zijn tweede publikatie en zou nog vele herdrukken hebben.
In 1838 introduceerde en definieerde hij de term wiskundige inductie waardoor hij deze techniek die al gebruikt werd zonder exact gedefinieerd te zijn, nu rigoureus omschreef. De term verschijnt voor het eerst in De Morgan’s artikel: Induction
8
￼
(Mathematics) in Penny Encyclopedia. (In de loop der jaren zal hij 712 artikels voor Penny Encyclopedia schrijven.) Penny Encyclopedia werd gepubliceerd door de Society for the Diffusion of Useful Knowledge; een vereniging opgericht door dezelfde hervormers die London University opgericht hadden, en deze vereniging publiceerde ook het beroemde werk The Differential and Integral Calculus van De Morgan.
In 1849 publiceerde hij Trigonometry and double algebra waarin hij een meet- kundige interpretatie van complexe getallen gaf.
Hij erkende de pure symbolische natuur van algebra en hij was zich bewust van andere algebras dan de gewone algebra. Hij introduceerde de wetten van De Morgan en zijn grootste bijdrage is als hervormer van de wiskundige logica.
De Morgan was in 1866 medestichter van de London Mathematical Society en werd de eerste president hiervan. De Morgan’s zoon George, een heel bekwame wiskundige, werd zijn eerste secretaris. In hetzelfde jaar werd De Morgan verkozen tot lid van de Royal Astronomical Society.
Hij was nooit lid van de Royal Society en hij stond niet toe dat hij voorgesteld werd om lid te worden van de Royal Society. Hij weigerde ook een eredoctoraat van de University of Edinburgh.
De Morgan was altijd geinteresseerd in merkwaardige numerieke feiten. In 1864 merkte hij in een brief op dat hij het geluk had om x jaar oud te zijn in het jaar x2 (Hij was 43 in 1849). Iedereen geboren in 1980 zal kunnen zeggen hetzelfde geluk te hebben.
(bron: http://turnbull.dcs.st-and.ac.uk/∼history/Mathematicians/De Morgan.html)
1.4 Algoritmes, programma’s en correctheid van programma’s
1.4.1 Algoritmes
Om deze paragraaf te situeren, geven we een informele definitie van algo- ritme.
Met een algoritme bedoelen we een routine of mechanische procedure die een zekere verzameling inputs aanvaardt, waarvoor die routine of mechani- sche procedure dan een output geeft na een eindig aantal stappen.
De input zijn dus de initi ̈ele data of startwaarden, en de output is wat het algoritme als eindresultaat geeft.
In deze definitie wensen we de volgende zaken te benadrukken.
(1) In de eerste plaats moet het algoritme effectief werken volgens een eindige verzameling instructies. Dit kan een reeks van taken zijn die opgedragen zijn aan een persoon of dit kan een reeks instructies zijn die uitgevoerd kunnen worden door een machine, maar in beide gevallen moet die persoon of machine getrouw, in de correcte volgorde, de instructies uit de verzameling instructies uitvoeren.
9
￼
(2) Het tweede punt dat benadrukt dient te worden is dat het algoritme altijd eindigt na een eindig aantal stappen.
Dit wordt gemotiveerd door het feit dat men in computerprogramma’s oneindige lussen probeert te vermijden, en dat men in computerpro- gramma’s problemen zoals overflow of tekort aan geheugencapaciteit wenst te vermijden.
1.4.2 Waar komt het woord algoritme vandaan?
Een vraag die gesteld kan worden, is waar het woord algoritme vandaan komt. Dit woord is afgeleid van de naam van de arabische wiskundige Abu Ja’far Muhammad ibn Musa al-Khwarizmi. Op de website
http://turnbull.dcs.st-and.ac.uk/∼history/Mathematicians/Al-Khwarizmi.html staat een biografie van deze wiskundige. Hierna volgt een samenvatting
van deze biografie.
Figuur 1.3: Abu Ja’far Muhammad ibn Musa al-Khwarizmi
Er zijn nog vele onzekerheden over het leven van Abu Ja’far Muhammad ibn Musa al-Khwarizmi. Daarom beperken we ons hier tot die zaken over zijn leven waarvan we zeker zijn. Laten we echter eerst de culturele en wetenschappelijke achtergrond schetsen waarin al-Khwarizmi gewerkt heeft.
Harun al-Rashid werd op 14 september 786 de vijfde kalief van de Abbasid dy- nastie. Dit is ongeveer de periode waarin al-Khwarizmi geboren werd. Het ver- moeden is dat hij omstreeks 780 in Bagdad geboren werd. Harun regeerde vanuit Bagdad over het islamrijk dat zich uitstrekte van het middellandse zeegebied tot in India. Hij bracht cultuur in zijn rijk en probeerde de wetenschappelijke disciplines te introduceren die op dat ogenblik nog niet aanwezig waren in de arabische wereld. Hij had twee zonen: de oudste was al-Amin en de jongere was al-Mamun. Harun stierf in 809 en er ontstond na zijn dood een gewapend conflict tussen deze twee broers. Al-Mamun won dit conflict en al-Amin werd gedood in 813. Hieropvolgend
10
￼
werd al-Mamun kalief en regeerde over het rijk vanuit Bagdad. Hij zette de aan- moediging tot leren die gestart was door zijn vader verder en stichtte een academie, genoemd het huis van de wijsheid.
Al-Khwarizmi en zijn collega’s, de Banu Musa, waren leerlingen aan dit huis van de wijsheid. Zijn algebrawerk Hisab al-jabr w’al-muqabala is het beroemdste en belangrijkste van zijn werken. Het is de titel van dit werk dat ons het woord algebra gegeven heeft. Rosen’s vertaling van al-Khwarizmi’s eigen woorden die het doel van dit werk beschrijven, leren ons dat al-Khwarizmi de bedoeling had aan te leren: datgene wat het eenvoudigst en nuttigst is in wiskunde, zoals de zaken die men voortdurend nodig heeft in vererving, verdelingen, processen, en handel, en in al onze zakelijke relaties, waar metingen van land, graven van kanalen, meetkundige berekeningen en andere zaken van allerlei aard optreden.
Dit ziet er op het eerste zicht niet uit als de inhoud van een algebratekst, en inderdaad, enkel het eerste deel van zijn boek gaat over wat wij nu aanduiden met het woord algebra. Het is echter belangrijk te realiseren dat het boek bedoeld was om heel praktisch te zijn, en dat algebra ge ̈ıntroduceerd werd om toenmalige dagdagelijkse problemen in het islamitische rijk op te lossen. In het begin van het boek beschrijft al-Khwarizmi de natuurlijke getallen op een manier die amusant overkomt voor ons die zo vertrouwd zijn met deze getallen: Als ik bekijk wat mensen in het algemeen willen in berekeningen, dan zie ik dat ze altijd een getal willen. Ik heb ook gezien dat elk getal bestaat uit eenheden, en dat elk getal kan opgesplitst worden in eenheden. Verder heb ik nog gezien dat elk getal tussen 1 en 10 het voorgaande getal met precies  ́e ́en eenheid overtreft; daarna wordt de tien verdubbeld of verdrievoudigd net zoals dit vroeger met de eenheden gedaan werd; dus leidend tot twintig, dertig, ..., honderd; dan wordt de honderd op dezelfde manier als de eenheden en de tientallen verdubbeld en verdrievoudigd, . . ., tot duizend; . . . en zo verder.
Nadat hij de natuurlijke getallen geintroduceerd had, introduceerde al-Khwarizmi het belangrijkste onderwerp van het eerste deel van zijn boek, namelijk de oplossing van vergelijkingen. Zijn vergelijkingen zijn lineair of kwadratisch en bestaan uit eenheden, wortels en kwadraten. Bijvoorbeeld, voor al-Khwarizmi was een een- heid een getal, een wortel was x en een kwadraat was x2. Hij reduceerde dan een vergelijking (lineair of kwadratisch) naar  ́e ́en van zes standaardvormen: (1) kwa- draten gelijk aan wortels, (2) kwadraten gelijk aan getallen, (3) wortels gelijk aan getallen, (4) kwadraten en wortels gelijk aan getallen, bv. x2 + 10x = 39, (5) kwa- draten en getallen gelijk aan wortels, bv. x2 + 21 = 10x, en (6) wortels en getallen gelijk aan kwadraten, bv. 3x + 4 = x2. Deze reductie wordt uitgevoerd gebruik- makende van twee bewerkingen: al-jabr en al-muqabala. Hier betekent al-jabr het wegdoen van negatieve termen van een vergelijking. Bijvoorbeeld: al-jabr vereen- voudigt x2 = 40x − 4x2 tot 5x2 = 40x. De bewerking al-muqabala betekent het wegdoen van positieve termen van dezelfde macht als deze aan beide zijden van de vergelijking optreden. Bijvoorbeeld, een keer al-muqabala toepassen op de getallen en een keer op de wortels vereenvoudigt 50+3x+x2 = 29+10x tot 21+x2 = 7x. Al-Khwarizmi toont dan hoe deze zes standaardtypes vergelijkingen opgelost kunnen worden.
Al-Khwarizmi zet zijn studie van algebra verder in Hisab al-jabr w’al-muqabala door de wiskundige rekenregels uit te breiden tot uitdrukkingen van de vorm (a + bx)(c + dx).
Het volgende deel van al-Khwarizmi’s Algebra bestaat uit toepassingen en uit uitgewerkte voorbeelden. Hij zoekt dan verder naar formules om de oppervlakte van
11
figuren zoals de cirkel te vinden, en om formules voor het volume van objecten zoals de bol, de kegel, en de pyramide te vinden.
Al-Khwarizmi schreef ook een boek over de Hindoes-Arabische getallen. De arabische tekst is verloren gegaan, maar er is een latijnse vertaling Algoritmi de numero Indorum (in het engels: Al-Khwarizmi on the Hindu Art of Reckoning), en het is het eerste woord algoritmi uit de titel van dit boek dat geleid heeft tot het woord algoritme. Dit werk beschrijft het Hindoes positioneel systeem van getallen gebaseerd op de cijfers 1,2,3,4,5,6,7,8,9 en 0. Al-Khwarizmi is vermoedelijk de eerste die nul gebruikt heeft in het positioneel getallensysteem.
Een ander belangrijk werk van al-Khwarizmi is zijn boek Sindhind zij over ster- renkunde. De belangrijkste zaken uit dit boek zijn: kalenders (berekenen van de exacte positie van zon, maan, en planeten, tabellen voor sinus en cosinus), sfe- rische sterrenkunde, astrologische tabellen, berekeningen van parallax en eclipsen, en zichtbaarheid van de maan. Hij schreef ook een belangrijk werk over geogra- fie waarin hij de lengte- en breedtemaat gaf van 2402 plaatsen, als basis voor een wereldkaart.
Al-Khwarizmi stierf omstreeks 850.
1.4.3 Al-Khwarizmi’s postzegel
De volgende postzegel werd op 6 september 1983 uitgegeven door de Sov- jetunie ter gelegenheid van de 1200ste verjaardag van de geboorte van al- Khwarizmi. Deze postzegel is te vinden op het www-adres
http://jeff560.tripod.com/
Figuur 1.4: Postzegel van al-Khwarizmi 12
￼
1.4.4 Khwarizmi International Award
De Iranian Organization for Science and Technology (IROST) reikt elk jaar de Khwarizmi Youth and Khwarizmi International Awards uit. Deze prijs bekroont iraanse en buitenlandse onderzoekers voor waardevolle bijdragen in verschillende domeinen van wetenschap en technologie.
Verdere informatie betreffende deze internationale wetenschappelijke prijs is te vinden op de www-pagina’s:
http://www.irost.org/en http://www.irost.org/en/goals
1.4.5 Programma’s
Een (computer)programma is een uitdrukking of eindige reeks uitdrukkingen in een zekere programmeertaal.
De definitie van (computer)programma staat in verband met het begrip algoritme, maar toch zijn ze niet hetzelfde.
Een programma moet opgevat worden als een concrete realisatie van een algoritme.
Dus een algoritme kan leiden tot verschillende programma’s, die zelfs in verschillende programmeertalen ge ̈ımplementeerd kunnen worden.
1.4.6 Correctheid van programma’s
De fundamentele vraag die gesteld kan worden over algoritmes en hun im- plementaties in programma’s is:
Hoe kunnen we zeker zijn dat een algoritme, of zijn implementatie in een programma, de taak waarvoor het opgesteld is, op correcte wijze uitvoert?
Dit is een heel belangrijke vraag. Een concreet voorbeeld.
Op 4 juni 1996 mislukte de lancering van de eerste Ariane-5 raket. Het on- derzoek naar de reden voor het mislukken van de lancering bracht een fout aan het licht bij het omzetten van een 64-bit floating point to 16-bit signed integer. De foutieve omzetting trad op in een routine die herbruikt werd van bij de Ariane-4 ra- ket. Het lanceringstraject van de Ariane-4 raket is echter verschillend van deze van de Ariane-5 raket. De variabele voor de berekening van de horizontale bias, een waarde die in verband staat met de horizontale snelheid, ging over de verwachte grenzen (verwacht voor de Ariane-4 raket), en leidde tot een foutieve waarde, bij de hierboven vermelde omzetting, die de lancering deed mislukken.
Voor meer info en verdere referenties, zie
13
http://www.rvs.uni-bielefeld.de/publications/Reports/ariane.html
In zekere zin is het meestal zo dat we nooit helemaal zeker kunnen zijn.
Soms kan een wiskundig bewijs voor het algoritme opgesteld worden. In vele gevallen wordt een benadering of voorlopige versie van het algoritme opgesteld. Dit wordt dan getest op verschillende inputs, en gebreken die opduiken in de voorlopige versie van het algoritme worden zoveel mogelijk gecorrigeerd.
Voor ingewikkelde programma’s is het soms echter onmogelijk alle ge- vallen te controleren door middel van enkele testgevallen; dus deze methode kan in zo’n geval nooit volledige zekerheid geven.
Voor gevallen waar programmeerfouten niet catastrofaal zijn, kunnen programmeerfouten gecorrigeerd worden naarmate ze opduiken. In andere gevallen kan het essentieel zijn dat alles de eerste keer correct is, en dat men dus zo zeker mogelijk wilt zijn dat dit effectief zo is.
De vraag die dan naar voor treedt is of er een feilloze methode bestaat om de correctheid van alle programma’s te verifi ̈eren.
Dit echter is onmogelijk.
Er bestaat geen feilloze methode om de correctheid van alle computer- programma’s te verifi ̈eren.
Dit gegeven volgt uit de onvolledigheidsstellingen van G ̈odel. Deze onvol- ledigheidsstellingen van Go ̈del zijn fundamentele resultaten over de limieten van het formeel redeneren die een grote invloed gehad hebben op moderne filosofie, wiskundige logica en theoretische informatica.
Voor specifieke programma’s kan soms wel een methode gevonden worden om de correctheid van de programma’s te verifi ̈eren.
Ook voor deze situaties zijn de resultaten van Go ̈del interessant, want uit de resultaten van Go ̈del volgt dat, in het algemeen,
programma’s die de correctheid van andere programma’s moeten verifi ̈eren ingewikkelder zullen zijn dan de programma’s die zij moeten controleren.
We bespreken nu in het volgende deel de recursieve programma’s wiens correctheid gecontroleerd en bewezen kunnen worden via de methode van wiskundige inductie.
1.4.7 Recursieve programma’s
Een recursief programma is een computerprogramma dat zichzelf oproept.
14
Voorbeeld 1
Beschouwen we het volgende voorbeeld. De volgende formule geldt: 20 +21 +22 +···+2n =2n+1 −1.
Bijvoorbeeld:
20 +21 +22 +23 =1+2+4+8=15=16−1=24 −1
en
20 +21 +22 +23 +24 =1+2+4+8+16=31=32−1=25 −1.
Met andere woorden, om 2n+1 − 1 te kunnen berekenen, kan het volgend programma geschreven worden dat enkel de macht n als input moet hebben.
PROGRAMMA machtvantweemineen(n);
ALS n = 0 DAN IS HET RESULTAAT 1;
ANDERS IS HET RESULTAAT machtvantweemineen(n − 1)+2n. EINDE PROGRAMMA
Geeft dit programma nu steeds de correcte uitkomst? Zal met andere woorden voor de input n het programma machtvantweemineen(n) steeds het getal 2n+1 − 1 teruggeven? Of nog, is voor elk natuurlijk getal n geldig dat
20 +21 +22 +···+2n =2n+1 −1?
Dit kan bewezen worden met de methode van bewijs door inductie.
Dit bewijs bestaat uit twee stappen (Sectie 1.3).
(1) Is de formule correct voor de kleinste waarde n = 0? Dit is een een- voudige controle. Voor n = 0 is de som links gelijk aan 20 zelf en dit is gelijk aan 1.
Voor n = 0 is de uitdrukking rechts gelijk aan 20+1 −1 = 21 −1 = 2 − 1 = 1.
Dus links en rechts vinden we dezelfde uitdrukking. De formule is correct voor n = 0.
15
(2) Nu komt de inductiestap. We onderstellen dat de formule correct is als n ingegeven wordt, en we bewijzen dat als de formule geldig is voor n, ze dan ook geldig is voor de opvolger n + 1.
Dus we veronderstellen dat
20 +21 +22 +···+2n =2n+1 −1.
Is nu
20 +21 +22 +···+2n +2n+1 gelijk aan 2n+2 − 1?
(1.6)
(1.7) Door gebruik van formule (1.6) weten we dat in het linkerlid de uit-
drukking 20 +21 +22 +···+2n zich vereenvoudigt tot 2n+1 −1. Dus het linkerlid van (1.7) is gelijk aan 2n+1 −1+2n+1 = 2·2n+1 −1 =
2n+2 −1, en dit is precies de uitkomst die gevraagd werd te controleren. Bijgevolg geldt de formule dus ook voor n + 1.
Uit het principe van bewijs door inductie volgt dat de formule nu geldig is voor alle natuurlijke getallen n.
Het programma machtvantweemineen berekent wel degelijk 2n+1 − 1 als de input n is.
Voorbeeld 2: De torens van Hanoi
In Sectie 1.3.2 hebben we een algoritme opgesteld om het spel de torens van Hanoi te spelen. Dit kunnen we opnieuw vertalen in een recursief algoritme; namelijk in een recursieve procedure.
De procedure roepen we op als Hanoi(n,A,B,C) wat betekent dat we de n schijven van staafje A naar staafje B wensen te verplaatsen, met C als reservestaafje.
Daar we tijdens de recursieve werking van het programma niet exact we- ten van welk staafje naar welk staafje er schijven verplaatst worden, stellen we de staafjes in de procedure voor door de letters x en y, en stelt z het reservestaafje voor, als we n schijven van staafje x naar staafje y wensen te verplaatsen.
PROCEDURE Hanoi(n, x, y, z);
ALS n = 1 DAN verplaats de schijf van staafje x naar staafje y; ANDERS
Hanoi(n − 1, x, z, y)
16
Hanoi(1, x, y, z)
Hanoi(n − 1, z, y, x) EINDE ALS
EINDE PROCEDURE
1.5 Verzamelingen
In deze sectie herhalen we de begrippen en notaties betreffende verzamelin- gen.
Een verzameling A bestaat uit elementen. Verzamelingen zullen we meestal aanduiden met hoofdletters: A, B, C, . . . , en de elementen met kleine letters: a,b,c,...,x,y,z,...,x1,x2,...,
Verzamelingen worden aangeduid via de haakjes { en }, en als de ver- zameling niet te groot is, dan kan ze expliciet beschreven worden door de elementen van de verzameling te geven.
Bijvoorbeeld, A = {5, 7, 8} is de verzameling van de drie elementen 5, 7 en 8.
Soms wordt ”...” gebruikt om de verzameling te beschrijven. Zo is de verzameling {1, 2, 3, 4, . . . , 1000} de verzameling van alle natuurlijke getallen van 1 tot en met 1000. Bij deze notatie wordt wel verondersteld dat ieder- een die deze verzameling ziet, eenvoudig uit de wel expliciet opgeschreven elementen de eigenschap of formule kan afleiden waaraan de elementen van de verzameling voldoen. Is deze eenvoudige eigenschap of formule er niet, dan moet expliciet gezegd worden wat de eigenschap is van de elementen van de verzameling.
Zo is bijvoorbeeld {0,2,4,6,8,...} de verzameling van de even natuur- lijke getallen en is {1, 2, 4, 8, 16, 32, . . .} de verzameling van de machten van 2.
Een eigenschap waaraan de elementen van P = {2, 3, 5, 7, 11, 13, 17, 19, . . .} voldoen, is op het eerste zicht niet af te leiden. De opgeschreven getallen zijn priemgetallen. Een priemgetal is een natuurlijk getal dat in N enkel het getal 1 en zichzelf als factoren heeft. Dus hier moet expliciet bijgeschreven worden dat P de verzameling priemgetallen is.
Er geldt dat er oneindig veel priemgetallen zijn.
Verzamelingen kunnen ook beschreven worden door enkel de eigenschap te geven waaraan de elementen van de verzameling voldoen.
Zo is
P = {n : n is een priemgetal},
N = {n : n is een natuurlijk getal},
17
Z = {n : n is een geheel getal},
Q = {a/b : a, b zijn gehele getallen en b ̸= 0}, R = {x : x is een re ̈eel getal}.
Ook wensen we nog te vermelden dat een element slechts  ́e ́en maal geteld wordt in een verzameling. Dus de verzameling {a, b, a} is gelijk aan {a, b}.
De ledige verzameling wordt aangeduid met ∅.
De kardinaliteit van een verzameling is het aantal elementen van deze verzameling. Dit kan eindig zijn, maar ook oneindig zijn.
De kardinaliteit van een verzameling X wordt aangeduid met |X|. 1.5.1 Klassieke bewerkingen op verzamelingen
(1) (deelverzameling) We schrijven X ⊆ Y om aan te duiden dat elk element van X ook een element is van Y , en we zeggen dat X een deelverzameling is van Y , of nog dat X bevat is in Y .
(2) (doorsnede) Voor elke twee verzamelingen X en Y is de doorsnede X ∩ Y de verzameling van de elementen die zowel tot X als tot Y behoren.
(3) (unie) Voor elke twee verzamelingen X en Y is de unie X ∪ Y de verzameling van de elementen die tot X of tot Y , of tot zowel X als Y , behoren.
(4) (verschil) Het verschil van de verzameling X ten opzichte van de verzameling Y wordt genoteerd met X\Y en bestaat uit alle elementen die tot X behoren, maar niet tot Y behoren.
(5) (machtsverzameling) De machtsverzameling P(X) van een verza- meling X is de verzameling van alle deelverzamelingen van X.
1.5.2 Voorbeeld
Een voorbeeld van de machtsverzameling P(X) van een verzameling X. Stel X = {a,b,c}, dan is
P ({a, b, c}) = {∅, {a}, {b}, {c}, {a, b}, {a, c}, {b, c}, {a, b, c}}.
In het algemeen geldt dat als een verzameling X precies n elementen bezit, dan de machtsverzameling P(X) precies 2n elementen bezit. Of anders gezegd, een verzameling met n elementen heeft precies 2n deelverzamelingen.
In het voorbeeld hierboven, {a, b, c} heeft 23 = 8 deelverzamelingen.
18
1.6 Relaties
1.6.1 Geordende paren en reeksen
Een geordend paar van twee elementen x en y wordt genoteerd met (x,y). Hier speelt de volgorde waarin x en y geschreven zijn een belangrijke rol want
(x1,x2) = (y1,y2) als en slechts als x1 = y1 en x2 = y2.
Analoog zijn er geordende drietallen (x1, x2, x3), viertallen (x1, x2, x3, x4), . . . Algemeen is een geordend n-tal (x1, . . . , xn) een geordende reeks van n elementen. Zo’n n-tal wordt ook nog een reeks of lijst genoemd.
Een ander belangrijk verschil tussen verzamelingen en reeksen is dat een element meerdere keren in een lijst mag voorkomen; in een verzameling komt een element maar hoogstens  ́e ́en keer voor.
1.6.2 Relaties
Beschouw twee verzamelingen A en B. De verzameling van alle geordende paren (a, b), met a ∈ A en b ∈ B, wordt het cartesiaans product A × B van A en B genoemd.
Een binaire relatie is een verzameling R van geordende paren. We noe- men R een binaire relatie op een verzameling A als R bestaat uit geordende paren elementen uit A; dus als R een deelverzameling is van A × A = A2.
1.6.3 Voorbeeld
Beschouw de verzameling A = {2, 6, 12}, dan is
A2 = {(2, 2), (2, 6), (2, 12), (6, 2), (6, 6), (6, 12), (12, 2), (12, 6), (12, 12)}.
De relatie R van de koppels (a,b) uit A2, met a ≤ b, is dan gelijk aan R = {(2,2),(2,6),(2,12),(6,6),(6,12),(12,12)}; dus R stelt de klassieke relatie is kleiner dan of gelijk aan voor op A.
1.6.4 Domein en codomein
Het domein domR van een relatie R is de verzameling van alle elementen die optreden in de eerste positie van een element uit R.
Het codomein van een relatie R is de verzameling van alle elementen die optreden op de tweede positie van een element van R.
De inverse relatie R−1 van R is de verzameling R−1 = {(y, x) : (x, y) ∈ R} en bestaat dus uit alle koppels uit R waarin de volgorde van de elementen omgekeerd is.
19
￼1.6.5 Opmerkingen
(1) Algemeen kan ook nog een n-aire relatie gedefinieerd worden; dit is een deelverzameling van An; dus een verzameling geordende n-tallen uit A.
(2) En ook kunnen geordende n-tallen bestaande uit elementen uit wil- lekeurigeverzamelingenA1,...,An gedefinieerdworden.
Het cartesiaans product A1 × · · · × An van de verzamelingen A1, . . . , An is de verzameling bestaande uit alle geordende n-tallen (a1,...,an), met a1 ∈ A1,...,an ∈ An.
1.6.6 Voorbeelden
(1) Een ternaire relatie R op de verzameling mensen kan gegeven worden door (a,b,c) ∈ R als en slechts als a en b de ouders zijn van c.
(2) Een ternaire relatie R op de verzameling re ̈ele getallen kan gegeven worden door (a, b, c) ∈ R als en slechts als b tussen a en c ligt; dus a ≤ b ≤ c of c ≤ b ≤ a.
(3) Andere voorbeelden van relaties kunnen gevonden worden in relatio- nele gegevensbanken.
1.6.7 Samenstelling van twee relaties
Voor twee relaties R en S, is de samenstelling S◦R van R en S, lees S na R, gedefinieerd op de volgende manier: het koppel (x, y) ∈ S ◦ R als en slechts als er een zekere z bestaat waarvoor (x, z) ∈ R en waarvoor (z, y) ∈ S.
Hier dient wel opgelet te worden wat de preciese ordening van R en S is. Bij de samenstelling S ◦ R is R de relatie die het eerst toegepast dient te worden, en pas daarna wordt S toegepast.
Dit wordt duidelijk gemaakt aan de hand van de volgende figuur.
Figuur 1.5: Samenstelling van twee relaties
20
￼￼
1.6.8 Voorbeeld
Stel dat R de relatie is broer van is, en stel dat S de relatie is vader van is, dan is S ◦ R de relatie is oom van.
Want als x in relatie staat tot y via de samenstelling S ◦ R, dan moet er een persoon z zijn zodat x in relatie staat met z via de relatie R en z moet zelf in relatie staan met y via de relatie S. En dit geldt maar als x een broer is van z en z de vader is van y, dus x is een oom van y.
Opmerking 1.6.9 We kiezen voor deze definitie van de samenstelling van twee relaties omdat we in Paragraaf 1.8 over functies een functie f steeds voor zijn argument x zullen schrijven in de notatie f(x), en dit in tegenstel- ling tot de Poolse notatie.
1.7 Ordeningen
In Paragraaf 1.2.5 hebben we al de ordening op de gehele getallen vermeld. Nu zullen we ordeningen algemeen defini ̈eren als belangrijke voorbeelden van relaties R op een verzameling X.
1.7.1 Definities
Een relatie R op een verzameling X is
(1) reflexief als (x, x) ∈ R voor alle x in X;
(2) anti-symmetrisch als er geldt dat als (x,y) ∈ R en (y,x) ∈ R, dan noodzakelijk x = y;
(3) transitief als er geldt dat als (x,y) ∈ R en (y,z) ∈ R, dan ook (x,z) ∈ R.
(4) totaalalsergeldtdat(x,y)∈Rof(y,x)∈RvoorallexenyinX.
De hierboven gedefinieerde termen spelen nu een cruciale rol in het de- fini ̈eren van ordeningen.
De structuur (X, ≤) is een partieel geordende verzameling als ≤ een re- latie is op X die reflexief, anti-symmetrisch en transitief is.
Als de ordening ≤ totaal is, dan is (X, ≤) een totaal geordende verzame- ling; dus elke twee elementen van X kunnen vergeleken worden met elkaar.
1.7.2 Voorbeelden
(1) (N, ≤), (Z, ≤), (Q, ≤), en (R, ≤) vormen klassieke voorbeelden van totaal geordende verzamelingen.
21
(2) Beschouw een verzameling X en zijn bijhorende machtsverzameling P(X). De machtsverzameling P(X) van een verzameling X, tesamen met de inclusie ⊆ als orderelatie ≤ is een voorbeeld van een partieel geordende verzameling.
Beschouw de verzameling X = {∅, {a}, {b}, {a, c}, {a, b}, {b, c}}. De vol- gende figuur geeft de ordening op de elementen van X, bepaald door de inclusie, schematisch weer.
Figuur 1.6: Parti ̈ele ordening
1.7.3 Definities
Als (X, ≤) een partieel geordende verzameling is, dan is een element x ∈ X maximaal als er geldt dat als x ≤ y, dan y = x; dus er is geen element strict groter dan x. Het element x is het grootste element als y ≤ x voor alle y ∈ X.
Een element x ∈ X is minimaal als er geldt dat als y ≤ x, dan y = x; dus er is geen element strict kleiner dan x. Het element x is het kleinste element als x ≤ y voor alle y ∈ X.
1.7.4 Opmerking
Het verschil tussen een maximaal element van (X, ≤) en het grootste element van (X, ≤) is dat het grootste element van (X, ≤) groter dan of gelijk is aan elk element van X. Een maximaal element van (X, ≤) is groter dan of gelijk aan elk element van X waarmee het vergeleken kan worden binnen de ordening ≤.
Ook kunnen er binnen een partieel geordende verzameling meerdere ma- ximale elementen zijn, maar het grootste element, als het bestaat, is uniek. Zo zijn {a, b}, {a, c} en {b, c} maximale elementen in Voorbeeld 1.7.2 (2), maar het zijn geen grootste elementen. De verzameling (X,≤) heeft zelfs
geen grootste element.
Analoge opmerkingen kunnen gemaakt worden over minimale elementen
￼￼en het kleinste element.
22
In Voorbeeld 1.7.2 (2) is er slechts  ́e ́en minimaal element, namelijk ∅, en dit is ook het kleinste element.
1.7.5 Definitie van strict parti ̈ele ordeningen
Een relatie R op een verzameling X is asymmetrisch als (x,y) ∈ R en (y, x) ∈ R niet beide terzelfdertijd kunnen geldig zijn.
Een strict parti ̈ele ordening is een transitieve, asymmetrische relatie. Voorbeeld
(N, <), (Z, <), (Q, <) en (R, <) zijn verzamelingen met stricte parti ̈ele orde- ningen.
Voor bijvoorbeeld twee natuurlijke getallen is het niet mogelijk dat ter- zelfdertijd x < y en y < x.
1.7.6 Kleinste bovengrens en grootste ondergrens
Beschouw een partieel geordende verzameling (X, ≤) en beschouw twee ele- menten x en y van X.
(1) Als er een element z ∈ X bestaat waarvoor 1. z≤xenz≤y;
2. voorelkelementt∈X,alst≤xent≤y,danist≤z, dan wordt z de grootste ondergrens van x en y genoemd.
(2) Als er een element z ∈ X bestaat waarvoor 1. x ≤ z en y ≤ z;
2. voorelkelementt∈X,alsx≤teny≤t,danisz≤t, dan wordt z de kleinste bovengrens van x en y genoemd.
Als de grootste ondergrens, respectievelijk de kleinste bovengrens, van twee elementen x en y bestaat, dan is deze uniek.
De grootste ondergrens van x en y wordt genoteerd met x ∧ y en de kleinste bovengrens van x en y wordt genoteerd met x ∨ y.
1.7.7 Voorbeeld
Beschouw een verzameling X en haar machtsverzameling P(X). Beschouw P(X) en de parti ̈ele ordening bepaald door de inclusie ⊆. Dan hebben elke twee elementen A en B van P(X) een grootste ondergrens A ∧ B = A ∩ B en een kleinste bovengrens A ∨ B = A ∪ B.
23
1.8 Functies
Functies vormen een essentieel onderdeel in een studie over informatica. Een computerprogramma dat input omzet in output kan beschreven wor-
den als een functie van de input naar de output.
In dit opleidingsonderdeel zullen wij bespreken welke functies bereken-
baar zijn; welke functies via een eindig algoritme ge ̈ımplementeerd kunnen worden op een computer?
In deze sectie zullen we de notaties en definities vastleggen waarop ge- steund zal worden.
1.8.1 Definitie van een functie
Een functie is een binaire relatie R waarvoor geldt dat geen enkel element van het domein meer dan  ́e ́en keer voorkomt als eerste coo ̈rdinaat in een koppel uit de relatie.
Dus, als a ∈ domR, dan is er een uniek element b zodat (a, b) ∈ R. 1.8.2 Opmerking
In het algemeen zullen de letters f,g,h,..., gebruikt worden om functies aan te duiden.
Alhoewel we functies hiervoor gedefinieerd hebben als verzamelingen ge- ordende paren, is het meer gebruikelijk om ze te interpreteren als rekenregels of verbanden.
Namelijk, als x ∈ domf, dan is er een unieke y waarvoor (x,y) ∈ f, en dit wordt genoteerd met y = f(x).
Als f een functie is die een deelverzameling is van X × Y , dan noteren we dit ook als
f:X→Y
en we spreken van een functie van X naar Y .
Indien beschikbaar, dan schrijven we ook op de volgende manier het
verband tussen x en f(x) erbij:
f:X→Y :x􏰀→f(x).
Bijvoorbeeld, de functie f = {(x,x2) : x is een natuurlijk getal} wordt genoteerd als
f :N→N:x􏰀→x2.
24
1.8.3 1-1 functies
Een functie f is een 1-1 functie als verschillende elementen uit het domein afgebeeld worden op verschillende elementen uit het codomein.
1.8.4 Opmerking
De motivering voor deze definitie van 1-1 functies volgt uit de studie van de inverse van een functie.
Een functie f van X naar Y is eerst en vooral een relatie R die een deelverzameling is van X × Y .
De inverse relatie f−1 is altijd gedefinieerd; ze wordt bekomen door in alle koppels (x,f(x)) de volgorde om te keren; dus f−1 = {(f(x),x) : x ∈ domf }.
Maar de inverse relatie f−1 is niet altijd een functie; als x1 ̸= x2 en f(x1) = f(x2), dan behoren beide koppels (f(x1),x1),(f(x2),x2) tot f−1; dus er zijn twee koppels in f−1 met hetzelfde eerste element f(x1) = f(x2); dus f−1 is geen functie.
Er geldt dat f−1 een functie is als en slechts als er een 1-1 verband is tussen de elementen van het domein van f en de elementen van het codomein van f.
1.9 Parti ̈ele functies
We hebben reeds opgemerkt dat een computerprogramma kan gezien worden als een functie van de input naar de output. Gegeven de input, dan wordt de input door het computerprogramma omgezet naar de output.
Dit is echter een zienswijze die met de nodige voorzichtigheid gepaard moet gaan.
Alhoewel computerprogramma’s gewoonlijk geschreven worden met de intentie dat ze zouden moeten eindigen, is het dikwijls moeilijk te verzekeren dat voor een gegeven input het programma wel degelijk na een eindig aantal stappen een output zal geven.
Naast het vermijden van oneindige lussen zoals x := 0;
while x ≥ 0 do x := x + 1;
kan het in een ingewikkeld programma moeilijk zijn om het overzicht te behouden over de lussen, iteraties en/of recursies in het programma.
Dus het domein, de verzameling inputs waarvoor het programma in een eindig aantal stappen de output geeft, kan een ingewikkelde verzameling zijn; soms zo ingewikkeld dat we verkiezen om deze niet expliciet te beschrijven.
25
Het probleem om te vinden voor welke inputs een gegeven programma eindigt, wordt het halting (stop) probleem genoemd, en het feit dat er geen algoritme bestaat om dit probleem op te lossen, zal later in deze cursus besproken worden.
De hiervoor gemaakte bedenkingen hebben geleid tot het begrip parti ̈ele functie in de informatica.
1.9.1 Parti ̈ele functies
Een parti ̈ele functie van X naar Y is een functie f waarvoor domf ⊆ X en codomeinf ⊆ Y .
Als we wensen te benadrukken dat een functie f : X → Y wel degelijk domein X heeft, dan zeggen we dat f totaal is. Als f een parti ̈ele functie is van X naar Y en x ∈ X \ domf, dan zeggen we dat f(x) ongedefinieerd is.
1.9.2 Voorbeelden
(1) Beschouw het volgende computerprogramma. Stel dat de input n een natuurlijk getal moet zijn.
read(n);
while n > 1 do
begin
if n is even then n := n/2 else n := 2n + 1
end; write(n);
Wat is het effect van dit programma? Het programma schrijft n = 0 en n = 1 onmiddellijk uit. Voor n > 1 komt het in de while-lus terecht. In deze while-lus wordt n gehalveerd tenzij het oneven is. Als n oneven wordt, dan wordt het tweede gedeelte van de while-lus opgeroepen en n wordt een groter oneven getal, en blijft voor altijd vergroten en oneven.
Dit toont aan dat de functie f : N → N gedefinieerd door het programma als volgt beschreven wordt:
 0 f(n) = 1
als n = 0
als n een macht van 2 is in de andere gevallen
 ongedefinieerd Dusf:N→Niseenparti ̈elefunctiemetdomein{0}∪{2r :r∈N}.
(2) Beschouw de volgende kleine variatie op voorbeeld (1).
read(n);
while n > 1 do
26
begin
if n is even then n := n/2 else n := 3n + 1
end; write(n);
Van dit programma is het niet geweten voor welke waarden van de input n het programma eindigt. Het vermoeden is dat het zal eindigen voor alle natuurlijke getallen n.
Totdat dit effectief zeker is, kunnen we enkel stellen dat dit programma een parti ̈ele functie van N naar N definieert.
Om het grillig verloop van dit programma voor verschillende inputs n te illustreren, tonen we het verloop van het programma voor inputs n = 3, 21, 25.
Namelijk
3,10,5,16,8,4,2,1 stop
21,64,32,16,8,4,2,1 stop 25,76,38,19,58,29,88,44,22,11,34,17,52,26,13,40,20,10,5,16,8,4,2,1 stop
Dit probleem wordt het Collatz-probleem genoemd en werd voor het eerst geformuleerd door Lothar Collatz in 1937. De wikipedia pagina
http://nl.wikipedia.org/wiki/Vermoeden van Collatz
vertelt meer over dit Collatz-probleem.
1.10 Equivalentierelaties
Een equivalentierelatie is een bijzonder type relatie dat op vele vlakken ver- schilt van functies, maar dat toch ook heel belangrijk is.
Intu ̈ıtief zijn de equivalentierelaties die relaties die de meest belangrijke eigenschappen van gelijkheid tussen elementen benaderen; in een equivalen- tierelatie worden elementen die op elkaar gelijken verzameld in equivalentie- klassen.
Echter, een verschil met de intu ̈ıtieve benadering van functies en equiva- lentierelaties is dat de intu ̈ıtie betreffende functies is dat functies methodes zijn om van  ́e ́en verzameling naar een andere (of dezelfde) verzameling te gaan: een element van een eerste verzameling wordt in verband gebracht met een element van een andere verzameling.
Equivalentierelaties echter zijn steeds gedefinieerd op de elementen van  ́e ́en verzameling.
27
￼￼
1.10.1 Definities
Beschouw de volgende drie eigenschappen die kunnen gelden voor een relatie R op een verzameling X.
(1) reflexief: (x, x) ∈ R voor alle x ∈ X;
(2) symmetrisch: als (x, y) ∈ R, dan ook (y, x) ∈ R;
(3) transitief: als (x,y) ∈ R en (y,z) ∈ R, dan (x,z) ∈ R.
Een relatie die reflexief, symmetrisch en transitief is, wordt een equiva- lentierelatie op X genoemd.
Als R een equivalentierelatie is op een verzameling X, dan gebruiken we ook de notatie x ∼ y als (x, y) ∈ R.
Intu ̈ıtief komt de notatie neer op het feit dat als x ∼ y, dan gelijken x en y op elkaar volgens de relatie R.
1.10.2 Voorbeelden
(1) De relatie = op een verzameling X is het eenvoudigste voorbeeld van een equivalentierelatie.
(2) Beschouw de verzameling van de gehele getallen. We defini ̈eren ∼ op Z door te stellen dat a ∼ b als en slechts als a − b even is.
Dit is een equivalentierelatie. Want ∼ is reflexief daar a − a = 0 even is. Als a ∼ b, dan is a − b even; dus ook b − a is even; dus ook b ∼ a.
Entenslotte,alsa∼b,enb∼c,danisooka∼c. Wantalsa−beven is, en ook b − c even is, dan is ook a − c = (a − b) − (c − b) even.
(3) Beschouw de verzameling X van alle computerprogramma’s geschre- ven in een zekere programmeertaal.
Beschouw twee computerprogramma’s P en Q. Stel P ∼ Q als voor alle inputs I:
(a) het programma P output geeft na een eindig aantal stappen als en slechts als het programma Q output geeft na een eindig aantal stappen, en
(b) als dit zo is, dat dan beide outputs gelijk zijn.
Dan is ∼ een equivalentierelatie op X.
(4) Beschouw de relatie . . . is even oud als . . . op de verzameling van alle mensen. Dit is een equivalentierelatie.
Zoals de relatie ... is even oud als ... uitdrukt, ook deze equivalentie- relatie vertolkt een zekere gelijkheid tussen mensen; twee mensen die even oud zijn, hebben dezelfde leeftijd.
28
1.10.3 Equivalentieklassen
De belangrijkste stelling betreffende equivalentierelaties op een verzameling X zegt dat elke equivalentierelatie R op X de verzameling X in equivalen- tieklassen verdeelt. Deze equivalentieklassen zijn:
(1) niet-ledig;
(2) twee verschillende equivalentieklassen hebben geen elementen gemeen; en
(3) de unie van al de verschillende equivalentieklassen is de volledige verza- meling X.
De betekenis van deze equivalentieklassen is dat de elementen uit een equivalentieklasse op elkaar gelijken voor deze equivalentierelatie.
Figuur 1.7: Equivalentieklassen op Z 1.10.4 Voorbeelden
(1) De equivalentierelatie gedefinieerd in Voorbeeld 1.10.2 (2) verdeelt de verzameling van de gehele getallen in twee equivalentieklassen, bestaande uit respectievelijk de even en oneven gehele getallen; zie ook Figuur 1.7.
(2) Beschouw Voorbeeld (3) uit Voorbeeld 1.10.2.
Beschouw de computer waarop de computerprogramma’s uit X werken. In Voorbeeld 1.10.2 (3) hebben we twee programma’s P en Q met elkaar
in verband gebracht via de relatie ∼ als en slechts als er voor elke input I geldt dat:
(a) het programma P output geeft na een eindig aantal stappen als en slechts als het programma Q output geeft na een eindig aantal stappen, en
(b) als dit zo is, dat dan beide outputs gelijk zijn.
29
￼
Dus met andere woorden, voor deze computer zijn de programma’s P en Q gelijk, want hetzelfde effect wordt waargenomen.
(3) En beschouw tenslotte Voorbeeld (4) uit Voorbeeld 1.10.2. Hier bestaan de equivalentieklassen van de equivalentierelatie . . . is even oud als ... uit de klassen van personen met dezelfde leeftijd. Mensen die dezelfde leeftijd hebben, behoren tot dezelfde equivalentieklasse.
1.11 Aftelbare en niet-aftelbare verzamelingen
Oneindige verzamelingen treden op verschillende plaatsen op bij de studie van problemen in de informatica. Vele van de objecten waarmee een com- puter werkt, zijn elementen van een oneindige verzameling, of zijn benade- ringen voor oneindige objecten.
Ook treden er soms vreemde verschillen op tussen oneindige verzamelin- gen. Er zijn oneindige verzamelingen die evenveel elementen bevatten, maar er zijn ook oneindige verzamelingen die een verschillend aantal elementen bevatten.
E ́en van de doelen van deze sectie is om hier duidelijkheid in te brengen, en ook zullen we kijken naar een belangrijke toepassing van deze studie voor de informatica; namelijk, we geven in dit opleidingsonderdeel het antwoord op de vraag:
Kunnen alle problemen opgelost worden door een computer?
1.11.1 Oneindige kardinaalgetallen
Beschouw twee eindige verzamelingen, dan is het eenvoudig na te gaan of ze dezelfde kardinaliteit hebben. We tellen gewoon het aantal elementen in beide verzamelingen en we kijken of we twee keer hetzelfde getal bekomen.
Voor oneindige verzamelingen is dit niet meer te doen. Beschouw N = {0, 1, 2, . . .} en N \ {0} = {1, 2, 3, 4, . . .}.
Hebben deze twee oneindige verzamelingen hetzelfde aantal elementen, of verschillen ze precies met  ́e ́en in hun kardinaliteit?
Om hierop het antwoord te vinden, bekijken we opnieuw het probleem wanneer twee eindige verzamelingen dezelfde kardinaliteit hebben.
Van twee eindige verzamelingen X en Y kan aangetoond worden dat ze dezelfde kardinaliteit hebben als het mogelijk is een 1-1 verband te vinden tussen de elementen van X en de elementen van Y . Dus elk element van X correspondeert in dit verband met precies  ́e ́en element van Y , en omgekeerd correspondeert elk element van Y (onder het invers verband) met precies  ́e ́en element van X.
30
Bijvoorbeeld, de verzamelingen X = {1,2,3} en Y = {2,4,6} hebben dezelfde kardinaliteit, want de functie
f : X → Y : x 􏰀→ 2x
geeft een 1-1 verband tussen X en Y .
Dus met andere woorden: voor twee eindige verzamelingen geldt het
volgende resultaat:
|X|=|Y| als en slechts als er een 1-1 functie f is tussen X en Y.
Dit kan nu uitgebreid worden tot twee oneindige verzamelingen X en Y . Voor twee oneindige verzamelingen X en Y geldt dat |X| = |Y | als en
slechts als er een 1-1 functie f is tussen X en Y . Vooraleer verder te gaan, enkele voorbeelden.
1.11.2 Voorbeelden
(1) N en N \ {0} hebben evenveel elementen. Namelijk, definieer f :N→N\{0}:n􏰀→n+1.
Dan wordt elk element van N afgebeeld op  ́e ́en element van N \ {0}, en omgekeerd correspondeert elk element m van N \ {0} met het element m − 1 van N.
Er is dus een 1-1 verband tussen beide verzamelingen; beide hebben de- zelfde kardinaliteit.
(2) N en de verzameling E = {0,2,4,6,...} van de even natuurlijke getallen hebben dezelfde kardinaliteit.
Namelijk
f : N → E : n 􏰀→ 2n is een 1-1 functie tussen beide verzamelingen.
(3) Ook de verzamelingen N en Z hebben dezelfde kardinaliteit, en even- eens de verzamelingen N en Q van de natuurlijke en de rationale getallen hebben dezelfde kardinaliteit.
1.11.3 Aftelbare verzamelingen
Beschouw een oneindige verzameling X. Indien er een 1-1 functie tussen de verzameling N en de verzameling X gevonden kan worden, dan wordt X een aftelbare verzameling genoemd (we kunnen dan inderdaad de elementen van X  ́e ́en voor  ́e ́en aftellen).
Indien er geen dergelijke 1-1 functie tussen de verzameling N en de ver- zameling X bestaat, dan noemen we X een niet-aftelbare verzameling.
31
1.11.4 Opmerking
De voorgaande definitie toont aan dat we onder de oneindige verzamelingen een onderscheid maken tussen de aftelbare en de niet-aftelbare verzamelin- gen.
We zullen de eindige verzamelingen eveneens als aftelbare verzamelingen beschouwen; ook van deze verzamelingen kunnen we het aantal elementen tellen.
De vraag is of er voorbeelden bestaan van niet-aftelbare verzamelingen.
Het antwoord is wel degelijk ja; de verzameling van de re ̈ele getallen R is een niet-aftelbare verzameling.
1.11.5 R is een niet-aftelbare verzameling
De verzameling R is een niet-aftelbare verzameling. We tonen aan dat het onmogelijk is om een 1-1 verband tussen de elementen van N en R te vinden. We bewijzen dit door aan te tonen dat het interval [0,1] van R zelf al een niet-aftelbare verzameling is. Hier is het interval [0, 1] de verzameling
van alle re ̈ele getallen x met 0 ≤ x ≤ 1.
Veronderstel het tegendeel. Dan is er een 1-1 functie f van N naar het
interval [0, 1], en ontstaan de volgende waarden:
voorkomen. We noemen
waarbij
x = 0,x1x2x3x4 ...
x1 =
x2 =
x3 =
.
􏰁a0+1 alsa0≤7 a0 − 1 als a0 ≥ 8
􏰁b1+1 alsb1≤7 b1 − 1 als b1 ≥ 8 􏰁c2+1 alsc2≤7 c2 − 1 als c2 ≥ 8
f(0) =
f(1) =
f(2) =
f(3) =
.
0, a0b0c0d0 . . . 0, a1b1c1d1 . . . 0, a2b2c2d2 . . . 0, a3b3c3d3 . . . .
Hierbij staan ai, bi, . . . voor  ́e ́en van de cijfers 0 tot en met 9.
We produceren nu een re ̈eel getal tussen 0 en 1 dat niet in de lijst kan
.
32
Stel bijvoorbeeld dat de lijst waarvan wij vertrekken op de volgende manier begint. Hierbij onderlijnen we in het getal f (n) steeds het (n + 1)-ste getal na de komma.
f(0) = f(1) = f(2) = f(3) = f(4) = f(5) = . .
Dan zal het getal x beginnen als
doet er niet toe, het is alleen belangrijk om te bewijzen dat x niet kan voorkomen in de lijst getallen waarvan wij vertrokken zijn. Inderdaad, voor n = 0,1,2,... zal het getal x met het getal f(n) verschillen op de (n + 1)- ste plaats na de komma. Bijgevolg zal het interval [0,1] en dus ook de verzameling R niet aftelbaar zijn.
Opmerking 1.11.6 De hiervoor gebruikte methode is de klassieke methode om aan te tonen dat bepaalde oneindig grote verzamelingen X niet-aftelbaar zijn.
Deze methode wordt de diagonalisatiemethode genoemd, omdat het idee in deze methode is te onderstellen dat de oneindig grote verzameling X wel aftelbaar is, en er een 1-1 functie is tussen N en X, en dan een contradictie af te leiden door een nieuw element te construeren voor de verzameling X door de diagonaal in de tabel af te lopen, en steeds het element op die diagonaal te veranderen.
Het nieuw opgestelde element uit de verzameling X moet ergens op een rij optreden in de tabel, maar tegelijkertijd kan het niet optreden in de tabel, want het nieuw opgestelde element verschilt met elke rij in de positie van de diagonaal.
Dus we krijgen tegenstrijdige resultaten. De onderstelling dat de onein- dig grote verzameling X wel aftelbaar is, kan niet waar zijn.
Er is bewezen dat de oneindig grote verzameling X niet-aftelbaar is. Zij is groter dan aftelbaar, zij heeft meer elementen dan er natuurlijke getallen zijn.
1.11.7 Kardinaalgetallen
Beschouwen we nu de verzameling N. We noteren het kardinaalgetal van deze verzameling (en van elke verzameling die oneindig en aftelbaar is) als א0 (aleph-naught). Beschouw nu de afbeelding f gedefinieerd door f(n) = n+1, ∀n ∈ N. Dan is f een 1-1 verband van N naar N0, en bijgevolg is
33
0,772563... 0,092971... 0,000000... 0,000722... 0,000998... 0,227354... .
￼￼￼￼￼￼0,
881885 . . .. De preciese waarde van x
|N0| = |N| = א0. Anderzijds is
N = N0 ∪ {0},
zodat, indien we de optelling van eindige kardinaalgetallen tot de oneindige
kardinaalgetallen willen uitbreiden,
א0 = א0 + 1.
Dit betekent bijvoorbeeld dat bij het rekenen met oneindige kardinaalgetal- len de schrappingswet niet geldt, want anders zou 0 = 1.
De ogenschijnlijke paradox is het gevolg van het feit dat er 1-1 verbanden bestaan van de verzameling N naar eigenlijke deelverzamelingen van N. Het 1-1 verband tussen N en de verzameling E van de even natuurlijke getallen (zie 1.11.2 (2)) is hier een voorbeeld van.
De theorie van de oneindige kardinaalgetallen werd ontwikkeld door Georg Can- tor (1845–1918).
1.12 Toepassing in de informatica
Beschouw een computerprogramma dat  ́e ́en natuurlijk getal als input aan- vaardt en dat op deze input bewerkingen uitvoert die opnieuw een natuurlijk getal opleveren.
We hebben opgemerkt in Paragraaf 1.8 dat dit computerprogramma ge- zien kan worden als de concrete realisatie van een functie van N naar N; het computerprogramma kan in feite vereenzelvigd worden met deze functie.
Een eerste fundamentele vraag die gesteld kan worden is of elke functie van N naar N ge ̈ımplementeerd kan worden in een computerprogramma. Dus neem een zekere programmeertaal, kan elke functie van N naar N ge ̈ımplementeerd worden in een eindig aantal instructies?
Om het antwoord te vinden op deze vraag, zullen we proberen het aantal functies van N naar N te tellen en ook het aantal programma’s die geschreven kunnen worden in een zekere programmeertaal te tellen.
We zullen dit doen in een aantal stappen om de idee ̈en en de gebruikte technieken voor de oplossing van dit type probleem naar voor te brengen.
1.12.1 Woorden over een alfabet
Beschouw een alfabet. Dit is een eindige verzameling symbolen.
Voor de eenvoud nemen we als alfabet ons standaardalfabet bestaande
uit de letters a,. . .,z.
Een woord over dit alfabet is een eindige reeks letters. Om het probleem
eenvoudig te houden, eisen we niet dat de woorden een betekenis moeten hebben; ze moeten enkel een eindige reeks letters zijn.
34
Stelling 1.1 Het aantal woorden over het alfabet {a,. . . ,z} is aftelbaar.
Bewijs. Om aan te tonen dat het aantal woorden over het alfabet af- telbaar is, moet er aangetoond worden dat er een 1-1 verband tussen de verzameling van de natuurlijke getallen N en de verzameling woorden be- staat.
Dus er moet aangetoond worden dat het mogelijk is om aan elk woord een nummer te geven dat een natuurlijk getal is.
Dit kan op de volgende manier gedaan worden.
Rangschik de woorden alfabetisch en volgens stijgende lengte. Dus eerst worden de woorden van lengte 1 alfabetisch opgeschreven, dan worden de woorden van lengte 2 alfabetisch opgeschreven, dan de woorden van lengte 3 alfabetisch,. . .
Dit geeft het volgende schema:
a, b, c, ..., z
aa, ab, ac, ..., ..., zz
aaa, aab, aac, ..., ... ..., zzz
. ···, ···, ···, ···, ···, ···,
Door de woorden op deze manier op te schrijven, kunnen we ze elk een nummer geven.
Namelijk, we doorlopen de rijen  ́e ́en voor  ́e ́en van links naar rechts; op deze manier krijgt elk woord een rangnummer.
Maar dit rangnummer toont aan dat elk woord dus effectief een nummer kan krijgen.
Dus het is mogelijk een 1-1 verband tussen de natuurlijke getallen en de woorden te defini ̈eren.
Dit bewijst dat het aantal woorden over het alfabet aftelbaar is. P Opmerking 1.12.2 Het belangrijkste idee in het opschrijven van de woor-
den volgens rijen, is
dat de rijen eindige lengte hebben.
Enkel bij rijen van eindige lengte kun je bij het tellen overgaan naar de volgende rij.
Als je een rij hebt die oneindig lang is, en je telt hoeveel elementen er op die rij staan, dan stop je nooit met tellen op die oneindig lange rij, en dus zul je nooit eens de elementen op de volgende rij tellen, dus een nummer geven.
35
1.12.3 Zinnen over een alfabet
In de vorige paragraaf hebben we woorden over het alfabet a,. . .,z gedefini- eerd.
Met woorden kunnen we nu zinnen vormen. Een zin is een eindige op- eenvolging van woorden.
Opnieuw, om de redenering zo eenvoudig mogelijk te maken, is het niet nodig dat de zinnen enige betekenis hebben.
De vraag is nu of het aantal zinnen over een eindig alfabet aftelbaar is. Dit blijkt wel degelijk zo te zijn.
Stelling 1.2 Het aantal zinnen over het alfabet {a, . . . , z} is aftelbaar.
Bewijs. Dit kan heel eenvoudig bewezen worden als de idee ̈en uit het bewijs van Stelling 1.1 op een slimme manier gebruikt worden.
Wat is een zin? Een zin is een eindige opeenvolging van woorden, met spaties ertussen.
Noteer een spatie met het symbool P.
Wat is een zin als je je alfabet zou gelijk stellen aan {a, . . . , z, P}?
Als je het alfabet gelijk stelt aan {a, . . . , z, P}, dan is een zin in feite een
woord over dit alfabet.
Dus alle idee ̈en uit het bewijs van Stelling 1.1 kunnen herbruikt worden
om aan te tonen dat het aantal zinnen over het alfabet {a, . . . , z} aftelbaar is. P
1.12.4 Functies van N naar N
Beschouw een willekeurige functie f van N naar N. Dan weten we dat f met elk natuurlijk getal n een zeker natuurlijk getal f(n) laat corresponderen.
We kunnen dus elke functie f van N naar N defini ̈eren door de lijst van beelden van de natuurlijke getallen onder f te geven. Namelijk,
0 􏰀→ f(0) 1 􏰀→ f(1) 2 􏰀→ f(2)
. . .
Er zijn oneindig veel dergelijke functies f van N naar N. Opnieuw kunnen we de vraag stellen of het aantal functies van N naar N aftelbaar is.
Hier blijkt het antwoord negatief te zijn.
Stelling 1.3 De verzameling van alle functies van N naar N is niet-aftelbaar.
Bewijs. Dit kan volledig analoog bewezen worden via de diagonalisa- tiemethode (Sectie 1.11.6), die we gebruikt hebben om aan te tonen dat de verzameling R van de re ̈ele getallen niet-aftelbaar is (Sectie 1.11.5). P
36
1.12.5 Toepassing voor computerprogramma’s
Beschouw een programmeertaal. Stel dat deze programmeertaal een eindig aantal symbolen gebruikt. Bijvoorbeeld, de letters a, . . . ,z, de cijfers 0, 1, . . . , 9, en eventueel enkele andere symbolen zoals bijvoorbeeld ” : ”, ”; ”, ” ∗ ”, ” + ”, ”(” en ”)”.
Net zoals hiervoor noemen we deze letters, cijfers en symbolen het alfabet van de programmeertaal.
Met deze programmeertaal schrijven we nu programma’s met eindige lengte (zie Sectie 1.4.5) om functies van N naar N te programmeren.
Dan geldt er
Stelling 1.4 Het aantal computerprogramma’s dat kan geschreven worden in een programmeertaal met een eindig aantal symbolen is aftelbaar.
Bewijs. Een computerprogramma kun je opnieuw zien als een eindige zin over het alfabet dat je gebruikt. Je hebt woorden over je alfabet geschre- ven, met daartussen spaties.
Gebruik opnieuw de idee ̈en van het bewijs van Stelling 1.1, waarbij je het symbool spatie opnieuw toelaat tot je alfabet. P
Gevolg 1 In een programmeertaal met een eindig alfabet kunnen niet alle functies van N naar N geprogrammeerd worden.
Bewijs. Er kunnen maar een aftelbaar aantal computerprogramma’s geschreven worden, en er zijn een niet-aftelbaar aantal functies. P
1.12.6 Opmerkingen
(1) Het feit dat niet alle functies van N naar N ge ̈ımplementeerd kunnen worden in een computerprogramma heeft geleid tot het begrip berekenbare functies; dit zijn de functies die effectief berekend kunnen worden in een computerprogramma.
Deze die niet berekend kunnen worden in een computerprogramma heten de niet-berekenbare functies.
(2) Het feit dat er berekenbare en niet-berekenbare functies zijn, leidt tot de fundamentele vraag: welke problemen kunnen geprogrammeerd worden in een programmeertaal?
Dit zal bestudeerd worden tijdens de studie van de Turing machines: Tu- ring machines modelleren numeriek en symbolisch rekenen in het algemeen (1936).
37
￼￼￼1.13 Appendix
Hierna volgen twee tekeningen die met aftelbaarheid te maken hebben. Ze zijn afkomstig van een poster uit 1998 over aftelbaarheid van Carolina Ma- thematics, Burlington, NC 27215.
De eerste tekening toont hoe filosofen al aftelbaarheid in hun redene- ringen gebruikten; eens dacht men dat de aarde op de rug van een olifant stond, die olifant stond op de rug van een schildpad, die zelf op de rug van een schildpad stond, die zelf ...; dus het is turtles all the way down.
￼Figuur 1.8: Filosofie en aftelbaarheid
De volgende tekening illustreert het idee van David Hilbert van een aftel- baar hotel om het begrip aftelbaarheid te verduidelijken. Het hotel Aleph- Null heeft een oneindig aftelbaar aantal kamers. Het hotel is volzet. Er komt een oneindig aftelbare groep toeristen toe die wensen te verblijven in hotel Aleph-Null.
Alhoewel het hotel volzet is, zegt de man aan de receptie: No problem. Dus de volledige groep toeristen kan toch nog blijven logeren in het hotel. Verklaar het antwoord!
38
￼￼Figuur 1.9: Hotel Aleph-Null
39
.
Deel 1
Eindige deterministische automaten, reguliere grammatica’s en reguliere talen
40
Hoofdstuk 2
Eindige automaten
2.1 Inleiding
In dit eerste gedeelte zullen we de eenvoudigste automaten bestuderen; de eindige deterministische automaten.
We zullen eerst deze automaten beschrijven. Daarna zullen we de talen bestuderen die aanvaard kunnen worden door deze eindige deterministische automaten.
Het is intu ̈ıtief duidelijk dat een eenvoudige automaat slechts eenvoudige talen kan aanvaarden.
Dit is effectief zo voor de eindige deterministische automaten.
Maar toch doet dit niet af aan het grote belang van de eindige determi- nistische automaten.
De eindige deterministische automaten zijn heel belangrijk voor een echte computer en voor het dagelijks computergebruik van ieder van ons.
Standaarden voor bijvoorbeeld floating point getallen, namen voor va- riabelen, namen voor emailadressen en voor webadressen zijn standaarden die in feite talen zijn die aanvaard kunnen worden door eindige determinis- tische automaten. Door voor deze standaarden talen te kiezen die aanvaard kunnen worden door eindige deterministische automaten, helpen deze auto- maten ons bij het detecteren van fouten bij het typen of bij het schrijven van computerprogramma’s. Zij helpen dus mee aan de correcte werking van een computer.
Meer zelfs, de werking van heel veel machines uit het dagdagelijkse leven kan beschreven worden door een eindige deterministische automaat.
Zo geeft wikipedia (http://en.wikipedia.org/wiki/Finite-state_ machine) als eerste voorbeeld voor een eindige deterministische automaat, een toegangspoort.
41
￼Figuur 2.1: Toegangspoort
Figuur 2.2: EDA voor toegangspoort
2.2 Eindige deterministische automaten
Definitie 2.2.1 Een eindige deterministische automaat (EDA) M is een 5-tal M = (K,Σ,δ,s,A), met
• K een eindige verzameling toestanden,
• Σ een eindig alfabet,
• s ∈ K de starttoestand,
• A ⊆ K de verzameling van de aanvaardende toestanden, en,
• δ de transitiefunctie van K × Σ naar de verzameling toestanden K.
42
￼
Definitie 2.2.2 Een configuratie van een EDA M is een element (q, u) van het cartesiaans product K × Σ∗.
De configuratie (q,u) van een EDA M beschrijft:
• de toestand q waarin de EDA M zich op dat ogenblik bevindt, en
• de invoer u die nog verwerkt dient te worden.
De startconfiguratie van een EDA M , die de invoer w dient te verwerken,
is:
met s de starttoestand van de EDA M.
Definitie 2.2.3 De leidt in  ́e ́en stap relatie ⊢M die de werking van de EDA M beschrijft, is als volgt gedefinieerd:
(q,w)⊢M (q′,w′)
als en slechts als
• w = aw′ voor een zeker symbool a uit het alfabet Σ, en • δ(q,a)=q′.
De relatie ⊢∗M is de reflexieve, transitieve sluiting van de  ́e ́en stapsrelatie ⊢M.
Definitie 2.2.4 Een berekening uitgevoerd door een EDA M is een ein- dige reeks van configuraties C0, C1, . . . , Cn, voor zekere n ≥ 0, waarvoor de volgende eigenschappen gelden:
• C0 is de startconfiguratie (s, w),
• Cn = (q, ε), voor een zekere toestand q ∈ K, •
C0 ⊢M C1 ⊢M⊢···⊢M Cn, of, equivalent hiermee,
C0 ⊢∗M Cn.
Merk op dat deze definitie stelt dat in een berekening alle inputsymbolen verwerkt dienen te zijn!
43
(s, w),
Definitie 2.2.5 (1) Een EDA M aanvaardt een inputreeks w als en slechts als
(s,w)⊢∗M (q,ε),
voor een zekere aanvaardende toestand q ∈ K, dus q ∈ A.
(2) Een EDA M weigert een inputreeks w als en slechts als (s,w)⊢∗M (q,ε),
voor een zekere niet-aanvaardende toestand q ∈ K, dus q ̸∈ A.
(3) De taal aanvaard door de EDA M, genoteerd met L(M), is de ver-
zameling van alle reeksen die aanvaard worden door deze EDA M.
De volgende eigenschap geldt omdat een EDA M bij elke berekening
precies  ́e ́en symbool uit de invoerreeks s verwerkt.
Stelling 2.1 Elke EDA M, die een invoerreeks s dient te verwerken, stopt
na |s| stappen.
Nu tonen we een eindige deterministische automaat. Eindige determi- nistische automaten zullen voorgesteld worden door grafen. Hierbij worden de volgende afspraken gemaakt:
• De starttoestand wordt aangeduid met een pijl.
• Niet-aanvaardende toestanden staan in een enkele cirkel, en aanvaar-
dende toestanden in een dubbele cirkel.
• Het label op een lus of pijl duidt aan of, bij verwerking van het input- symbool voorgesteld door het label, in de huidige toestand gebleven dient te worden (bij een lus), of indien er naar een andere toestand gegaan dient te worden (bij een pijl).
Voorbeeld 2.2.6 De volgende eindige deterministische automaat aanvaardt de oneven natuurlijke getallen. Hij verwerkt de cijfers 0, . . . , 9. Bij een even cijfer blijft de automaat in toestand q0 of gaat hij naar toestand q0. Bij een oneven cijfer gaat de automaat naar toestand q1 of blijft de automaat in toestand q1.
De motivatie hiervoor is als volgt: de enige aanvaardende toestand is de toestand q1. Iedere keer dat een cijfer gelezen wordt, kan dit het laatste cijfer zijn dat gelezen dient te worden. Als het laatste cijfer oneven is, dan is het ingevoerde getal oneven, en dan moet deze input aanvaard worden. Dus dan moet de automaat in de aanvaardende toestand q1 zijn.
Daarom, bij het inlezen van een oneven cijfer, blijft de automaat in de aanvaardende toestand q1 of gaat de automaat naar de aanvaardende toe- stand q1.
44
￼￼￼￼￼Is een ingelezen cijfer even, dan blijft de automaat in de niet-aanvaardende toestand q0 of gaat de automaat naar de niet-aanvaardende toestand q0, want als dit ingelezen even cijfer het laatste is, dan is de ingegeven input een even natuurlijk getal, en dan mag deze input zeker niet aanvaard worden.
￼Figuur 2.3: EDA die oneven getallen aanvaardt
Voorbeeld 2.2.7 De volgende EDA aanvaardt de taal
L = {w ∈ {a, b}∗ : elke a wordt onmiddellijk gevolgd door een b}.
Figuur 2.4: EDA
Voorbeeld 2.2.8 De EDA in Figuur 2.5 aanvaardt de taal
L = {w ∈ {a, b}∗ : w bevat hoogstens 1 keer de letter b}.
Hier zien we het gebruik van een dead state d. De slechte reeksen, die dus minstens twee b’s bevatten, worden naar de niet-aanvaardende toestand d gestuurd, die niet meer verlaten kan worden.
Voorbeeld 2.2.9 De EDA in Figuur 2.6 aanvaardt de taal
L = {w ∈ {a, b}∗ : elke reeks opeenvolgende a in w heeft even lengte}.
45
￼
￼￼￼￼￼￼￼￼Figuur 2.5: EDA met een dead state
Figuur 2.6: EDA
Voorbeeld 2.2.10 Nu een praktisch voorbeeld: de taal van de floating point getallen kan aanvaard worden door een EDA.
Concrete voorbeelden van floating point getallen zijn: +3.0, 3.0, 0.3E1, 0.3E + 1, −0.3E + 1, −3E8
De volgende EDA aanvaardt de taal van de floating point getallen.
Figuur 2.7: EDA die de floating point getallen aanvaardt
Voorbeeld 2.2.11 Nu geven we al een hint die soms gebruikt kan worden om een EDA te maken die een taal L aanvaardt.
Stel er wordt gevraagd een EDA te maken die de taal
L = {w ∈ {a, b}∗ : w bevat niet de deelreeks aab}
￼￼aanvaardt.
46
￼￼Bekijk deze vraag. Dan voel je aan dat een gemakkelijker vraag ging ge- weest zijn:
maak een EDA die de taal
¬L = {w ∈ {a, b}∗ : w bevat de deelreeks aab}
aanvaardt.
Want hiervoor kunnen we de EDA
Figuur 2.8: EDA die ¬L aanvaardt
maken.
Hoe zet je nu deze EDA die de negatie ¬L van de taal L aanvaardt, om in de EDA die de taal L aanvaardt?
2.3 Niet-deterministische eindige automaten
De eindige deterministische automaten (EDA), die in de vorige sectie ge- definieerd werden, zijn heel eenvoudige automaten. Zij kunnen maar heel eenvoudige zaken controleren of aanvaarden.
Nu bekijken we de niet-deterministische eindige automaten. Deze auto- maten mogen iets meer: zij mogen soms een keuze maken wat te doen in de volgende stap:
• eventueel geen symbool verwerken, formeel komt dit neer op de nul- reeks ε verwerken,
• soms kan een keuze gemaakt worden tussen verschillende volgende toe- standen bij het inlezen van de nulreeks of een inputsymbool.
Dit wordt geillustreerd in Figuur 2.9.
Als een automaat zelf keuzes mag maken, kunnen wij zijn gedrag niet voorspellen. Het gedrag van deze automaat is niet meer gedetermineerd, daarom noemen we deze automaten niet-deterministische automaten.
Maar een eindige deterministische automaat toch toelaten keuzes te ma- ken, geeft dit ons een performantere machine, waarbij performanter betekent
47
￼￼
￼￼￼￼dat er talen zijn die aanvaard kunnen worden door een niet-deterministische automaat, maar niet door een deterministische automaat?
Deze vraag zal beantwoord worden binnen deze sectie.
Definitie 2.3.1 Een niet-deterministische eindige automaat (NDA) M is
een 5-tal M = (K,Σ,∆,s,A), met
• K een eindige verzameling toestanden,
• Σ een eindig alfabet,
• s ∈ K de starttoestand,
• A ⊆ K de verzameling van de aanvaardende toestanden, en
• ∆ de transitierelatie. Dit is een eindige deelverzameling van (K×(Σ∪ {ε})) × K.
Het idee bij niet-deterministische automaten is dat de automaat keuzes kan maken. Dit wordt geillustreerd door Figuur 2.9.
We zien dat er drie pijlen vertrekken uit de starttoestand q0:  ́e ́en met la- bel de nulreeks ε, en twee met label a. Dus de eerste keuze die de automaat kan maken in de toestand q0 is of de automaat niks verwerkt, equivalent hiermee de nulreeks ε verwerkt, of een karakter a verwerkt. Kiest de auto- maat ervoor om een karakter a te verwerken, dan kan de automaat nog eens kiezen of hij naar toestand q2 of naar toestand q3 gaat.
Door deze keuzemogelijkheden is het gedrag van een niet-deterministische automaat niet te voorspellen. Dus is er een grotere voorzichtigheid geboden bij de studie van een niet-deterministische automaat, en ook een grotere voorzichtigheid geboden bij het formuleren van definities en eigenschappen van een niet-deterministische automaat.
Figuur 2.9: Keuzemogelijkheden bij een NDA
48
￼
￼￼￼￼￼￼Definitie 2.3.2 Een NDA M aanvaardt een inputreeks w als en slechts als er minstens  ́e ́en pad is dat de NDA M kan volgen vanuit zijn starttoestand s, en, nadat de inputreeks w volledig verwerkt is, eindigt in een aanvaardende toestand q, dus q ∈ A.
De taal aanvaard door de NDA M, genoteerd met L(M), is de verzame- ling van alle reeksen die aanvaard worden door deze NDA M.
Hoe kan de werking van een NDA M onderzocht worden? Een mogelijk- heid is via een boom die alle mogelijke manieren weergeeft waarop deze NDA M de inputreeks w kan verwerken. Dit wordt getoond in de volgende figuur. Het begin van deze figuur correspondeert met het begin van de Figuur 2.9. De verschillende paden in de boom tonen de verschillende manieren waarop deze NDA de input abab kan verwerken.
Figuur 2.10: Verschillende manieren om input abab te verwerken
Nu geven we twee voorbeelden van niet-deterministische eindige auto-
maten.
Voorbeeld 2.3.3 De eerste niet-deterministische eindige automaat aan- vaardt de taal
L = {w ∈ {a, b}∗ : w bestaat uit twee of drie a gevolgd door nul, 1, of meerdere b}.
Figuur 2.11: NDA: beginnen met twee of drie a’s
Het niet-deterministisch karakter in deze NDA ligt in het feit dat in de
starttoestand er een keuze gemaakt dient te worden of niks ingelezen wordt,
49
￼￼￼￼
￼￼of een karakter a ingelezen wordt. De NDA dient in het begin te gokken of een correcte input met twee of met drie a’s begint.
Voorbeeld 2.3.4 De tweede niet-deterministische eindige automaat aan- vaardt de taal
L = {w ∈ {a, b}∗ : de vierde laatste karakter is een a}.
Het niet-deterministisch karakter in deze NDA ligt in het feit dat in de starttoestand er een keuze gemaakt dient te worden of op een gegeven ogenblik de vierde laatste karakter gelezen wordt of niet.
Figuur 2.12: NDA: gokken of ingelezen karakter vierde laatste karakter is
Bij een NDA M is het toegelaten dat deze in een stap geen karakter uit de inputreeks w verwerkt. Dan verwerkt deze NDA M in feite de nulreeks ε. We noemen dit een ε-transitie.
We bespreken nu hoe er formeel met deze ε-transities dient omgegaan te worden. Eerst en vooral defini ̈eren we de verzameling eps(q), voor elke toestand q.
Definitie 2.3.5
eps(q) = {p ∈ K : (q,w) ⊢∗M (p,w)}.
In woorden, eps(q) is de sluiting van het singleton q onder de relatie {(p, r) : er is een transitie (p, ε, r) ∈ ∆}, of, equivalent hiermee, eps(q) is de verzameling van alle toestanden p die bereikt kunnen worden uit de toestand q door enkel ε-transities te volgen.
Vanuit een programmeerstandpunt kunnen de verzamelingen eps(q) via het volgende iteratief algoritme berekend worden.
eps(q : state) = result := {q}.
WHILE there exists some p ∈ result and some r ̸∈ result and
some transition (p, ε, r) ∈ ∆ DO: 50
￼
INSERT r into result. RETURN result.
Nu kunnen we de werking van een niet-deterministische eindige auto- maat simuleren.
ndfsmsimulate(M : NDA, w: reeks) =
1. current − state = eps(s).
2. Zolang er symbolen in de input w overblijven,
(a) c = get − next − symbol(w)
(b) next − state = ∅.
(c) Voor elke toestand q in current − state doe: Voor elke toestand p waarvoor (q, c, p) ∈ ∆ doe: next − state = next − state ∪ eps(p).
(d) current − state = next − state.
3. IF current − state minstens  ́e ́en toestand uit A bevat, dan wordt de
input w aanvaard, anders wordt ze geweigerd.
Het idee voor dit algoritme steunt op de volgende zaken: current-state en next-state zijn verzamelingen toestanden. Het idee hierachter is dat deze verzamelingen toestanden alle mogelijke toestanden verzamelen die bereikt kunnen worden, indien de niet-deterministische eindige automaat alle mo- gelijke manieren zou proberen om de input w te verwerken. Indien op het einde, na het volledig verwerken van de input w, current-state minstens  ́e ́en aanvaardende toestand bevat, dan geeft dit het signaal dat de niet- deterministische automaat een manier heeft om de input w te verwerken, en te eindigen in een aanvaardende toestand. Maar dan betekent dit dat de input w aanvaard dient te worden door de niet-deterministische eindige automaat (Definitie 2.3.2).
2.4 Equivalentie van EDA en NDA
Het is duidelijk dat een taal die door een deterministische eindige automaat aanvaard kan worden, ook aanvaard kan worden door een niet-deterministische automaat, maar het interessante is dat het omgekeerde ook waar is.
Stelling 2.2 Voor elke niet-deterministische eindige automaat, is er een equivalente eindige deterministische automaat die dezelfde taal L aanvaardt.
51
BEWIJS: We bewijzen dit door voor elke NDA M = (K,Σ,∆,s,A) een equivalente eindige deterministische automaat M′ = (K′, Σ, δ′, s′, A′) te construeren:
Hier zijn de vijf componenten van deze equivalente eindige determinis- tische automaat M′ = (K′,Σ,δ′,s′,A′):
• K′ = P(K), m.a.w, K′ bestaat uit de verzameling van alle deelverza- melingen van de verzameling toestanden K van M,
• s′ = eps(s) is de starttoestand voor de equivalente eindige determinis- tische automaat M′,
• A′ = {Q ⊆ K : Q ∩ A ̸= ∅}, m.a.w., de aanvaardende toestanden voor de equivalente EDA M′ bestaan uit alle deelverzamelingen van toestanden van M die minstens  ́e ́en aanvaardende toestand van de NDA M bevatten,
•
δ′(Q,a) = ∪{eps(p) : p ∈ K en (q,a,p) ∈ ∆ voor een zekere q ∈ Q}.
52
P
￼￼￼￼￼￼￼Hoofdstuk 3
Minimalisatie van eindige automaten
3.1 Inleiding
Als eindige automaten gebruikt worden in de praktijk, dan wensen we na- tuurlijk dat deze eindige automaten zo effici ̈ent mogelijk de hun opgelegde taak uitvoeren.
Wij zullen in dit hoofdstuk aantonen dat er een algoritme bestaat dat elke eindige automaat kan omzetten in een equivalente automaat die het kleinste aantal toestanden heeft, nodig voor het uitvoeren van de opgelegde taak.
Dit omvat verschillende aspecten, zoals het wegdoen van toestanden die onbereikbaar zijn. In de volgende figuur is toestand 3 onbereikbaar, dus in feite van geen nut voor de automaat.
Figuur 3.1: Een onbereikbare toestand
Het omvat ook het samenvoegen van toestanden omdat hun gedrag het- zelfde is. In de automaat in de figuur hierna spelen de toestanden 2 en 3 dezelfde rol, dus in feite mogen zij samengevoegd worden tot  ́e ́en toestand.
Maar wanneer vertonen twee verschillende toestanden hetzelfde gedrag? Dit zal objectief gedefinieerd kunnen worden.
53
￼
￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼Figuur 3.2: Equivalente toestanden
Intu ̈ıtief vertonen twee toestanden q en q′ hetzelfde gedrag als geldt dat:
alle reeksen uit Σ∗ hetzelfde lot (aanvaard worden of geweigerd worden) hebben, onafhankelijk van het feit of ze verwerkt worden startend vanuit de toestand q of vanuit de toestand q′.
Dit wordt geillustreerd door de volgende figuur, waarin de toestanden q2 en q3 hetzelfde gedrag vertonen, en dus equivalent zijn.
Figuur 3.3: Equivalente toestanden
Maar we zullen het algoritme om een eindige automaat M te minima- liseren opstellen via de taal L = L(M) aanvaard door deze automaat M, omdat deze ons dan onmiddellijk het algoritme geeft.
Dit zal de benadering zijn in Sectie 3.2. In de erop volgende Sectie 3.3 zullen we een iteratief algoritme geven om een EDA M te minimaliseren naar een equivalente EDA M∗, met het kleinste aantal benodigde toestanden, om dezelfde taal L te aanvaarden.
3.2 Benadering via de taal L
Definitie 3.2.1 Twee reeksen x en y uit de verzameling Σ∗ zijn equivalent ten opzichte van een taal L, bevat in Σ∗, genoteerd met x ≈L y, als en slechts als er geldt dat wat er ook rechts bij x of y toegevoegd wordt, deze nieuwe reeksen ofwel allebei tot L behoren, ofwel allebei niet tot L behoren.
54
￼
Formeel genoteerd:
x≈L y⇔∀z∈Σ∗(xz∈L⇔yz∈L).
De vraag is of dit een goede definitie is, om twee reeksen x en y equivalent te defini ̈eren ten opzichte van een taal L.
Wiskundig komt dit neer op het feit dat gecontroleerd dient te worden dat de relatie ≈L een equivalentierelatie is. Dit wordt bewezen in de volgende stelling.
Stelling 3.1 De relatie ≈L is een equivalentierelatie. BEWIJS
(1) De relatie ≈L is reflexief (∀x ∈ Σ∗(x ≈L x)) daar er geldt: ∀x,z ∈ Σ∗(xz ∈ L ⇔ xz ∈ L).
(2) De relatie ≈L is symmetrisch (∀x,y ∈ Σ∗((x ≈L y) → (y ≈L x))) daar er geldt:
∀x,y,z ∈ Σ∗((xz ∈ L ⇔ yz ∈ L) ⇔ (yz ∈ L ⇔ xz ∈ L)).
(3) De relatie ≈L is transitief (∀x, y, z ∈ Σ∗(((x ≈L y) ∧ (y ≈L z)) →
(x ≈L z))) daar er geldt:
∀x,y,z,w ∈ Σ∗(((xz ∈ L ⇔ yz ∈ L)∧(yz ∈ L ⇔ wz ∈ L)) → (xz ∈ L ⇔ wz ∈ L)).
P
We tonen nu enkele voorbeelden van deze equivalentierelatie ≈L. Merk op dat een equivalentierelatie ≈L de verzameling Σ∗ van alle reeksen ver- deelt in equivalentieklassen. Hierbij is een equivalentieklasse nooit leeg, en elke reeks uit Σ∗ behoort tot precies  ́e ́en equivalentieklasse van de equiva- lentierelatie ≈L.
De betekenis van een equivalentieklasse voor de equivalentierelatie ≈L is als volgt:
twee reeksen x en y in dezelfde equivalentieklasse ≈L zijn gelijkwaardig ten opzichte van deze taal L; zij vertonen hetzelfde gedrag ten opzichte van deze taal, of equivalent hiermee, ten opzichte van een eindige automaat die deze taal L aanvaardt.
Voorbeeld 3.2.2 Zij Σ = {a, b} en zij de taal L gelijk aan:
L = {w ∈ Σ∗ : elke a wordt onmiddellijk gevolgd door een b}.
Deze taal L heeft precies drie equivalentieklassen voor ≈L: 55
• [1]=detaalLzelf
[1] = L = {ε,b,ab,...},
• [2] = de verzameling van alle reeksen die eindigen op a en die geen
vroegere a hebben niet gevolgd door een b
[2] = {a, abbba, . . .},
• [3] = de verzameling van alle reeksen met minstens twee opeenvolgende a’s
[3] = {aa, abaa, . . .}.
We tonen aan dat de klasse [2] effectief een equivalentieklasse is ten opzichte van de relatie ≈L. We leggen dit uit door aan te tonen dat de twee reeksen a en abbba uit klasse [2] hetzelfde gedrag vertonen ten opzichte van de taal L.
Plaats rechts van a en abbba een reeks z die begint met een a, dan hebben az en abbbaz allebei een keer twee opeenvolgende a’s, dus beide reeksen az en abbbaz behoren niet tot de taal L.
Plaats rechts van a en abbba een reeks z die begint met b en tot de taal L behoort, dan behoren az en abbbaz allebei tot de taal L.
Tenslotte, plaats na a en abbba een reeks z die begint met b, maar zelf een keer twee opeenvolgende a’s heeft, dan hebben az en abbbaz allebei een keer twee opeenvolgende a’s, dus beide reeksen az en abbbaz behoren niet tot de taal L.
We zien dat a en abbba steeds hetzelfde gedrag vertonen als er eenzelfde reeks z rechts van a en abbba geplaatst wordt, dus het geldt inderdaad dat a ≈L abbba, dus zij dienen inderdaad tot dezelfde equivalentieklasse ten op- zichte van de equivalentierelatie ≈L te behoren.
Voorbeeld 3.2.3 Zij Σ = {a, b} en zij de taal L gelijk aan: L={w∈Σ∗ :|w|iseven}.
Deze taal L heeft precies twee equivalentieklassen voor ≈L:
• [1] = L = de verzameling reeksen uit Σ∗ van even lengte
[1] = L = {ε,aa,ab,ba,bb,aaaa,...},
• [2] = Σ∗ \ L = de verzameling reeksen uit Σ∗ van oneven lengte
[2] = Σ \ L = {a, b, aaa, aab, . . . , bbb, . . .}.
56
Het is niet zo dat een reguliere taal L zelf,  ́e ́en equivalentieklasse vormt voor ≈L, zoals het volgende voorbeeld aantoont.
Voorbeeld 3.2.4 Zij Σ = {a, b} en zij de taal L gelijk aan:
L = {w ∈ Σ∗ : geen twee opeenvolgende karakters zijn gelijk aan elkaar}.
Deze taal L heeft precies vier equivalentieklassen voor ≈L:
• [1] De nulreeks, die tot L behoort: {ε},
• [2] De reeksen die tot L behoren, en eindigen op a: {a, ba, aba, baba, . . .},
• [3] De reeksen die tot L behoren, en eindigen op b: {b, ab, bab, abab, . . .},
• [4] De reeksen die niet tot L behoren: {aa, abaa, ababb, . . .}.
We zullen zien dat dit zal corresponderen met een minimale eindige au- tomaat voor de taal L, die meerdere aanvaardende toestanden bezit.
E ́en van de eigenschappen die zeker geldt voor een taal L aanvaard door een eindige automaat, is dat een dergelijke taal L steeds een eindig aantal equivalentieklassen bezit voor de equivalentierelatie ≈L. Dit wordt aange- toond in de volgende stelling.
Stelling 3.2 Zij L een taal aanvaard door een eindige deterministische au- tomaat, en zij M een EDA die deze taal L aanvaardt.
Dan is het aantal toestanden in de EDA M steeds groter dan of gelijk aan het aantal equivalentieklassen voor de equivalentierelatie ≈L.
Bijgevolg is het aantal equivalentieklassen, van een taal aanvaard door een eindige deterministische automaat, voor de equivalentierelatie ≈L eindig.
BEWIJS: Stel dat het aantal toestanden in de EDA M kleiner is dan het aantal equivalentieklassen voor de equivalentierelatie ≈L.
Neem uit elke equivalentieklasse voor ≈L een element, en laat dit ver- werken door de EDA M, dan volgt uit het duivenhokprincipe dat de EDA M zeker voor minstens  ́e ́en stel van twee elementen α en β uit verschillende equivalentieklassen zal eindigen in dezelfde toestand. Maar dan zullen αz en βz, voor alle z ∈ Σ∗, hetzelfde gedrag voor de EDA M vertonen.
Maar dit betekent dan dat α ≈L β, wat in tegenstrijd is met het feit dat zij tot verschillende equivalentieklassen voor ≈L behoren.
Dus we bekomen een tegenstrijdigheid. We besluiten dat het aantal toestanden in de EDA M groter dan of gelijk is aan het aantal equivalentie- klassen voor de equivalentierelatie ≈L.
Een EDA M heeft een eindig aantal toestanden, dus impliceert dit dat de equivalentierelatie ≈L voor een taal L aanvaard door een EDA M ook
57
een eindig aantal equivalentieklassen bezit. P De voorgaande stelling geeft ons een voorwaarde waaruit we kunnen
besluiten dat een taal L niet aanvaard kan worden door een EDA M. Gevolg 2 Als een taal L oneindig veel equivalentieklassen bezit voor de equi-
valentierelatie ≈L, dan is deze taal niet-regulier.
Voorbeeld 3.2.5 Zij Σ = {a, b} en beschouw de taal L = {anbn : n ∈ N}. Dan heeft deze taal L oneindig veel equivalentieklassen voor de equiva-
lentierelatie ≈L.
Zo zijn de singletons {an}, voor elke n ∈ N, equivalentieklassen voor ≈L. Hieruit mogen we besluiten dat de taal L niet aanvaard kan worden door
een EDA M.
Deze taal L = {anbn : n ∈ N} zal in deze cursus het klassieke voorbeeld
zijn van een taal die niet aanvaard kan worden door een EDA M.
We weten uit Stelling 3.2 dat het aantal toestanden in een EDA M die een taal L aanvaardt, groter dan of gelijk is aan het aantal equivalentieklas- sen van deze taal L ten opzichte van ≈L. De volgende stelling toont aan dat er zelfs een EDA bestaat die de taal L aanvaardt, met het aantal toestanden gelijk aan het aantal equivalentieklassen van deze taal L ten opzichte van ≈L.
Stelling 3.3 Zij L een taal over het alfabet Σ die aanvaard kan worden door een eindige deterministische automaat.
Dan bestaat er een EDA M die de taal L aanvaardt, en met het aantal toestanden voor M exact gelijk aan het aantal equivalentieklassen van deze taal L ten opzichte van ≈L.
Elke andere EDA die ook de taal L aanvaardt heeft ofwel meer toestanden dan deze EDA M, of is equivalent aan de EDA M.
BEWIJS: We geven de constructie voor deze EDA M = (K, Σ, δ, s, A) die de taal L aanvaardt, en met het aantal toestanden voor M exact gelijk aan het aantal n aan equivalentieklassen van deze taal L ten opzichte van ≈L:
• K: elke toestand in K komt overeen met precies  ́e ́en van de equiva- lentieklassen van L ten opzichte van ≈L,
• s = [ε], met [ε] de equivalentieklasse van de nulreeks ε ten opzichte van ≈L,
• A = {[x] : x ∈ L}, met [x] de equivalentieklasse van de reeks x ten opzichte van ≈L,
58
•
We controleren nu dat de hiervoor gedefinieerde automaat M wel degelijk een EDA is die de taal L aanvaardt.
(1) Eerst en vooral, een EDA mag maar een eindig aantal toestanden hebben. Dit is wel degelijk het geval. Want de taal L wordt aanvaard door een EDA M′. Deze laatste EDA M′ heeft een eindig aantal toestanden m, en dit aantal toestanden m is groter dan of gelijk aan n (Stelling 3.2).
Dus het aantal toestanden n voor K is eindig.
(2) De bewerking δ is wel degelijk een functie. We tonen aan dat
∀s,t(([ε],st)⊢∗M ([s],t)).
We tonen dit aan door inductie op de lengte |s| van de te verwerken invoer s.
Inductiebasis: Als |s| = 0, dan is s = ε, en dan is ([ε], εt) ⊢∗M ([ε], t), wat geldig is omdat voor de nulreeks ε de EDA M geen bewerkingen dient uit te voeren.
Inductiehypothese: Stel dat de stelling al geldig is voor de lengte |s| = k, dan tonen we aan dat zij ook geldig is voor de lengte |s| = k + 1.
Hieris|s|≥1,duswekunnenstellendats=yc,mety∈Σ∗ vanlengte |y| = k, en met c ∈ Σ.
De EDA M leest de invoer van links naar rechts, dus M leest de k karakters uit y het eerst. Uit de inductiehypothese voor inputs y van lengte k weten we dat
([ε],yct)⊢∗M ([y],ct).
Nu lezen we het volgende karakter c in, en laten we verwerken door de
EDA M. Hier passen we rechtstreeks de definitie van δ toe: ([y],ct)⊢∗M ([yc],t).
De opeenvolging van de twee hiervoor uitgevoerde bewerkingen, leiden uiteindelijk tot:
([ε],yct)⊢∗M ([yc],t). Dus daar s = yc hebben we bewezen dat:
([ε],st)⊢∗M ([s],t), waardoor het te bewijzen ook geldt als |s| = k + 1.
59
δ([x], a) = [xa].
Met andere woorden, als de EDA M zich in de toestand [x] bevindt van de reeks x, dan zal de EDA M zich, na het lezen van het volgende karakter a ∈ Σ, naar de toestand [xa] begeven.
￼￼￼￼Uit de eigenschappen van een bewijs door inductie kunnen we nu beslui- ten dat:
∀s,t(([ε],st)⊢∗M ([s],t)).
Laat nu t = ε, dan hebben we in feite voor elke reeks s ∈ Σ∗ aangetoond
dat:
([ε],s)⊢∗M ([s],ε).
Dit impliceert dat de EDA M de invoer s zal aanvaarden als en slechts als [s] ∈ A.
Dus de geconstrueerde EDA M aanvaardt inderdaad enkel en alleen de reeksen s uit de taal L.
Er kan geen EDA zijn met minder toestanden die de taal L aanvaardt (Stelling 3.2), dus deze EDA M heeft effectief het kleinste aantal toestanden nodig om de taal L te aanvaarden.
Er kan bewezen worden dat, op equivalentie na, er geen andere EDA M# bestaat met evenveel toestanden als M die de taal L aanvaardt. Dit bewijs wordt niet besproken binnen het kader van dit opleidingsonderdeel.
P
Voorbeeld 3.2.6 We geven de minimale EDA M die de taal L uit Voor- beeld 3.2.4 aanvaardt. Hier corresponderen de nummers van de toestanden van M met de nummers van de equivalentieklassen uit Voorbeeld 3.2.4.
Figuur 3.4: Minimale EDA
De volgende stelling van Myhill en Nerode toont zelfs aan dat een taal L aanvaard kan worden door een EDA als en slechts als het aantal equiva- lentieklassen van deze taal L voor de equivalentierelatie ≈L eindig is.
Stelling 3.4 (Myhill-Nerode) Een taal L kan aanvaard worden door een EDA M als en slechts als het aantal equivalentieklassen van deze taal L voor de equivalentierelatie ≈L eindig is.
60
￼
BEWIJS:
Deel 1: Als de taal L aanvaard wordt door een EDA M, dan is het aantal equivalentieklassen van deze taal L voor de equivalen- tierelatie ≈L eindig.
Stel de taal L wordt aanvaard door een EDA M, dan heeft deze EDA M een eindig aantal toestanden. Stel dat M precies m toestanden heeft.
Nu zegt Stelling 3.2 dat het aantal equivalentieklassen van de taal L ten opzichte van ≈L hoogstens gelijk is aan het aantal toestanden van M. Dus is het aantal equivalentieklassen van de taal L ten opzichte van ≈L eindig.
Deel 2: Als het aantal equivalentieklassen van deze taal L voor de equivalentierelatie ≈L eindig is, dan wordt deze taal L aanvaard door een EDA.
Hiervoor kunnen we steunen op de constructiemethode uit het bewijs van Stelling 3.3 om een EDA M te construeren die de taal L aanvaardt. P
3.3 Benadering via de EDA M
In het laatste gedeelte van dit hoofdstuk zullen we een iteratief algoritme geven om een EDA M te minimaliseren naar een equivalente EDA M∗, met het kleinste aantal benodigde toestanden, om dezelfde taal L te aanvaarden.
Hier worden opnieuw de idee ̈en van equivalentierelaties en equivalentie- klassen gebruikt, omdat het opnieuw de bedoeling is om toestanden, die hetzelfde gedrag vertonen, samen te voegen tot  ́e ́en nieuwe toestand.
Definitie 3.3.1 Zij M een EDA, en stel dat p en q twee van de toestanden van deze EDA M zijn.
Dan noemen we deze twee toestanden p en q equivalent, genoteerd met q ≡ p, als en slechts als de volgende voorwaarde geldt:
q ≡ p als en slechts als voor alle reeksen w ∈ Σ∗, er geldt dat M eindigt in een aanvaardende toestand als zowel w verwerkt wordt startend bij toestand p en bij toestand q, of dat M eindigt in een niet-aanvaardende toestand als zowel w verwerkt wordt startend bij toestand p en bij toestand q.
Voorbeeld3.3.2ZijΣ={a,b}enzijL={w∈Σ∗ :|w|iseven.}. In de automaat uit Figuur 3.5 die de taal L aanvaardt, zien we dat de twee toestanden q2 en q3 equivalent zijn.
Nu tonen we het iteratief algoritme dat de equivalentierelatie ≡ op de toestanden van een EDA M zal geven, als de limiet van een reeks benade- rende equivalentierelaties ≡n. In de beschrijving van het iteratief algoritme zijn p en q twee toestanden van deze EDA M.
• p ≡0 q als en slechts als zij hetzelfde gedrag vertonen bij de verwerking van de nulreeks ε.
61
￼￼￼￼￼Figuur 3.5: Equivalente toestanden q2 en q3
Dit komt in feite neer op het feit of zij beide aanvaardende of beide niet-aanvaardende toestanden zijn.
• p ≡1 q als en slechts als zij hetzelfde gedrag vertonen bij de verwerking van inputs van lengte 1.
Dus elke afzonderlijke karakter wordt na verwerking vanuit zowel toe- stand p als vanuit toestand q naar een aanvaardende toestand ge- stuurd, of wordt na verwerking vanuit zowel toestand p als vanuit toestand q naar een niet-aanvaardende toestand gestuurd.
• p ≡2 q als en slechts als zij hetzelfde gedrag vertonen bij de verwerking van inputs van lengte 2.
Dit kan inductief als volgt uitgelegd worden: na het verwerken van het eerste karakter van een input van lengte 2, vanuit zowel de toestand p als de toestand q, is de EDA M terechtgekomen in toestanden p′ en q′ die voldoen aan p′ ≡1 q′. Uit de definitie van ≡1 volgt dan dat zij tot hetzelfde resultaat (aanvaarden of weigeren) zullen leiden na verwerking van het tweede karakter uit de inputs van lengte 2.
• Zo inductief verder voor de definitie van p ≡n q:
p ≡n q als en slechts als zij hetzelfde gedrag vertonen (aanvaarden of weigeren) bij de verwerking van de inputs van lengte n als deze inputs verwerkt worden vanuit zowel toestand p als vanuit toestand q.
Formeel beschreven:
als en slechts als: – q≡n−1 p,en
∀p,q∈K en∀n≥1:p≡n q
62
￼￼￼￼￼￼￼￼– ∀a ∈ Σ(δ(p, a) ≡n−1 δ(q, a)).
Voorbeeld 3.3.3 Het voorgaande algoritme toepassen op de volgende EDA
leidt tot de ernavolgende EDA met het minimaal aantal toestanden.
Figuur 3.6: Te minimaliseren EDA
Figuur 3.7: Geminimaliseerde EDA
63
￼￼
Hoofdstuk 4
Reguliere uitdrukkingen
Dit hoofdstuk concentreert zich op de talen die aanvaard kunnen worden door een eindige deterministische automaat M.
Er zal aangetoond worden dat de talen die aanvaard kunnen worden door een EDA gelijk zijn aan de reguliere talen; dit zijn de talen die beschreven worden door reguliere uitdrukkingen.
Reguliere uitdrukkingen treden overal op binnen de informatica. Ze tre- den op bij zoekpatronen die uitgevoerd kunnen worden door computers, bij het opstellen van standaarden voor emailadressen en webadressen, bij de beschrijving van floating point getallen, . . .
Zij vormen door het feit dat zij op zovele plaatsen optreden binnen de informatica,  ́e ́en van de basisconcepten binnen de informatica.
4.1 Definities
We starten met de definitie van reguliere uitdrukkingen.
Definitie 4.1.1 De reguliere uitdrukkingen over een alfabet Σ zijn alle uit- drukkingen die volgens een eindige combinatie van de volgende regels opge- steld kunnen worden:
• ∅ is een reguliere uitdrukking,
• ε is een reguliere uitdrukking,
• elk element van het alfabet Σ is een reguliere uitdrukking,
• als α en β reguliere uitdrukkingen zijn, dan is ook αβ (β na α) een reguliere uitdrukking,
• als α en β reguliere uitdrukkingen zijn, dan is ook α ∪ β (α of β) een reguliere uitdrukking,
64
• als α een reguliere uitdrukking is, dan is ook α∗ een reguliere uitdruk- king,
• als α een reguliere uitdrukking is, dan is ook α+ een reguliere uitdruk- king,
• als α een reguliere uitdrukking is, dan is ook (α) een reguliere uitdruk- king.
De betekenis van deze regels zal geleidelijk duidelijk worden uit de voor- beelden en het vervolg van dit hoofdstuk. Maar de laatste regel is ingevoerd omdat er soms haakjes rond reguliere uitdrukkingen geplaatst dienen te wor- den, om op een correcte wijze complexere reguliere uitdrukkingen te vormen.
Voorbeeld 4.1.2 Beschouw het alfabet Σ = {a,b}, dan zijn de volgende uitdrukkingen voorbeelden van reguliere uitdrukkingen over het alfabet Σ:
•∅
•ε
•a
• (a∪b)∗ • abba∪ε
Reguliere uitdrukkingen zijn in feite compacte uitdrukkingen voor ganse verzamelingen uitdrukkingen, soms oneindig grote verzamelingen uitdruk- kingen. In de volgende definitie geven we de formules om een reguliere uitdrukking om te zetten in de corresponderende verzameling uitdrukkin- gen waarvoor het een compacte uitdrukking is. We doen dit via de functie L, die we de semantische interpretatiefunctie noemen.
Definitie 4.1.3 De semantische interpretatiefunctie L die de regels geeft om een reguliere uitdrukking om te zetten in de corresponderende reguliere verzameling uitdrukkingen waarvoor het een compacte uitdrukking is, wordt gedefinieerd aan de hand van de volgende regels:
• L(∅) = ∅,
• L(ε) = {ε},
• Voor c∈Σ is L(c)={c},
• L(αβ) = L(α)L(β) = {vw : ∀v ∈ L(α), ∀w ∈ L(β)}, • L(α∪β)=L(α)∪L(β),
65
• L(α∗) = (L(α))∗, waarbij voor een verzameling X, de notatie X∗ staat voor de verzameling van alle mogelijke eindige reeksen van de elemen- ten uit X, met of zonder herhaling van de elementen uit X, de nulreeks ε inbegrepen,
• L(α+) = L(α)(L(α))∗.
AlsL(α)=∅,danisookL(α+)=∅. AlsL(α)̸=∅,danisL(α+) gelijk aan de verzameling van alle mogelijke eindige reeksen van de elementen uit X, met of zonder herhaling van de elementen uit X, van lengte minstens 1.
• L((α)) = L(α).
Het toepassen van deze regels en de betekenis die er uit volgt, zal ge- leidelijk duidelijk worden in het vervolg van dit hoofdstuk. Maar de regel: voor c ∈ Σ is L(c) = {c} geeft in feite aan dat de elementen c uit het alfabet Σ in feite voor constanten, constante symbolen, staan.
Voorbeeld 4.1.4 We geven nu een voorbeeld waarin we een reguliere uit- drukking omzetten in de corresponderende reguliere verzameling uitdrukkin- gen die het definieert. In dit voorbeeld passen we expliciet de rekenregels uit de vorige definitie toe. Hier is opnieuw het alfabet Σ = {a, b}.
L((a ∪ b)∗b) = L((a ∪ b)∗ )L(b) = (L((a ∪ b)))∗ L(b)
= (L(a) ∪ L(b))∗ L(b) = ({a} ∪ {b})∗ {b}
= {a, b}∗ {b}.
De betekenis van deze reguliere uitdrukking, die ook weergeeft welke reek- sen tot de corresponderende reguliere verzameling behoren, kan ook in woor- den beschreven worden.
De reguliere uitdrukking (a∪b)∗b is de aaneenschakeling van de reguliere uitdrukkingen (a∪b)∗ en b. De reguliere uitdrukking (a∪b)∗ betekent wegens de ∗-notatie een willekeurige herhaling van a’s en b’s, dus staat in feite voor alle reeksen a’s en b’s, de nulreeks ε inbegrepen, en de meest rechtse b staat enkel voor zichzelf, dus enkel voor de letter b. Maar als je na alle reeksen bestaande uit a’s en b’s, de nulreeks inbegrepen, de letter b schrijft, dan krijg je in feite alle eindige reeksen a’s en b’s die eindigen op de letter b.
Samengevat: de reguliere uitdrukking (a∪b)∗b is de compacte beschrijving van alle eindige reeksen a’s en b’s die eindigen op de letter b.
We geven nu nog enkele voorbeelden. We geven zowel de reguliere uit- drukking als de corresponderende reguliere verzameling uitdrukkingen.
66
Merk op dat in vele reguliere verzamelingen er iets repetitiefs is in de uitdrukkingen die tot deze reguliere verzamelingen behoren. Het is altijd de moeite waard te onderzoeken of er een repetitief iets in de uitdrukkingen van een reguliere verzameling is, want dit leidt tot het gebruik van de ∗-notatie in de reguliere uitdrukking die correspondeert met de gegeven reguliere ver- zameling.
Voorbeeld 4.1.5 •
L={w∈{a,b}∗ :|w|iseven} heeft als corresponderende reguliere uitdrukking:
(aa∪ab∪ba∪bb)∗.
L = {w ∈ {a, b}∗ : |w| bevat een oneven aantal a}
•
Er geldt dat de reguliere talen exact samenvallen met de talen die aan- vaard kunnen worden door de eindige deterministische automaten. Dit is de stelling van Kleene.
We zullen de volgende twee stellingen bewijzen.
Stelling 4.1 Elke taal L die beschreven kan worden door een reguliere uit- drukking, kan aanvaard worden door een bijbehorende eindige determinis- tische automaat.
Stelling 4.2 Elke taal L die aanvaard kan worden door een eindige determi- nistische automaat, kan beschreven worden door een bijbehorende reguliere uitdrukking.
We bewijzen nu eerst Stelling 4.1: Voor elke reguliere uitdrukking is er een corresponderende EDA die de taal beschreven door deze reguliere uitdrukking aanvaardt.
We bewijzen deze stelling door een eindige automaat te construeren die hoort bij een reguliere uitdrukking, door voor elk van de rekenregels in Definitie 4.1.1, de bijhorende methode te geven om de erbij corresponderende eindige automaat te construeren.
Eerst geven we de EDA voor de taal L = ∅ (Figuur 4.1), dan voor de taal L = {c} (Figuur 4.2), met c ∈ Σ, en dan voor de taal L = {ε} = ∅∗
67
heeft als corresponderende reguliere uitdrukking:
b∗ab∗(ab∗ab∗)∗.
￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼Figuur 4.1: EDA voor ∅
Figuur 4.2: EDA voor constante c
Figuur 4.3: EDA voor de nulreeks ε = (∅)∗
(Figuur 4.3).
Unie: Nu maken we de EDA voor α = β ∪ γ, met β en γ zelf reguliere
uitdrukkingen, als hun eigen EDA M1 en M2 gegeven zijn.
Dit wordt geillustreerd door Figuur 4.4. Plaats de EDA M1 en M2 die respectievelijk de reguliere uitdrukkingen α en β aanvaarden, als het ware in parallel.
Plaats voor hen een nieuwe starttoestand S en verbind de starttoestand S via ε-transities met de starttoestanden S1 en S2 van de EDA M1 en M2.
Concatenatie: Nu maken we de EDA voor de concatenatie α = βγ, met β en γ zelf reguliere uitdrukkingen, als hun eigen EDA M1 en M2 ge- geven zijn.
Dit wordt geillustreerd door Figuur 4.5. Plaats de EDA M1 en M2 die respectievelijk de reguliere uitdrukkingen α en β aanvaarden, als het ware serieel.
Verbind nu alle aanvaardende toestanden uit de EDA M1 via een ε- transities met de starttoestand S2 van de EDA M2, waarbij ook de aanvaar- dende toestanden in de EDA M1 hun status van aanvaardende toestand zien
68
￼￼￼￼￼
￼￼￼￼￼￼￼￼Figuur 4.4: EDA voor de unie α ∪ β
￼Figuur 4.5: EDA voor de concatenatie βγ
veranderen naar de status van niet-aanvaardende toestand.
Kleene ster: Nu maken we de EDA voor de Kleene ster α = β∗, met β zelf regulier, als de EDA M1 voor de reguliere uitdrukking β gegeven is.
Figuur 4.6 toont de EDA M1 voor β.
Nu geven we de correcte manier om deze EDA M1 om te zetten in de
EDA M voor de Kleene ster α = β∗: 69
￼￼￼￼￼￼￼￼Plaats een nieuwe starttoestand S voor de starttoestand S1 van M1, en maak deze nieuwe starttoestand S een aanvaardende toestand. Verbind daarna deze nieuwe starttoestand S met de oude starttoestand S1 van M1 via een ε-transitie. Verbind ook alle aanvaardende toestanden in de EDA M1 die β aanvaardt via een ε-transitie met de oude starttoestand S1 van de EDA M1 die β aanvaardt.
Hierboven wordt vermeld dat de methode hiervoor vermeld de correcte manier is om deze EDA M1 om te zetten in de EDA M voor de Kleene ster α = β∗.
Meestal wordt als oplossing voorgesteld:
om de EDA M1 die β aanvaardt om te zetten in de EDA M die de Kleene ster α = β∗ aanvaardt, verbind gewoon alle aanvaardende toestanden in de EDA M1 die β aanvaardt via een ε-transitie met de starttoestand S1 van de EDA M1 die β aanvaardt.
Maar dit voorstel is niet altijd correct.
De vraag naar jullie toe is dan ook: wat kan er soms mislopen?
Figuur 4.6: EDA voor de Kleene ster α = β∗
Voorbeeld 4.1.6 Nu zullen we een volledig uitgewerkt voorbeeld tonen. We construeren via de hierboven vermelde rekenregels en constructies de EDA die de taal L = (a ∪ ab)∗ aanvaardt.
Figuur 4.7 toont de EDAs die b en a aanvaarden. Figuur 4.8 toont de EDA die ab aanvaardt.
70
￼
￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼is.
Daarna volgt de EDA die b ∪ ab aanvaardt.
We besluiten met de EDA die (b ∪ ab)∗ aanvaardt.
Figuur 4.7: EDAs die a en b aanvaarden
Figuur 4.8: EDA die ab aanvaardt
Figuur 4.9: EDA die b ∪ ab aanvaardt
Figuur 4.10: EDA die (b ∪ ab)∗ aanvaardt
Merk wel op dat de geconstrueerde eindige automaat soms niet-deterministisch
71
￼￼￼￼￼￼We bewijzen nu Stelling 4.2: Voor elke taal aanvaard door een EDA is er een corresponderende reguliere uitdrukking die deze taal be- schrijft.
We zullen dit opnieuw bewijzen via een constructieve methode om de EDA om te zetten naar een nieuwe automaat die precies twee toestanden heeft: de starttoestand, die niet-aanvaardend is, en precies  ́e ́en andere toe- stand die wel aanvaardend is, met als label voor de pijl van de starttoestand naar de andere toestand, een reguliere uitdrukking die de taal beschrijft aan- vaard door deze EDA. De volgende twee figuren illustreren dit. Het label op de pijl van toestand q1 naar toestand q3 in de tweede figuur is ab∗a, en is een reguliere uitdrukking die de taal beschrijft aanvaard door de EDA in de eerste figuur.
Figuur 4.11: Originele EDA
Figuur 4.12: Reguliere uitdrukking aanvaard door deze EDA
Voorbereidende stappen: eerst voeren we een paar voorbereidende bewerkingen uit op de EDA om de EDA in de geschikte vorm te brengen om de EDA om te zetten in een EDA waaruit we de reguliere uitdrukking voor de aanvaarde taal kunnen aflezen:
1. verwijder alle toestanden die niet-bereikbaar zijn.
2. Maak een nieuwe starttoestand zodat de nieuwe starttoestand geen deel uitmaakt van een lus die doorlopen kan worden in de graaf van de EDA. Verbind de nieuwe starttoestand met de originele starttoestand van de EDA via een ε-transitie.
3. Als er meer dan  ́e ́en aanvaardende toestand is, voeg dan een nieuwe toestand bij die de enige aanvaardende toestand zal zijn. Verbind de
72
￼￼
￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼originele aanvaardende toestanden in de EDA via een ε-transitie met de nieuwe aanvaardende toestand, waarbij de originele aanvaardende toestanden uit de EDA ook hun status van aanvaardende toestand verliezen, en niet-aanvaardende toestanden worden.
4. Als er meerdere transities zijn tussen twee toestanden p en q, voeg deze dan samen tot  ́e ́en transitie via de unie-operator.
5. Als er transities ontbreken tussen toestanden, voeg deze bij met het label ∅.
Formeel worden deze voorbereidende stappen gerealiseerd in het algo- ritme standardize:
standardize(M : EDA) =
1. Verwijder de onbereikbare toestanden uit M.
2. Indien nodig, cre ̈eer een nieuwe starttoestand.
3. Indien nodig, cre ̈eer een nieuwe aanvaardende toestand.
4. Als er meer dan  ́e ́en transitie is tussen de toestanden p en q, voeg deze samen tot  ́e ́en transitie.
5. Als er transities ontbreken tussen toestanden, cre ̈eer deze transities met als label ∅.
Voorbereidende stappen 2 en 3 worden ge ̈ıllustreerd in Figuren 4.13 en 4.14.
Figuur 4.13: Originele EDA
Voorbereidende stap 4 wordt ge ̈ıllustreerd in Figuren 4.15 en 4.16.
Verwijderen van toestanden via het rip-algoritme: Het algoritme om de graaf van een EDA om te zetten in een graaf met enkel een start- toestand, die niet-aanvaardend is, en  ́e ́en andere (aanvaardende) toestand,
73
￼
￼￼￼￼￼￼￼￼￼Figuur 4.14: EDA met nieuwe starttoestand en  ́e ́en (nieuwe) aanvaardende toestand
Figuur 4.15: Twee transities tussen twee toestanden
Figuur 4.16: Twee transities samengevoegd tot  ́e ́en transitie
waarbij het label van de starttoestand naar de andere toestand een reguliere uitdrukking is voor de taal aanvaard door deze EDA, wordt het rip-algoritme genoemd, en werkt als volgt:
het rip-algoritme doet iteratief toestanden weg, maar past de labels aan zodat nog altijd dezelfde uitdrukkingen verwerkt worden.
Intu ̈ıtief komt het aanpassen van de labels neer op het langer maken van de labels.
De volgende twee figuren illustreren dit. Bij overgang naar de tweede figuur wordt de toestand 3 weggelaten, maar worden alle labels die via toe- stand 3 passeren aangepast tot het label aa∗b op de pijl van toestand 2 naar toestand 1, die de samentrekking is van de pijlen en de lus die vroeger leidden van toestand 2 naar toestand 1, via toestand 3.
74
￼￼
￼￼￼￼￼￼￼￼￼Figuur 4.17: EDA voor het rip-algoritme wordt toegepast op toestand 3
￼Figuur 4.18: EDA na het rip-algoritme toegepast is op toestand 3
De formele beschrijving van het rip-algoritme is als volgt. Stel dat rip de toestand is die wij willen verwijderen uit de graaf van de EDA, dan dienen de labels in de graaf van de EDA als volgt aangepast te worden. Stel dat p en q twee toestanden zijn in de graaf van de EDA, verschillend van rip, dan dient na het weglaten van de toestand rip het label op de transitie van toestand p naar toestand q als volgt aangepast te worden. Hier staat R voor de labels in de originele graaf van de EDA, en staat R′ voor de labels in de graaf van de EDA, na het weglaten van de toestand rip:
R′(p, q) = R(p, q) ∪ R(p, rip)R(rip, rip)∗R(rip, q),
• R(p,q) het label op de transitie die rechtstreeks gaat van toestand p
met
naar toestand q,
• R(p,rip) het label op de transitie die rechtstreeks gaat van toestand p naar toestand rip,
• R(rip, rip) het label op de lus rond toestand rip,
75
• R(rip,q) het label op de transitie die rechtstreeks gaat van toestand rip naar toestand q.
Het formele algoritme is buildregex:
buildregex(M : EDA) =
1. Als de EDA M geen aanvaardende toestanden heeft, geef ∅ terug.
2. Als de EDA M slechts  ́e ́en toestand heeft, geef ε terug.
3. Tot enkel de start- en de aanvaardende toestand overblijven, doe:
(a) Selecteer een toestand rip in de EDA M, verschillend van de start- en de aanvaardende toestand.
(b) Voor elke transitie van toestand p naar toestand q, beide verschil- lend van toestand rip:
bereken het nieuwe label R′ voor de transitie van toestand p naar toestand q via:
R′(p, q) = R(p, q) ∪ R(p, rip)R(rip, rip)∗R(rip, q),
(c) Verwijder de toestand rip en alle transities die deze toestand rip
verlaten of bereiken.
4. Geef het label terug dat op de transitie staat van de starttoestand naar de aanvaardende toestand.
Tesamen vormen het voorbereidend algoritme standardize en het effec- tieve algoritme buildregex dat de EDA omzet naar de EDA die de reguliere uitdrukking geeft die deze EDA aanvaardt, het algoritme fsmtoregex:
fsmtoregex(M : EDA) =
1. 2.
4.2
M′ = standardize(M : EDA). Geef buildregex(M′) terug.
Reguliere uitdrukkingen in praktische toepas- singen
Reguliere uitdrukkingen treden overal op binnen de informatica. E ́en van de hoofdredenen is het feit dat patronen die voldoen aan een reguliere uitdruk- king gemakkelijk gecontroleerd kunnen worden, namelijk door code equiva- lent aan de werking van een EDA. We geven in de volgende voorbeelden
76
enkele praktische voorbeelden van veel gebruikte zaken binnen de informa- tica die voldoen aan een reguliere uitdrukking.
Het eerste voorbeeld betreft de programmeertaal Perl die herkenning van reguliere uitdrukkingen ondersteunt. Hierna geven we in Figuren 4.19 en 4.20 de rekenregels voor het opstellen van reguliere uitdrukkingen binnen de programmeertaal Perl. We zien dat hier meer regels optreden dan in Definitie 4.1.1.
De reden hiervoor is als volgt. Door meer speciale symbolen en meer regels toe te laten, kunnen de reguliere uitdrukkingen gemakkelijker opge- steld worden. Op deze manier kunnen meer mensen via deze regels reguliere uitdrukkingen opstellen.
Figuur 4.19: Rekenregels voor reguliere uitdrukkingen in Perl I
Sommige van de symbolen uit de twee tabellen kennen we uit Definitie 4.1.1, zoals de Kleene ster, en het plus-teken. We zien dat het of teken ∪ uit Definitie 4.1.1 bij Perl correspondeert met het |-symbool. We zien ook dat het vraagteken een betekenis heeft. Zo toont de eerste tabel dat a? staat voor hoogstens  ́e ́en keer de reguliere uitdrukking a. Verder staat [a-z] voor een bereik: alle karakters tussen a en z, dus alle letters, terwijl [ˆa- z] staat voor het verbieden van een reeks karakters. Hier staat [ˆa-z] voor het verbieden van alle karakters tussen a en z, dus er mogen geen letters optreden.
77
￼￼￼
￼￼Figuur 4.20: Rekenregels voor reguliere uitdrukkingen in Perl II
Voorbeeld 4.2.1 • Een decimaal getal voldoet aan de volgende regu- liere uitdrukking:
-?([0-9]+(\.[0-9]∗)?| \.[0-9]+)
Referentie: J. Friedl, Mastering Regular Expressions, O’Reilly, 1997
• Een emailadres voldoet aan de volgende reguliere uitdrukking: \b[A-Za-z0-9 %-]+@[A-Za-z0-9 %-]+(\.[A-Za-z]+){1, 4}\b
Voorbeeld 4.2.2 Reguliere uitdrukkingen worden ook gebruikt bij het be- strijden van SPAM.
Stel je beslist dat alle emails met in de subject lijn de reeksen k1, . . . , kn naar je SPAM folder gestuurd dienen te worden, dan kun je deze emails vinden door een EDA op te stellen die controleert of de subject lijnen in je emails voldoen aan de reguliere uitdrukking:
(Σ∗(k1 ∪···∪kn)Σ∗)+ met Σ het alfabet dat gebruikt wordt.
78
￼￼
Hoofdstuk 5
Reguliere grammatica’s
In de informatica worden programmeertalen gebruikt. We hebben in de vorige hoofdstukken gesproken over de taal aanvaard door een eindige de- terministische automaat.
Hoe worden programmeertalen opgesteld? Waarom hebben program- meertalen een bepaalde structuur?
Programmeertalen hebben net zoals gesproken taal een grammatica.
Bij gesproken talen leert de grammatica ons via de regels van de gram- matica hoe correct zinnen opgesteld kunnen worden in deze taal; zinnen die een betekenis hebben, of equivalent hiermee, die begrepen kunnen worden door de persoon tegen wie deze zin uitgesproken wordt.
De grammatica van een programmeertaal of een andere taal heeft het- zelfde doel. De grammatica dient ons de regels te geven zodat correcte zinnen, in deze context computerprogramma’s in deze programmeertaal, opgesteld kunnen worden, zodat deze zinnen, dus computerprogramma’s, begrepen kunnen worden door de computer, en zodat deze computer deze programma’s kan uitvoeren. Maar hier is er ook een belangrijk aspect naar de schrijver van deze computerprogramma’s toe. Ook de schrijver van deze computerprogramma’s dient via deze regels te weten wat het programma zal doen, zodat de code van deze computerprogramma’s correct opgesteld kan worden om de computer de hem opgelegde taak correct uit te laten voeren, en zodat de schrijver van de computerprogramma’s zeker is, dat als de code correct is, dat de computer exact zal doen wat hem gevraagd wordt te doen.
5.1 Definities
Definitie 5.1.1 Een grammatica G is een 4-tal G = (V, Σ, R, S), met:
• V het gebruikte alfabet. Hier bestaat V uit niet-terminalen en termi-
nalen.
Meestal zullen de niet-terminale symbolen met drukletters aangeduid
worden, en de terminale symbolen met kleine letters.
79
• Σ, de verzameling van de terminale symbolen, is een deelverzameling van het alfabet V .
• R, de verzameling van de herschrijfregels, is een eindige verzameling regels van de vorm:
X → Y.
De betekenis van een dergelijke herschrijfregel X → Y is dat het lin- kergedeelte X vervangen (herschreven) wordt door het rechtergedeelte Y.
• S is het startsymbool, en is een niet-terminaal uit het alfabet V .
Intu ̈ıtief betekenen de niet-terminalen symbolen die nog dienen vervan- gen te worden, terwijl de terminalen intu ̈ıtief constanten voorstellen die niet meer vervangen mogen worden. Ook de grammatica van een programmeer- taal, zoals JAVA, kan beschreven worden door herschrijfregels, zoals later getoond zal worden. Elk programma geschreven in JAVA kan bekomen wor- den door herschrijfregels toe te passen, startend bij het startsymbool S. Het is de bedoeling om herschrijfregels toe te passen, startend bij het startsym- bool S, tot een zin, dus een computerprogramma, bekomen wordt dat enkel bestaat uit terminalen. Intu ̈ıtief betekent dit dat alle variabelen een inhoud hebben.
Bijvoorbeeld, stel x := 5 en y := 7 in een computerprogramma. Wat doet dan de computer als deze z := x + y; dient te berekenen? De computer vervangt (herschrijft) x door 5 en y door 7, en bekomt daardoor z := 5 + 7;, en nu kan de computer dit uitrekenen, en z := 12 stellen.
Dit lukt omdat de variabele (niet-terminaal) x herschreven kan worden naar de terminaal (constante) 5, en de variabele (niet-terminaal) y herschre- ven kan worden naar de terminaal (constante) 7. En daardoor kan de vari- abele (niet-terminaal) z herschreven worden naar de terminaal (constante) 12.
Moest door een programmeerfout de variabele x geen inhoud hebben, dan kan de computer de berekening z := x + y; niet uitvoeren, en dan geeft de computer een foutmelding. In feite zegt de computer dan tegen de programmeur dat het hem opgelegde programma niet volledig bestaat uit terminalen; er is nog een niet-terminaal aanwezig in de code.
De complexiteit van de herschrijfregels in een grammatica bepaalt de complexiteit van de taal die deze grammatica definieert. In dit hoofdstuk bespreken we de grammatica’s van reguliere talen; dit zullen nog gramma- tica’s zijn met heel eenvoudige herschrijfregels, maar in de volgende delen worden er complexere talen, en dus complexere grammatica’s besproken.
In de volgende definitie geven we de herschrijfregels voor de grammatica van een reguliere taal, dus van een taal die herkend kan worden door een eindige deterministische automaat.
80
Definitie 5.1.2 In een reguliere grammatica dienen de herschrijfregels X → Y te voldoen aan de volgende restricties:
• Links staat precies  ́e ́en niet-terminaal. • Rechts staat
– de nulreeks ε, of
– precies  ́e ́en terminaal, of
– precies  ́e ́en terminaal gevolgd door precies  ́e ́en niet-terminaal.
Bijvoorbeeld, de volgende herschrijfregels zijn toegelaten bij reguliere grammatica’s:
S→a,S→ε, en,T →aS.
Maar de volgende herschrijfregels zijn niet toegelaten bij reguliere gram-
matica’s:
S → aSa en aSa → T.
Definitie 5.1.3 De taal L(G) bepaald door een grammatica G is de verza- meling van alle reeksen terminalen w die bekomen kunnen worden uit het startsymbool S van de grammatica G, door het toepassen van een eindig aan- tal herschrijfregels uit de verzameling herschrijfregels R van de grammatica G.
Voorbeeld 5.1.4 In het volgende voorbeeld geven we de reguliere taal L bestaande uit alle reeksen a’s en b’s van even lengte, de reguliere uitdruk- king voor deze reguliere taal, de EDA die deze taal aanvaardt, alsook de herschrijfregels van de grammatica van deze taal L:
L={w∈{a,b}∗ :|w|iseven}. De taal L is bepaald door de reguliere uitdrukking
(aa∪ab∪ba∪bb)∗ en door de grammatica met als herschrijfregels
￼￼S→ε S → aT S → bT
￼￼￼￼￼T→a
T→b T → aS T → bS
￼￼￼￼￼￼￼81
￼￼￼￼￼Figuur 5.1: EDA die de taal L aanvaardt
Het voorgaande voorbeeld illustreert de equivalentie tussen de vele be- grippen: reguliere taal, reguliere uitdrukking, EDA die deze reguliere taal aanvaardt, alsook de herschrijfregels van de bijhorende reguliere gramma- tica.
De equivalentie tussen reguliere uitdrukkingen, en dus ook reguliere ta- len, en eindige deterministische automaten, werd bewezen in Stellingen 4.1 en 4.2. Nu tonen we de equivalentie aan tussen de reguliere grammatica’s en de reguliere talen.
Stelling 5.1 De klasse talen die gedefinieerd worden door reguliere gram- matica’s valt samen met de klasse van de reguliere talen.
BEWIJS: Deze equivalentie wordt in twee stappen bewezen. We tonen aan hoe elke reguliere grammatica kan hervertaald worden naar een eindige deterministische automaat. De omgekeerde weg: elke eindige determinis- tische automaat kan hervertaald worden naar een reguliere grammatica, is analoog, en wordt als oefening gelaten.
Omzetting van reguliere grammatica G naar EDA M: Zij G = (V, Σ, R, S) een gegeven reguliere grammatica:
1. Cre ̈eer in M een aparte toestand voor elke niet-terminaal in het alfabet V van G.
2. De starttoestand S in M is de toestand corresponderend met het start- symbool S van G.
3. Als er herschrijfregels zijn in R van de vorm X → w, met w ∈ Σ, cre ̈eer een nieuwe toestand, die gelabeld wordt met #.
4. Voor elke herschrijfregel van de vorm X → wY , teken een transitie van de toestand X in M naar de toestand Y in M, met het label w.
5. Voor elke herschrijfregel van de vorm X → w, teken een transitie van de toestand X in M naar de toestand # in M, met het label w.
6. Voor elke herschrijfregel van de vorm X → ε, markeer de toestand X in M als aanvaardende toestand.
82
￼￼￼￼￼￼￼￼￼￼￼￼7. Markeer de toestand # in M als aanvaardende toestand. We geven nu twee voorbeelden.
Voorbeeld 5.1.5 Beschouw de taal
L = {w ∈ {a, b}∗ : w eindigt met de reeks aaaa},
met als herschrijfregels
Deze herschrijfregels leiden tot de volgende EDA.
￼￼￼S → aS S → bS S → aB
￼￼￼￼￼B → aC C → aD D→a
￼￼￼￼Figuur 5.2: EDA die de taal L aanvaardt
Voorbeeld 5.1.6 Beschouw de taal L ⊂ {a, b, c}∗ bestaande uit de reeksen a’s, b’s en c’s die hoogstens twee van de drie letters a, b, c bevatten, met als herschrijfregels.
￼￼￼S→ε S → aB S → aC S → bA S → bC S → cA S → cB
￼￼￼￼￼￼￼￼￼￼￼￼A → bA A → cA A→ε B → aB B → cB B→ε
￼￼C → aC C → bC C→ε
￼￼￼￼￼￼￼￼￼￼￼￼￼83
￼￼￼￼￼Figuur 5.3: EDA die de taal L aanvaardt
84
Hoofdstuk 6
Reguliere en niet-reguliere talen
6.1 Inleiding
In de vorige hoofdstukken hebben we een gedetailleerde studie gemaakt van eindige deterministische automaten, en de hierbij horende concepten, zoals reguliere uitdrukkingen en reguliere talen.
Er zijn oneindig veel eindige deterministische automaten, en dus oneindig veel reguliere talen, maar toch dienen we op te merken dat er oneindig veel talen zijn die niet-regulier zijn.
De reguliere talen zijn heel eenvoudige talen. Dit kan ingezien worden via het feit dat zij herkend kunnen worden door een heel eenvoudige automaat, de eindige deterministische automaat.
E ́en van de kenmerken van een eindige deterministische automaat is dat deze automaat geen geheugencapaciteit heeft, en dus geen tussenresultaten kan opslaan. Hieruit kan al afgeleid worden dat eindige deterministische automaten maar heel eenvoudige talen kunnen aanvaarden. Het klassiek voorbeeld van een niet-reguliere taal, die dus te complex is om aanvaard te wordendooreenEDA,isdetaalL={anbn :n∈N}.
Het kan als volgt intu ̈ıtief ingezien worden dat deze taal L niet aanvaard kan worden door een automaat zonder geheugencapaciteit. E ́en van de be- langrijke aspecten aan een woord anbn uit de taal L is dat het aantal a’s gelijk is aan het aantal b’s. Hoe kan een automaat controleren dat het aantal a’s gelijk is aan het aantal b’s, als deze automaat geen geheugencapaciteit heeft?
Zoals gezegd, het idee uit de vorige paragraaf is een intu ̈ıtief idee om aan te tonen dat de taal L = {anbn : n ∈ N} niet-regulier is.
In dit hoofdstuk zullen we enkele technieken voorstellen om het regulier zijn, of het niet-regulier zijn, van een taal L aan te tonen. De techniek die wij centraal willen stellen, is de techniek van het pompend lemma, dat een
85
voorwaarde geeft waaraan elke oneindig grote reguliere taal voldoet. Als een oneindig grote taal dus niet aan deze voorwaarde uit het pompend lemma voldoet, dan kan zij dus niet regulier zijn. En dit is precies de manier waarop we dit pompend lemma zullen gebruiken: om aan te tonen dat bepaalde oneindig grote talen niet-regulier zijn.
Eerst en vooral tonen we via idee ̈en uit de logica aan dat er effectief talen bestaan die niet-regulier zijn.
Stelling 6.1 Er zijn een aftelbaar oneindig aantal reguliere talen.
BEWIJS: Er zijn minstens een oneindig aftelbaar aantal reguliere talen.
Bijvoorbeeld: elke eindige taal is regulier. Zij L = {k1, . . . , kn}, met k1,...,kn eindige reeksen over een eindig alfabet Σ. Dan is k1 ∪ ··· ∪ kn een reguliere uitdrukking voor de taal L, en bijgevolg, is deze taal L dus regulier.
Er kunnen oneindig veel eindige deelverzamelingen woorden over een ein- dig alfabet geconstrueerd worden, dus het aantal reguliere talen is zeker al oneindig groot.
Maar er kunnen niet meer dan een oneindig aftelbaar aantal reguliere talen zijn, daar er analoog een oneindig aftelbaar aantal reguliere uitdruk- kingen gemaakt kunnen worden, en elke reguliere verzameling is gedefinieerd door een reguliere uitdrukking. P
Stelling 6.2 Er zijn oneindig veel talen die niet-regulier zijn.
BEWIJS: Neem een eindig alfabet Σ.
Er kunnen een oneindig aftelbaar aantal reguliere uitdrukkingen over dit alfabet Σ opgesteld worden, dus zoals in de vorige stelling bewezen, het aantal reguliere talen over het alfabet Σ is oneindig aftelbaar, dus even groot als N.
Maar beschouw nu de verzameling Σ∗, de verzameling van alle eindige reeksen symbolen uit Σ, met of zonder herhaling van de symbolen in Σ, de nulreeks ε inbegrepen.
Deze verzameling Σ∗ is oneindig groot, en het aantal deelverzamelingen (eindig of oneindig groot) van Σ∗ is oneindig niet-aftelbaar, even groot als R. Elk van deze deelverzamelingen van Σ∗ kan gezien worden als een taal over het alfabet Σ.
Maar de verzameling van de re ̈ele getallen R is veel groter dan de ver- zameling van de natuurlijke getallen N. Dus er zijn oneindig veel meer niet-reguliere talen dan er reguliere talen zijn. P
De volgende stelling geeft het eenvoudigste idee om van sommige talen te controleren dat zij regulier zijn. Elke eindige taal is regulier.
86
Stelling 6.3 Elke eindige taal is regulier.
BEWIJS: Als een taal L de ledige verzameling is, dan correspondeert zij met de reguliere uitdrukking ∅, en is zij dus regulier.
Als L = {k1,...,kn}, met k1,...,kn eindige reeksen over een eindig al- fabet Σ, dan is k1 ∪ · · · ∪ kn een reguliere uitdrukking voor de taal L, en bijgevolg, is deze taal L dus regulier. P
Er zijn vele manieren om aan te tonen dat een taal regulier is. Het is best door voorbeelden te bekijken en oefeningen te maken om ervaring op te doen welke methode het geschiktst is om van een bepaalde reguliere taal, effectief aan te tonen dat zij regulier is. Hierna geven we enkele van deze technieken.
Zij L een taal die regulier is, dan kan je via  ́e ́en van de volgende tech- nieken formeel aantonen dat zij regulier is.
• Toon aan dat deze taal L eindig is.
• Geef een EDA die deze taal L aanvaardt.
• Geef een reguliere uitdrukking die deze taal L beschrijft.
• Toon aan dat het aantal equivalentieklassen voor de equivalentierelatie ≈L eindig is.
• Geef een reguliere grammatica voor deze taal L.
• Benut sluitingseigenschappen voor de verzameling van alle reguliere
talen.
Het benutten van sluitingseigenschappen voor de verzameling van alle reguliere talen, komt neer op het volgende. Er zijn bepaalde bewerkingen die, als zij toegepast worden op reguliere talen, opnieuw een reguliere taal opleveren. Dus als je je afvraagt of een bepaalde taal L regulier is, en je kent een andere reguliere taal L′ en een sluitingseigenschap f voor reguliere talen, zodat f(L′) = L, dan mag je hieruit besluiten dat de taal L wel degelijk regulier is.
We geven enkele van de bijzonderste sluitingseigenschappen voor regu- liere talen.
Stelling 6.4 De verzameling van alle reguliere talen is gesloten onder de volgende bewerkingen:
• Unie,
• Concatenatie,
87
• Kleene ster,
• Complement,
• Doorsnede,
• Verschil,
• Omkering,
• Substitutie van letters.
Substitutie van letters: We spreken van een substitutie van letters in de woorden en in de zinnen van een taal L1 als er een substitutiefunctie letsub van de volgende vorm toegepast wordt op de woorden en op de zinnen van deze taal L1.
Stel dat Σ1 en Σ2 alfabetten zijn, en stel dat er een functie sub: Σ1 → Σ∗2 is. Dan
letsub(L1) = {w∈Σ∗2 :∃y∈L1 en
w = y behalve dat elke karakter c binnen y
vervangen is door sub(c)}.
Voorbeeld 6.1.1 Beschouw de taal L = {anbn : n ∈ N} en beschouw de volgende substituties van de letters: sub(a) = 0 en sub(b) = 11.
Dan letsub({anbn : n ∈ N}) = {0n(11)n : n ∈ N}.
We bewijzen enkele van deze sluitingseigenschappen.
BEWIJS Complement: Zij L een reguliere taal over het alfabet Σ, dan is het complement ¬L = Σ∗ \ L ook een reguliere taal.
Hier is het eenvoudigste bewijs via een EDA M die de reguliere taal L aanvaardt.
Verander in de EDA M alle aanvaardende toestanden in niet-aanvaardende toestanden, en vice versa, verander in de EDA M alle niet-aanvaardende toestanden in aanvaardende toestanden.
Dan krijgen we een nieuwe EDA M ′ die de taal ¬L = Σ∗ \ L aanvaardt.
We hebben een EDA M′ gevonden die de taal ¬L aanvaardt. Dit toont aan dat de taal ¬L ook regulier is. P
BEWIJS: Doorsnede: Stel dat L1 en L2 reguliere talen zijn, dan is ook de taal L1 ∩ L2 regulier.
88
Hier steunen we op vroegere sluitingseigenschappen, en op eigenschappen uit de verzamelingenleer. Er geldt:
L1 ∩ L2 = ¬(¬L1 ∪ ¬L2).
Als L1 en L2 regulier zijn, dan zijn ook ¬L1 en ¬L2 regulier (zie hier- voor).
Als ¬L1 en ¬L2 regulier zijn, dan is ook ¬L1 ∪ ¬L2 regulier, want de unie van twee reguliere verzamelingen is regulier.
Als ¬L1 ∪ ¬L2 regulier is, dan is ook ¬(¬L1 ∪ ¬L2) = L1 ∩ L2 regulier.
We hebben bewezen dat de verzameling van alle reguliere talen gesloten is onder de doorsnede. P
BEWIJS: Verschil: Stel dat L1 en L2 reguliere talen zijn, dan is ook de taal L1 \ L2 regulier.
Dit volgt uit de vorige sluitingseigenschappen daar L1 \ L2 = L1 ∩ ¬L2. P
Opmerking 6.1.2 Het is belangrijk de sluitingseigenschappen op de cor- recte manier toe te passen.
De sluitingseigenschap betreffende de doorsnede zegt:
Als twee talen L1 en L2 regulier zijn, dan is hun doorsnede L = L1 ∩ L2 ook regulier.
Het is belangrijk deze eigenschap niet in de omgekeerde richting toe te passen.
Stel dat een taal L gedefinieerd wordt als de doorsnede van twee talen L1 en L2, dus L = L1 ∩ L2, en stel dat L regulier is, dan kan in principe niks besloten worden betreffende het regulier zijn van de twee originele talen L1 en L2. Dit illustreren we via de twee volgende voorbeelden.
Beschouw de doorsnede L = L1 ∩ L2 beschreven door ab = ab ∩ (a ∪ b)∗,
dan zijn hier in dit voorbeeld alle drie de talen L,L1 en L2 regulier, want alle zijn beschreven via een reguliere uitdrukking.
Maar beschouw de doorsnede L = L1 ∩ L2 beschreven door ab=ab∩{anbn :n∈N},
dan is de linkse taal L regulier, maar de rechtse taal L2 = {anbn : n ∈ N} is het klassieke voorbeeld van een niet-reguliere taal.
89
De vorige paragrafen handelden over technieken om aan te tonen dat een taal regulier is.
Maar stel dat een taal niet-regulier is, welke technieken kunnen dan toegepast worden om aan te tonen dat deze taal niet-regulier is? Opnieuw kan hier geen algoritme gegeven worden dat altijd toegepast kan worden.
We zullen ons concentreren op het pompend lemma dat gebruikt maakt van een kenmerkende eigenschap die geldt voor oneindig grote reguliere ta- len.
Beschouw een oneindig grote reguliere taal L.
Deze taal kan beschreven worden via een reguliere uitdrukking, die een eindige uitdrukking is. De enige manier waarop een eindige, reguliere, uit- drukking, oneindig veel reeksen woorden uit de reguliere taal L kan voorstel- len, is door gebruik van de Kleene ster ∗. Stel dat de reguliere uitdrukking x∗ optreedt binnen de reguliere uitdrukking die de reguliere taal L beschrijft. Deze Kleene ster x∗ betekent dat de uitdrukking x, nul keer,  ́e ́en keer, of meerdere, een willekeurig aantal, keren herhaald mag worden.
Anders gezegd, er bevindt zich iets repetitiefs binnen in de woorden van een oneindig grote reguliere taal.
Dit repetitief karakter binnen in de woorden van een oneindig grote re- guliere taal, vinden we ook terug in de graaf van de EDA M die de reguliere taal L aanvaardt.
De graaf van deze EDA M is een eindige graaf, maar zij aanvaardt wel oneindig veel inputs, namelijk alle woorden uit de taal L.
Dit kan enkel als er cykels doorlopen kunnen worden binnen de graaf van de EDA M. Opnieuw vinden we een repetitief karakter, nu binnen in de graaf van deze EDA M.
We zullen dit nu formeel bestuderen, om een algoritme te ontwikkelen dat gebruikt kan worden om aan te tonen dat bepaalde talen L niet-regulier zijn.
Stelling 6.5 Zij M = (K, Σ, δ, s, A) een eindige deterministische automaat. Als deze EDA M inputs aanvaardt met lengte groter dan of gelijk aan het aantal toestanden |K| in de EDA M, dan zal tijdens de verwerking van deze inputs door de EDA M een bepaalde toestand minstens twee keer doorlopen
worden.
BEWIJS: Zij w een input die aanvaard dient te worden door de EDA M, met |w| ≥ |K|.
De EDA M start met de verwerking van de input w in de starttoestand S. Elke keer dat de EDA M een inputsymbool verwerkt, bezoekt het een toestand.
90
Dus worden er |w| + 1 > |K| toestanden bezocht.
Uit het duivenhokprincipe volgt er dus dat een bepaalde toestand q in de EDA M minstens twee keer doorlopen wordt als de EDA M de input w verwerkt. P
Nu kunnen we het pompend lemma voor reguliere talen formeel beschrij- ven.
Stelling 6.6 (Pompend lemma) Als een taal L regulier is, dan is elke lange zin binnen de taal L opblaasbaar.
Dit betekent: als L regulier is en oneindig groot is, dan: ∃k≥1,∀w∈L: als|w|≥k, dan:
∃x,y,z ∈ Σ∗ (w = xyz en |xy| ≤ k en y ̸= ε, en ∀q ≥ 0(xyqz ∈ L)).
BEWIJS: Stel dat de taal L aanvaard wordt door de EDA M die k := |K| toestanden heeft.
Als w ∈ L en |w| ≥ k, dan als deze EDA M de input w dient te ver- werken, dan zal hij zeker een cykel doorlopen omdat een bepaalde toestand q twee keer doorlopen wordt als de EDA M de input w verwerkt (Stelling 6.5).
Kies de eerste niet-ledige cykel die M doorloopt bij de verwerking van de input w, en stel dat dan de reeks y verwerkt wordt die binnenin w optreedt. Stel dat w = xyz, met dus x het gedeelte van de reeks w voor y en z het
gedeelte van de reeks w na y.
Dan worden ook alle reeksen xyqz, ∀q ∈ N, aanvaard door deze EDA
M, want de cykel die doorlopen wordt bij de verwerking van y mag nul,  ́e ́en of een willekeurig aantal keer doorlopen worden, uiteindelijk zullen deze reeksen xyqz, ∀q ∈ N, toch allemaal eindigen in dezelfde toestand als de input w = xyz, en die eindigt in een aanvaardende toestand.
We hebben aangetoond dat de EDA M ook alle inputs xyqz, ∀q ∈ N, aanvaardt. P
Opmerking 6.1.3 De voorgaande Stelling 6.6 geeft een eigenschap die ze- ker dient te gelden binnen reguliere talen die oneindig groot zijn.
Bijgevolg, als iemand een taal L bestudeert die oneindig groot is, en deze persoon kan aantonen dat deze eigenschap uit Stelling 6.6 niet geldig is binnen deze taal L, dan mag deze persoon onmiddellijk besluiten dat deze taal L niet-regulier is.
Het is precies op deze manier dat de voorgaande Stelling 6.6 toegepast wordt.
We illustreren dit met het volgende voorbeeld.
We tonen nu expliciet aan dat de taal L = {anbn : n ∈ N} niet-regulier is.
91
Voorbeeld 6.1.4 De taal L = {anbn : n ∈ N} is niet-regulier.
BEWIJS: Stel dat deze taal L toch regulier is, dan moet Stelling 6.6
gelden.
We zullen echter een tegenvoorbeeld w ∈ L vinden dat niet voldoet aan
de eigenschap uit Stelling 6.6.
Neem de waarde k uit Stelling 6.6, en neem het woord w ∈ a⌈k/2⌉b⌈k/2⌉ ∈
L. Dan zegt Stelling 6.6 dat w moet te schrijven zijn als w = xyz, met |xy| ≤ k, y ̸= ε, en zodat ∀q ∈ N(xyqz ∈ L).
Maar het lukt niet om deze ontbinding van w in deze vorm xyz te verwe- zenlijken, want stel dat deze ontbinding w = xyz toch kan. Dan krijgen we steeds een tegenstrijdigheid bij de studie van de verschillende mogelijkheden:
• Stely=ap,vooreenzekerep∈N.
Daary̸=ε,isp>0. Laatnuq=2,danisxyqz=ak+pbk,maardit
is geen woord meer uit L daar k+p>k.
• Stely=bp,vooreenzekerep∈N.
Dit leidt tot een analoge tegenstrijdigheid, met q = 2, als in het vorige geval.
• Stel y = apbr, voor zekere p,r > 0. Laat opnieuw q = 2, dan kan opnieuw xy2z niet tot L behoren, omdat in xy2z = · · · apbrapbr · · · , en er dan a’s en b’s door elkaar staan.
Alle mogelijke ontbindingen w = xyz, die voldoen aan de voorwaarden uit Stelling 6.6, zijn gecontroleerd, en geen enkele van deze ontbindingen kan de opgelegde eigenschap xyqz ∈ L, ∀q ∈ N, doen gelden.
Dit toont aan dat de taal L = {anbn : n ∈ N} niet-regulier is. Voorbeeld 6.1.5 De taal
L={an :n priem}
is niet-regulier.
Dit kan opnieuw aangetoond worden door een element w uit de taal L te
vinden dat niet kan voldoen aan de voorwaarden uit Stelling 6.6. Hier die- nen natuurlijk ook wiskundige eigenschappen gebruikt te worden die verband houden met het priem zijn of niet-priem zijn van natuurlijke getallen.
Neem w = aj, met j het kleinste priemgetal groter dan het getal k uit de voorwaarden van Stelling 6.6. Dan moet w = aj te ontbinden zijn in w = xyz, beschreven zoals in Stelling 6.6.
Dan moet xyqz ∈ L, voor alle q ∈ N. Maar hier is xyqz = a|x|+q·|y|+|z|, en xyqz ∈ L impliceert dat, voor alle q ∈ N, het getal |x| + q · |y| + |z| priem moet zijn.
Nu komen de wiskundige eigenschappen van natuurlijke getallen naar voor, om een waarde voor q te vinden zodat |x| + q · |y| + |z| niet-priem is.
92
Neem q = |x| + |z|, dan is
|x|+q·|y|+|z| = |x|+(|x|+|z|)·|y|+|z|
= (|x|+|z|)·(1+|y|),
wat aantoont dat, voor q = |x| + |z|, de macht |x| + q · |y| + |z| niet-priem is, en daardoor xyqz ̸∈ L.
Het woord w uit de taal L, dat moet voldoen aan de voorwaarden uit Stelling 6.6, voldoet niet aan deze voorwaarden.
Dit toont aan dat de taal L = {an : n priem} niet-regulier is. Voorbeeld 6.1.6 Andere voorbeelden van talen, waarvan het niet-regulier
zijn kan aangetoond worden via Stelling 6.6, zijn:
• De taal Bal =
{w ∈ {), (} : bij elk openend haakje ( hoort een sluitend haakje )} van de gebalanceerde reeksen haakjes is niet-regulier.
• De taal PalEven van de palindromen van even lengte PalEven = {wwR : w ∈ {a, b}∗} is niet-regulier.
• De taal
is niet-regulier.
• De taal
is niet-regulier.
{anbm :n≥m}
{abanbn : n ∈ N}
Er kan geen algoritme gegeven worden dat voor alle talen gebruikt kan worden om te controleren of zij regulier, dan wel niet-regulier, zijn. Soms dienen heuristieke algoritmes toegepast te worden. We geven nu enkele voorbeelden hiervan.
Voorbeeld 6.1.7 Stel er wordt gevraagd om aan te tonen dat de taal L = {w ∈ {a, b}∗ : #a(w) = #b(w)} niet-regulier is.
Dan kun je de volgende redenering gebruiken.
Stel dat deze taal L regulier is, dan zegt de sluitingseigenschap doorsnede voor reguliere talen dat de taal
L′ =L∩a∗b∗
ook regulier is, want de taal L is, per onderstelling, regulier, en de taal a∗b∗
is zeker regulier, want zij is gedefinieerd door een reguliere uitdrukking.
93
Maar deze taal L′ = {anbn : n ∈ N} is het klassiek voorbeeld van een niet-reguliere taal.
Dus de onderstelling dat de taal L regulier is, kan niet correct zijn. Dus de taal L is niet-regulier.
Voorbeeld6.1.8 Toon aan dat de taal L = {aibj : i,j ∈ Neni ̸= j} niet-regulier is.
Hier kun je de volgende redenering gebruiken.
Stel dat deze taal L regulier is, dan is zijn complement ¬L ook regulier daar de verzameling van de reguliere talen gesloten is onder complemente- ring.
Nu is ¬L = {anbn : n ∈ N}∪L′′, met L′′ de taal bestaande uit de reeksen a’s en b’s waarin de a’s niet allemaal voor alle b’s staan.
Daar ¬L regulier is, geldt wegens de sluitingseigenschap doorsnede voor de verzameling van de reguliere talen dat de doorsnede van ¬L met de regu- liere taal a∗b∗, dus L′ = ¬L ∩ a∗b∗ ook regulier is.
Maar L′ = {anbn : n ∈ N} is opnieuw het klassiek voorbeeld van een niet-reguliere taal.
Dus de onderstelling dat de taal L regulier is, kan niet correct zijn. Dus de taal L is niet-regulier.
94
Hoofdstuk 7
Beslissingsprocedures voor reguliere talen
7.1 Inleiding
Vele vragen worden gesteld over reguliere talen.
Wij zullen ons in dit hoofdstuk concentreren op beslissingsprocedures
voor reguliere talen.
Definitie 7.1.1 Een beslissingsprocedure is een algoritme voor het oplossen
van een probleem, en waarvan het resultaat een Booleaanse waarde is.
Uit deze definitie volgt dat een beslissingsprocedure dus moet: • stoppen, en,
• correct zijn.
Sommige algoritmes hebben we reeds opgesteld in de vroegere hoofd-
stukken.
Operaties op EDA:
• Ndfsmtodfs • MinDFSM
Operaties op reguliere talen:
• Voor de constructies van EDA die de unie, doorsnede, Kleene ster, negatie, doorsnede, verschil, reverse, en letsub van (reguliere) talen aanvaard door EDA aanvaarden.
95
Algoritmes voor de conversie tussen de EDA en hun reguliere gramma- tica’s en uitdrukkingen:
• Gegeven een reguliere uitdrukking α, construeer een EDA M zodat L(α) = L(M).
• Gegeven een EDA M, construeer een reguliere uitdrukking α zodat L(α) = L(M).
• Gegeven een reguliere grammatica G, construeer een EDA M zodat L(G) = L(M).
• Gegeven een EDA M, construeer een reguliere grammatica G zodat L(G) = L(M).
We zullen nu de volgende specifieke vragen over reguliere talen bespre- ken.
7.2 Beslissingsprocedures voor reguliere talen
Vraag 1: Gegeven een EDA M en een input s, zal deze input s aanvaard worden door deze EDA M?
Deze vraag kan door de volgende beslissingsprocedure beantwoord wor- den.
decideFSM(M: EDA, w: input) =
  If ndfsmsimulate(M,w) aanvaardt then return TRUE
                        else return FALSE.
Vraag 2: Gegeven een reguliere uitdrukking a en een reeks w, voldoet w aan deze reguliere uitdrukking a?
Ook deze vraag kan door een beslissingsprocedure beantwoord worden.
decideregex(a: reguliere uitdrukking, w: input) =
  Uit a, gebruik regextofsm om een EDA M te maken
         die de taal L(a) aanvaardt
  Return decideFSM(M,w)
96
Vraag 3: Gegeven een EDA M, is L(M) gelijk aan de ledige verzame- ling?
Deze vraag kan op twee manieren beantwoord worden: via een methode die steunt op de graaf van de EDA, en via een methode die inputs laat ver- werken door de EDA.
Methode 1: via de graaf van de EDA.
• Markeer alle toestanden die bereikbaar zijn vanuit de starttoestand van de EDA M.
• Als minstens  ́e ́en van deze gemarkeerde toestanden een aanvaardende toestand is, geef dan FALSE terug, anders geef TRUE terug
De reden voor deze twee stappen is natuurlijk heel eenvoudig: als min- stens  ́e ́en van de gemarkeerde toestanden een aanvaardende toestand is, dan wil dit zeggen dat er inputs aanvaard zullen worden door deze EDA M, en dan is L(M) ̸= ∅. Dus dan is het FALSE dat L(M) = ∅.
Methode 2: door inputs te laten verwerken door de EDA.
• Let M′ = ndfsmtodfsm(M).
• Voor elke input w ∈ Σ∗ met lengte |w| < |KM′|: decideFSM(M′,w).
• Als M′ minstens  ́e ́en input aanvaardt, geef dan FALSE terug, anders geef TRUE terug.
In de eerste stap van dit algoritme zetten we de EDA M om in zijn corresponderende deterministische automaat M′, omdat we dan zeker we- ten dat per stap die de EDA M′ uitvoert, er precies  ́e ́en karakter uit de input w verwerkt wordt. In de tweede stap verwerken we alle inputs w met lengte kleiner dan |KM′|, met |KM′| het aantal toestanden in de EDA M′. Als minstens  ́e ́en van deze inputs aanvaard wordt, dan zijn we zeker dat L(M) ̸= ∅, anders zijn we zeker dat L(M) = ∅. Verklaar dit laatste besluit.
Vraag 4: Gegeven een EDA M, is L(M) = Σ∗? Hier is de beslissingsprocedure gelijk aan:
• Construeer de EDA M′ die de taal ¬L(M) aanvaardt. • Pas emptyFSM(M′) toe.
97
Vraag 5: Gegeven een EDA M, is |L(M)| eindig?
Deze vraag zullen we opnieuw op twee manieren beantwoorden: via een methode die steunt op de graaf van de EDA, en via een methode die inputs laat verwerken door de EDA.
Methode 1: via de graaf van de EDA.
• M′ = ndfsmtodfsm(M).
• M′′ = minDFSM(M′).
• Markeer alle toestanden in de EDA M′′ die op een pad liggen, vertrek- kend vanuit de starttoestand naar een aanvaardende toestand.
• Beschouw nu enkel deze gemarkeerde toestanden, en onderzoek of er cykels binnen deze gemarkeerde toestanden in M′′ zijn.
• Als er cykels zijn binnen in de gemarkeerde toestanden in M′′, geef dan FALSE terug, anders geef TRUE terug.
Opnieuw maken we in dit algoritme de graaf deterministisch zodat we zeker bij iedere stap een karakter uit de input verwerken. Als er paden zijn die starten vanuit de starttoestand naar een aanvaardende toestand, dan zijn we al zeker dat er inputs aanvaard worden. Maar dan zijn we nog niet zeker dat er oneindig veel inputs aanvaard worden.
Het is pas als we cykels vinden die de gemarkeerde toestanden met elkaar verbinden, dat we zeker zijn dat er oneindig veel inputs aanvaard worden, want die cykels kunnen een willekeurig aantal keer doorlopen worden. Is dit dus het geval, dan is |L(M)| oneindig groot, en is het dus FALSE dat |L(M| eindig is.
Methode 2: door inputs te laten verwerken door de EDA.
• M′ = ndfsmtodfsm(M).
• Voor elke input w ∈ Σ∗, met lengte |KM′| ≤ w ≤ 2|KM′|−1:
decideFSM(M′,w).
• Als de EDA M′ minstens  ́e ́en zo’n input aanvaardt, geef dan FALSE
terug, anders geef TRUE terug. Verklaar dit algoritme.
98
Vraag 6: Gegeven twee EDA M1 en M2, zijn deze equivalent?
Deze vraag komt in feite neer op: is L(M1) = L(M2)?
Hier is het idee de vraag te vertalen naar een vraag waarop het antwoord al gekend is. Namelijk,
L(M1) = L(M2) ⇔ ((L(M1) \ L(M2)) ∪ (L(M2) \ L(M1))) = ∅. Dit leidt tot het volgende algoritme:
equalFSM(M1: EDA, M2: EDA) =
• Construeer de EDA MA om de taal L(M1) \ L(M2) te aanvaarden. • Construeer de EDA MB om de taal L(M2) \ L(M1) te aanvaarden. • Construeer de EDA MC om de taal L(MA) ∪ L(MB) te aanvaarden. • Geef emptyFSM(MC) terug.
Vraag 7: Gegeven de EDA M, is deze EDA minimaal?
De beslissingsprocedure is als volgt: • M′ = minDFSM(M).
• Als |KM | = |KM ′ |, geef dan TRUE terug, anders geef FALSE terug.
We hebben in Hoofdstuk 3 een algoritme opgesteld om een EDA M te minimaliseren tot een EDA M′ met het kleinste aantal benodigde toestan- den. Als M en M′ precies evenveel toestanden hebben, dan is M minimaal, anders niet.
Vraag 8: Gegeven twee reguliere uitdrukkingen α1 en α2, is (L(α1) ∩ L(α2)) \ {ε} ≠ ∅?
Het algoritme gaat als volgt:
• Construeer de EDA M1 zodat L(α1) = L(M1).
• Construeer de EDA M2 zodat L(α2) = L(M2).
• Construeer de EDA M′ zodat L(M′) = L(M1) ∩ L(M2).
• Construeer de EDA Mε zodat L(Mε) = {ε}.
• Construeer de EDA M′′ zodat L(M′′) = L(M′) \ L(Mε).
• Als L(M′′) = ∅, geef dan FALSE terug, anders geef TRUE terug.
99
Vraag 9: (oefening) Gegeven twee reguliere uitdrukkingen α1 en α2, zijn er dan minstens drie reeksen die zowel door α1 als door α2 gegenereerd wor- den?
100
.
Deel 2
Niet-deterministische stapelautomaten,
contextvrije grammatica’s en contextvrije talen
101
Hoofdstuk 8
Contextvrije grammatica’s
8.1 Herschrijfsystemen
We hebben al grammatica’s gedefinieerd in Hoofdstuk 5. Binnen een gram- matica gebruiken we herschrijfregels. Omdat herschrijfregels vari ̈eren van grammatica tot grammatica, defini ̈eren we ook apart een herschrijfsysteem, zodat we herschrijfregels apart kunnen bekijken.
Definitie 8.1.1 Een herschrijfsysteem HS over een woordenboek W is een geordend paar (W,P) waarbij:
• W een alfabet is;
• P een eindige verzameling geordende paren (z1,z2) van zinnen met
z1 ∈ W+ en z2 ∈ W∗.
We gebruiken de notatie z1 →P z2, of kort, z1 → z2 als (z1, z2) ∈ P .
We noemen de verzameling P ook de verzameling van de producties. Elke regel z1 →P z2 is een productie van het herschrijfsysteem.
We hebben al de rekenregels van een reguliere grammatica gedefinieerd in Definitie 4.1.1.
Nu gaan we naar iets ingewikkelder rekenregels, die dan ook leiden tot ingewikkelder grammatica’s, de contextvrije grammatica’s genoemd. Dit zullen grammatica’s zijn die dan natuurlijk ook leiden tot ingewikkelder talen, de contextvrije talen, die dan ook aanvaard worden door ingewikkelder machines, namelijk de niet-deterministische stapelautomaten.
Definitie 8.1.2 Een contextvrije grammatica G = (V, Σ, R, S), met:
• V het gebruikte alfabet. Hier bestaat V uit niet-terminalen en termi-
nalen.
Meestal zullen de niet-terminale symbolen met drukletters aangeduid
worden, en de terminale symbolen met kleine letters.
102
• Σ, de verzameling van de terminale symbolen, is een deelverzameling van het alfabet V .
• R, de verzameling van de herschrijfregels, is een eindige verzameling regels van de vorm:
X → Y, met X ∈ V \ Σ en met Y ∈ V ∗.
• S is het startsymbool, en is een niet-terminaal uit het alfabet V .
We zien dat de herschrijfregels van een contextvrije grammatica geken-
merkt worden door:
• Links staat precies  ́e ́en niet-terminaal.
• Rechts mag een willekeurige reeks symbolen uit het alfabet V staan, de nulreeks ε inbegrepen.
Voorbeeld 8.1.3 De volgende grammatica G = (V,Σ,R,S) definieert de taal L = {anbn : n ∈ N}, het klassiek voorbeeld van een niet-reguliere taal. Deze taal L is ook het klassiek voorbeeld van een contextvrije taal.
• V ={S,a,b}.
• Σ={a,b}.
• De verzameling van de herschrijfregels R bestaat uit de twee herschrijf- regels:
1. S → aSb, 2. S → ε.
• Het startsymbool is de, enige, niet-terminaal S.
Voorbeeld 8.1.4 De volgende grammatica G = (V,Σ,R,S) definieert de taal L van de gebalanceerde haakjes, een tweede klassiek voorbeeld van een contextvrije taal die niet-regulier is.
• V ={S,(,)}.
• Σ={(,)}.
• De verzameling van de herschrijfregels R bestaat uit de drie herschrijf- regels:
1. S → SS, 2. S → (S),
103
3. S → ε.
• Het startsymbool is de, enige, niet-terminaal S.
De bedoeling van de herschrijfregels is opnieuw om zinnen op te stellen die enkel bestaan uit terminalen, door te starten bij het startsymbool S, en dan een eindig aantal herschrijfregels toe te passen. We formaliseren dit in de volgende definitie.
Definitie 8.1.5 De zin y wordt direct afgeleid uit de zin x binnen de gram- matica G, genoteerd als x ⇒G y, als en slechts als x = αAβ en y = αγβ, en A → γ is een herschrijfregel uit de verzameling herschrijfregels R.
Een afleiding in de grammatica G is een reeks van de vorm w0 ⇒G w1 ⇒G w2 ⇒G ···⇒G wn,
dus een eindige reeks van toepassingen van herschrijfregels uit de verzameling herschrijfregels R.
We noteren met ⇒∗G de reflexieve, transitieve sluiting van de afleidings- relatie ⇒G.
De taal voortgebracht door een grammatica G, genoteerd met L(G), is de taal
L(G)={w∈Σ∗ :S⇒∗G w}.
Dus de uitdrukking w0 ⇒∗G wn betekent dat de reeks wn bekomen wordt uit de reeks w0 door het toepassen van een eindig aantal herschrijfregels uit de verzameling herschrijfregels R.
Merk opnieuw op dat de zinnen uit de taal L(G) voortgebracht door een grammatica G, enkel mogen bestaan uit terminale symbolen.
Definitie 8.1.6 Een taal L is contextvrij als zij voortgebracht kan worden door een contextvrije grammatica G.
Definitie 8.1.7 Een herschrijfregel wordt recursief genoemd als en slechts als zij van de vorm
is, en er geldt dat
X → w1Y w2 Y ⇒∗G w3Xw4,
voor zekere reeksen w1, w2, w3, w4 ∈ V ∗.
Een grammatica G wordt recursief genoemd als deze grammatica min-
stens  ́e ́en recursieve herschrijfregel heeft.
104
Voorbeeld 8.1.8 De herschrijfregel
S → (S)
is recursief in combinatie met de volgende twee herschrijfregels:
S → (T )
T → (S)
Definitie 8.1.9 Een herschrijfregel wordt zelf-embeddend genoemd als en
slechts als zij van de vorm
is, en er geldt dat
X → w1Y w2 Y ⇒∗G w3Xw4,
voor zekere reeksen w1w3 en w2w4 behorend tot Σ+.
Een grammatica G wordt zelf-embeddend genoemd als deze grammatica minstens  ́e ́en zelf-embeddende herschrijfregel heeft.
Voorbeeld 8.1.10 • De herschrijfregel S → aSa
is zelf-embeddend. • De herschrijfregel
S → aS is recursief, maar niet zelf-embeddend.
•
S → aT T → Sa
De reden voor de twee voorgaande definities, is dat we vanaf nu naar ingewikkelder grammatica’s en ingewikkelder talen gaan dan de reguliere grammatica’s en reguliere talen. Dus inzicht in de herschrijfregels is heel belangrijk. Welke eigenschappen voor de herschrijfregels leiden tot reguliere talen, en welke eigenschappen voor de herschrijfregels impliceren dat een taal niet-regulier is? De volgende stelling geeft reeds dergelijke eigenschappen.
Stelling 8.1 • Als een grammatica G niet zelf-embeddend is, dan is zij regulier.
105
is zelf-embeddend.
• Als een taal L de eigenschap heeft dat elke grammatica voor deze taal zelf-embeddend is, dan is deze taal L niet-regulier.
BEWIJS: Het bewijs van de eerste eigenschap is niet-triviaal.
Voor de tweede eigenschap, wat zou de verklaring kunnen zijn? P
We geven nu nog enkele klassieke voorbeelden van contextvrije talen. Voorbeeld 8.1.11 • PalEven = {wwR : w ∈ {a,b}∗} is contextvrij,
maar niet-regulier. Een grammatica G voor deze taal is G = ({S,a,b},{a,b},R,S),
met
R = {S → aSa,S → bSb,S → ε}.
• De taal L = {w ∈ {a,b}∗ : #a(w) = #b(w)} van alle reeksen a’s en b’s, met evenveel a’s als b’s. Een grammatica G voor deze taal is G = ({S,a,b},{a,b},R,S), met
R = {S → aSb,S → bSa,S → SS,S → ε}.
Voorbeeld 8.1.12 De taal L van de rekenkundige uitdrukkingen is bepaald
door de grammatica G = (V, Σ, R, E), met
• V = {+,∗,(,),id,E},
• Σ = {+,∗,(,),id},
• R={E→E+E,E→E∗E,E→(E),E→id}.
Op het eerste zicht zien deze herschrijfregels voor het opstellen van re- kenkundige uitdrukkingen er correct uit.
Maar zij zijn echter nog iets te zwak om in de praktijk in programmeer- talen toegepast te worden. We zullen later in Sectie 8.5 zien dat er nog dubbelzinnigheden in de rekenkundige uitdrukkingen door de mazen van het net glippen.
8.2 Backus Naur Form
Nu kunnen we al een belangrijk verband met concrete, veel gebruikte, zaken uit de informatica leggen.
De Backus Naur Form (BNF) is een veel gebruikte manier om program- meertalen te beschrijven.
Het interessante aan de BNF is dat dit in feite een voorstelling is van contextvrije herschrijfregels.
106
De volgende tekst is een beschrijving in BNF voor de programmeertaal JAVA. Hier herkennen we opnieuw het idee van herschrijven: links wordt vervangen door iets dat rechts staat. De pijl → die de scheiding vormt tussen het linkse en het rechtse gedeelte van een herschrijfregel, is hier vervangen door de notatie ::=.
Niet-terminalen, die vroeger in drukletters geschreven werden, staan nu tussen de symbolen < en >, en het |-symbool stelt of voor.
<block> ::= {<stmt-list>} | {}
<stmt-list> ::= <stmt> | <stmt-list> <stmt>
<stmt> ::= <block> | while (<cond>) <stmt> |
    if (<cond>) <stmt> |
      do <stmt> while (<cond>); |
      <assignment-stmt>; |
      return | return <expression> |
    <method-invocation>;
De BNF-notatie voor het opstellen van een natuurlijk getal is als volgt. Hier houden we rekening met het feit dat een natuurlijk getal een eindige reeks cijfers is. Alles is toegelaten, maar enkel het natuurlijk getal 0 begint met 0. Daarom moeten we in de BNF-notatie voor het opstellen van een natuurlijk getal ook een begincijfer defini ̈eren.
<begincijfer> ::= 1|2|3|4|5|6|7|8|9
<cijfer> ::= 0|1|2|3|4|5|6|7|8|9
<natuurlijk getal> ::= <cijfer>|<begincijfer><cijfersequent>
<cijfersequent> ::= <cijfer>|<cijfer><cijfersequent>
De eerste twee rijen duiden aan dat een begincijfer 1,2,..., of 9 is; en dat een cijfer 0,1,2,..., of 9 is. De derde rij betekent dat een natuurlijk getal bestaat uit  ́e ́en cijfer (zie <cijfer > dat op de derde rij voor het | teken staat), of uit een begincijfer, gevolgd door een cijfersequent. De laatste rij duidt dan aan wat een cijfersequent is: dit is ofwel  ́e ́en cijfer, ofwel een cijfer gevolgd door een cijfersequent.
We bespreken nu de BNF van JAVA. Dit is gebaseerd op de website
   http://cui.unige.ch/db-research/Enseignement/analyseinfo/JAVA/
BNFindex.html
Voor de kleine verschillen in notatie, zie
   http://cui.unige.ch/db-research/Enseignement/analyseinfo/AboutBNF.
html
107
De voornaamste verschillen zijn:
• tussen [ en ] is optioneel,
• Haakjes ( en ) worden altijd geplaatst,
• Repetitieve zaken (nul,  ́e ́en, of meerdere keren) staan tussen { en }.
De BNF-notatie voor numerische uitdrukking (numeric expression) is
￼numeric expression ::=
( ( "-”
| ”++”
| "--”) expression )
| ( expression ( ”++”
| "--”) )
| ( expression ( ”+”
| ”+=”
| "-”
| "-=”
| ”*”
| ”*=”
| "/”
| "/=”
| ”%”
| ”%=”) expression ) .
In onze BNF-notaties
￼108
⟨ numeric expression ⟩
::= (-⟨ expression ⟩)| (++⟨ expression ⟩)|
(--⟨ expression ⟩)|
(⟨ expression ⟩++)|
(⟨ expression ⟩--)|
(⟨ expression ⟩ + ⟨ expression ⟩)| (⟨ expression ⟩ += ⟨ expression ⟩)| (⟨ expression ⟩ - ⟨ expression ⟩)|
(⟨ expression ⟩ -= ⟨ expression ⟩)| (⟨ expression ⟩ * ⟨ expression ⟩)| (⟨ expression ⟩ *= ⟨ expression ⟩)| (⟨ expression ⟩ / ⟨ expression ⟩)| (⟨ expression ⟩ /= ⟨ expression ⟩)| (⟨ expression ⟩ % ⟨ expression ⟩)| (⟨ expression ⟩ %= ⟨ expression ⟩)
￼Opmerking 8.2.1 Namen variabelen (identifier) in JAVA. Uit BNF-notatie (nummer 19 op www-pagina)
• de naam moet beginnen met een letter, $, of een underscore ( ),
• de naam mag geen spaties bevatten,
• vanaf de tweede positie mogen ook de cijfers 0, . . . , 9 en bepaalde ka- rakters unicode character over 00C0 gebruikt worden.
Extra voorwaarde:
• de naam mag geen keyword zijn.
De namen van variabelen voldoen in feite aan herschrijfregels voor een reguliere taal. Door dit op te leggen aan de namen van variabelen, kan de computer via een EDA controleren of de namen van variabelen in een computerprogramma correct opgesteld zijn.
Om het idee dat elk JAVA programma bekomen kan worden via de her- schrijfregels voor de grammatica van JAVA opnieuw duidelijk te maken, herhalen we de uiteenzetting die gemaakt is in Sectie 5.1.
Intu ̈ıtief betekenen de niet-terminalen symbolen die nog dienen vervan- gen te worden, terwijl de terminalen intu ̈ıtief constanten voorstellen die niet meer vervangen mogen worden.
Elk programma geschreven in JAVA kan bekomen worden door her- schrijfregels toe te passen, startend bij het startsymbool S. Het is de bedoe- ling om herschrijfregels toe te passen, startend bij het startsymbool S, tot
109
￼
een zin, dus een computerprogramma, bekomen wordt dat enkel bestaat uit terminalen. Intu ̈ıtief betekent dit dat alle variabelen een inhoud hebben.
Bijvoorbeeld, stel x := 5 en y := 7 in een computerprogramma. Wat doet dan de computer als deze z := x + y; dient te berekenen? De computer vervangt (herschrijft) x door 5 en y door 7, en bekomt daardoor z := 5 + 7;, en nu kan de computer dit uitrekenen, en z := 12 stellen.
Dit lukt omdat de variabele (niet-terminaal) x herschreven kan worden naar de terminaal (constante) 5, en de variabele (niet-terminaal) y herschre- ven kan worden naar de terminaal (constante) 7. En daardoor kan de vari- abele (niet-terminaal) z herschreven worden naar de terminaal (constante) 12.
Moest door een programmeerfout de variabele x geen inhoud hebben, dan kan de computer de berekening z := x + y; niet uitvoeren, en dan geeft de computer een foutmelding. In feite zegt de computer dan tegen de programmeur dat het hem opgelegde programma niet volledig bestaat uit terminalen; er is nog een niet-terminaal aanwezig in de code.
8.2.2 John Backus en Peter Naur
John Backus
Figuur 8.1: John Backus
John Backus werd op 3 december 1924 te Philadelphia, Pennsylvania, USA, geboren.
Hij bracht zijn eerste levensjaren door in Wilmington, Delaware, en studeerde aan de Hill School in Pottstown, Pennsylvania. Hij studeerde in 1942 af, alhoewel, naar zijn eigen zeggen, hij zijn studies aan de Hill School niet te serieus opnam: Ik werd ieder jaar van school gestuurd. Ik studeerde nooit. Ik haatte studeren. Ik liep er de kantjes van af. Het had het prettig gevolg dat ik elk jaar naar de zomerklas in New Hampshire ging waar ik de ganse zomer kon gaan zeilen en mij amuseren.
Hij schreef zich in aan de University of Virginia om op zijn vader’s verzoek scheikunde te gaan studeren. Hij was echter niet ijveriger dan aan de Hill School en hij stopte met deze studies in 1943. Dat jaar ging hij naar het leger.
In het leger volgde hij een medische opleiding, en werkte in een hospitaal in At- lantic City in een neuro-chirurgische afdeling waar hoofdwonden behandeld werden.
110
￼
Daar vond men onverwachts dat hij een beentumor had en een plaat werd in zijn hoofd geplaatst. Een medische opleiding zag er uit als de juiste richting voor John Backus, maar na negen maanden opleiding in de medische school gaf hij ook dit op: Ik haatte het. Ze houden niet van nadenken in de medische school. Ze leren van buiten - dat is alles wat ze willen dat je doet. Je mag niet nadenken.
Opnieuw zonder een idee te hebben in welke richting te gaan, huurde hij een appartement in New York. Hij beschrijft wat er vervolgens gebeurde: Ik wist hele- maal niet wat te doen met mijn leven. I besloot dat wat ik wilde een goede hifi keten was omdat ik van muziek hield. Toen bestonden ze echter nog niet, en dus besloot ik naar een school voor radiotechnici te gaan. Ik had een heel goede leraar - de eerste goede leraar die ik ooit had - en hij vroeg mij om met hem samen te werken en voor een tijdschrift de karakteristieke eigenschappen te berekenen van enkele circuits. Ik herinner me eenvoudige berekeningen te doen om enkele punten op een kromme van een versterker te bepalen. Het was afmattend, eentonig, en verschrikkelijk, maar ik geraakte erdoor geinteresseerd in wiskunde. Het feit dat het een toepassing had - dat interesseerde mij.
Backus schreef zich in aan de Columbia University, New York, om wiskunde te gaan studeren. Hij studeerde af in 1949. Net voor hij afstudeerde, bezocht hij het IBM Computer Center op Madison Avenue. Toen hij tegen de gids zei dat hij werk zocht, zei zij hem om met  ́e ́en van de directeurs te gaan praten: Ik zei neen, ik kon niet. Ik zag er namelijk slordig en onverzorgd uit. Maar zij bleef aandringen en ik ging met een directeur praten. Ik nam deel aan een test en slaagde voor de test.
Backus begon te werken als programmeur voor IBM in het jaar 1950. Hij is de ontdekker van FORTRAN, de eerste hogere programmeertaal. FORTRAN werd commercieel beschikbaar in 1957. Toen hij zijn eerste werk over FORTRAN be- schreef, zei Backus: We wisten eigenlijk niet wat we wilden bekomen en hoe we het moesten doen. Het ontstond zomaar. De eerste discussies gingen over hoe de taal eruit zou zien. Dan hoe uitdrukkingen ontleed zouden worden - het was een groot probleem, en wat we doen deden, ziet er nu onvoorstelbaar stuntelig uit . . ..
John Backus ontwierp in 1959 de Backus Naur Form (BNF), een standaardno- tatie om de syntax van een hogere programmeertaal te beschrijven.
Zijn derde grote bijdrage tot de computerwetenschappen was de ontwikkeling van een functionele programmeertaal, FP genoemd, die een wiskundige benadering tot programmeren aanbeveelt.
(bron: http://turnbull.dcs.st-and.ac.uk/∼history/Mathematicians/Backus.html)
Peter Naur
Peter Naur werd geboren op 25 oktober 1928 in Frederiksberg, bij Kopenhagen, Denemarken.
Al vanop de middelbare school kreeg hij interesse voor sterrenkunde, en onder begeleiding van mensen van het observatorium van de Universiteit van Kopenhagen, deed hij berekeningen over de banen van kometen en kleine planeten. Hij begon in 1947 zijn universitaire studies aan de Universiteit van Kopenhagen, en behaalde in 1949 het diploma van sterrenkundige.
Hij bracht het jaar 1950-1951 door als onderzoeker aan King’s College, Cam- bridge, Engeland. Daar ontwierp hij een programma voor de EDSAC voor het
111
￼Figuur 8.2: Peter Naur
berekenen van de perturbatiebewegingen van kleine planeten. De jaren 1952-1953 bracht hij door in de Verenigde Staten, waar hij een aantal sterrenkundige observa- toria en computer ontwikkelingsbureaus bezocht. Dit werd gevolgd door een tweede verblijf in Cambridge. Van 1953 tot 1959 was hij wetenschappelijk assistent aan het observatorium in Kopenhagen, en hij fungeerde ook als adviseur in de gebieden van assembleertalen en debughulpmiddelen voor het onafhankelijk computerlabora- torium Regnecentralen bij de ontwikkeling van de eerste deense computer Dask. Hij behaalde in 1957 de titel van doctor in de sterrenkunde.
In 1959 ging Dr. Naur werken voor Regnecentralen om zich te specialiseren op het vlak van hogere programmeertalen en hij werd nauw betrokken bij de inter- nationale ontwikkeling van Algol 60. Hij organiseerde the Algol Bulletin en werd  ́e ́en van de 13 internationale wetenschappers die het finale ontwerp van Algol 60 opstelden in het jaar 1960. Hij werd benoemd tot redacteur van het Report on the Algorithmic Language ALGOL 60 over deze programmeertaal.
Als lid van de ontwerp groep voor compilers van Regnecentralen, droeg Peter Naur toe tot het ontwerp van compilers voor Algol 60 en Cobol; compilers die geken- merkt werden door hun effici ̈ent gebruik van multipass technieken. Deze ervaringen leidden tot interesse voor de basisprincipes van dataverwerking, en in 1974 tot de publikatie van het boek Concise Survey of Computer Methods.
Meer recent heeft hij actief bijgedragen tot de studie van programma ontwikke- ling als een menselijke activiteit, met behoud van een zekere scepcis tegenover de stellingen over methodes en formalisatie die binnen dit gebied naar voor gebracht werden.
Vanaf het begin in 1960 is hij co-redacteur geweest van het noorse tijdschrift BIT. Vanaf de stichting in 1966 tot 1982 is hij ook president geweest van Dansk Selskab for Datalogi, en hij was co-redacteur van het verslag over het eerste congres over software engineering in 1968.
Hij is sinds 1969 professor aan The Institute of Datalogy van de Universiteit van Kopenhagen.
Hij is in 1963 beloond geweest met de G.A. Hagemann medaille, in 1966 met de Jens Rosenkjaer prijs, en in 1986 met de Computer Pioneer Award van de IEEE Computer Society.
112
(bron: http://www.naur.com/bibliography.html)
Voorbeeld 8.2.3 Het volgend voorbeeld produceert 1843000 mogelijke va- riaties op het woord viagra, die allemaal gebruikt kunnen worden om SPAM te ontdekken.
Figuur 8.3: Spam ontdekken
(These production rules yield 1,843,200 possible spellings. How Many Ways Can You Spell V1@gra? By Brian Hayes: American Scientist, July-August 2007) (http: // www. americanscientist. org/ template/ AssetDetail/ assetid/ 55592 )
Voorbeeld 8.2.4 Ook HTML is een contextvrije taal.
8.3 Ontwerp van contextvrije grammatica’s
Nu illustreren we enkele idee ̈en om contextvrije grammatica’s op te stellen.
Concatenatie van onafhankelijke talen
Beschouw de taal
L={anbncm :n,m∈N}, voortgebracht door de grammatica
G = ({S,N,C,a,b,c},{a,b,c},R,S), met als verzameling herschrijfregels:
R = {S → NC,N → aNb,N → ε,C → cC,C → ε}. 113
￼
We zien in deze taal dat het cm gedeelte in een zin uit L onafhanke- lijk is van het anbn gedeelte uit deze zin. Dit verklaart waarom er in de herschrijfregels voor deze taal een herschrijfregel is van de vorm
S → NC,
waarbij het rechterlid bestaat uit twee niet-terminalen die dan zelf later nog
apart optreden in de herschrijfregels
N → aNb,N → ε, C → cC, C → ε.
en
wordt voortgebracht door de grammatica
G = ({S,M,a,b},{a,b},R,S),
met als verzameling herschrijfregels:
R = {S → MS,S → ε,M → aMb,M → ε}.
Door de herschrijfregel S → MS, in combinatie met de herschrijfregel M → aMb, wordt het patroon an1bn1an2bn2 ···ankbnk voor alle k ≥ 0 gege- nereerd.
Merk op dat deze taal ook bekomen wordt door de kleene ster toe te passen op de taal {anbn : n ≥ 0}:
{an1bn1an2bn2 ···ankbnk : k ≥ 0 en ∀i(ni ≥ 0)} = {anbn : n ≥ 0}∗. Verschillend aantal a’s en b’s
De taal
L={anbm :n̸=m} wordt voortgebracht door de grammatica
G = (V = {a,b,S,A,B},Σ = {a,b},R,S), met R de verzameling van de volgende herschrijfregels:
• S→A(voormeera’sdanb’s) 114
Algemener voorbeeld
De taal
L = {an1bn1an2bn2 ···ankbnk : k ≥ 0 en ∀i(ni ≥ 0)}
• •
8.4
B → Bb
B → aBb (drie regels om meer b’s dan a’s te hebben)
Vereenvoudigen van contextvrije grammatica’s
• S→B(voormeerb’sdana’s)
• A→a
• A → aA
• A → aAb (drie regels om meer a’s dan b’s te hebben) •B→b
Beschouw de volgende grammatica
G = ({S,A,B,C,D,a,b},{a,b},R,S),
met R de verzameling van de volgende herschrijfregels: • S → AB|AC
• A → aAb|ε
• B → aA
• C → bCa
• D → AB
Hier vallen twee zaken op aan deze herschrijfregels:
• De niet-terminaal C is niet-productief, want er is geen enkele manier om via de herschrijfregels, startend bij het startsymbool S, met behulp van de niet-terminaal C, een zin af te leiden die enkel bestaat uit terminalen.
Hier steunen we op het belangrijk aspect binnen de definitie van de taal L(G) voortgebracht door een grammatica G: de zinnen van L(G) mogen enkel en alleen bestaan uit terminalen.
• De niet-terminaal D is onbereikbaar, want er is geen enkele manier om via de herschrijfregels, startend bij het startsymbool S, een zin af te leiden die de niet-terminaal D bevat.
115
Dit voorbeeld toont aan dat het interessant is om contextvrije gram- matica’s zo goed mogelijk op te stellen dat zij geen overtollige zaken, zoals niet-productieve en/of onbereikbare niet-terminalen, bevat.
We zullen nu twee algoritmes bespreken die niet-productieve en onbe- reikbare niet-terminalen zullen verwijderen uit grammatica’s.
Verwijderen van niet-productieve niet-terminalen
removeunproductive(G : CFG) =
1. G′ =G.
2. Markeer elk niet-terminaal symbool in G′ als niet-productief.
3. Markeer elk terminaal symbool in G′ als productief.
4. Tot een volledige controle gedaan werd zonder dat er nieuwe symbolen gemarkeerd werden, doe:
(a) VoorelkeregelX→αinRdoe:
Als elk symbool in α gemarkeerd werd als productief, en X is nog niet gemarkeerd als productief, markeer dan ook X als productief.
5. Verwijder van G′ elk niet-productief symbool.
6. Verwijder van G′ elke regel die een niet-productief symbool bevat.
7. Geef G′ terug.
Verwijderen van onbereikbare niet-terminalen
removeunreachable(G : CFG) =
1. G′ =G.
2. Markeer het startsymbool S in G′ als bereikbaar.
3. Markeer elk niet-terminaal symbool in G′ als onbereikbaar.
4. Tot een volledige controle gedaan werd zonder dat er nieuwe symbolen gemarkeerd werden, doe:
(a) Voor elke regel X → αAβ in R, met A ∈ V \ Σ, doe:
Als X gemarkeerd werd als bereikbaar, en de niet-terminaal A is nog niet gemarkeerd als bereikbaar, markeer dan ook de niet- terminaal A als bereikbaar.
5. Verwijder van G′ elk onbereikbaar symbool.
6. Verwijder van G′ elke regel met een onbereikbaar symbool in het lin- kergedeelte.
116
7. Geef G′ terug.
Met deze twee algoritmes kunnen alle overtollige symbolen en herschrijf- regels verwijderd worden als eerst removeunproductive, en dan daarna re- moveunreachable toegepast wordt.
Voorbeeld 8.4.1 Beschouw de grammatica G met de herschrijfregels:
• S → AB •S→A •S→a
Hier is de niet-terminaal B niet-productief. Dus na het toepassen van de twee algoritmes removeunproductive en removeunreachable, vereenvoudigen de herschrijfregels tot:
•S→A •S→a
8.5 Structuur binnen contextvrije grammatica’s
Laten we even terugkeren naar Voorbeeld 8.1.12.
Voorbeeld 8.5.1 De taal L van de rekenkundige uitdrukkingen is bepaald door de grammatica G = (V, Σ, R, E), met
• V = {+,∗,(,),id,E},
• Σ = {+,∗,(,),id},
• R={E→E+E,E→E∗E,E→(E),E→id}.
Zoals reeds opgemerkt na Voorbeeld 8.1.12 zien deze herschrijfregels voor het opstellen van rekenkundige uitdrukkingen er correct uit. Maar zij zijn echter nog iets te zwak om in de praktijk in programmeertalen toegepast te worden. We zullen zien dat er nog dubbelzinnigheden in de rekenkundige uitdrukkingen door de mazen van het net glippen.
We verduidelijken dit als volgt.
Beschouw de volgende graaf die een afleiding binnen de grammatica G van de rekenkundige uitdrukkingen voorstelt.
Deze graaf verduidelijkt dat de afleidingsregels leidden tot de uitdrukking 3+5∗7.
117
￼￼￼￼￼￼￼￼￼￼￼￼￼Figuur 8.4: Afleiding van een rekenkundige uitdrukking
Maar stel dat dit nu uitgerekend dient te worden. We weten dat de vermenigvuldiging ∗ eerst uitgevoerd dient te worden, en dat het correcte resultaat voor de berekening 3 + 5 ∗ 7 gelijk is aan 38.
Maar uit de formele uitdrukking 3 + 5 ∗ 7 kan niet afgeleid worden, door een computer die dit moet uitrekenen, dat de vermenigvuldiging eerst uitgevoerd dient te worden.
Dit komt omdat deze herschrijfregels nog te weinig structuur hebben. Zij dienen verfijnd te worden, zodat het verschil in prioriteit van de wiskundige bewerkingen duidelijk wordt.
Dit heeft geleid tot het invoeren van het begrip parse tree van een gram- matica.
Definitie 8.5.2 Een parse tree, afgeleid door een grammatica G = (V, Σ, R, S), is een boom waarin:
• De wortel heeft het startsymbool S van G als label.
• Elk blad van de boom heeft een element uit Σ ∪ {ε}, dus een terminaal
of de nulreeks ε, als label.
• Elke andere knoop heeft een niet-terminaal als label, en
• als m een knoop is die geen blad is in de boom, die de niet-terminaal X als label heeft, en als de kinderen van de knoop m gelabeld zijn door x1,...,xn, dan moet de herschrijfregel X → x1 ···xn behoren tot de verzameling van de herschrijfregels R.
Het interessante aan parse trees is dat die het toepassen van de herschrijf- regels iets fijner beschrijven, dan de herschrijfregels zelf. Dit zal blijken uit de voorbeelden, maar eerst geven we de benodigde definities.
118
Definitie 8.5.3 De zwakke generatieve capaciteit van een grammatica G is de verzameling L(G) van de zinnen voortgebracht door de grammatica G.
De sterke generatieve capaciteit van een grammatica G is de verzameling van de parse trees voortgebracht door de grammatica G.
Waar ligt het verschil in de zwakke en de sterke generatieve capaciteit van een grammatica G? We zien dit in de volgende figuur.
Beschouw de grammatica
R = {E → E + E, E → E ∗ E, E → (E), E → id, id → 2|3|5}, en bekijk nu Figuur 8.5.
Figuur 8.5: Verschil tussen zwakke en sterke generatieve capaciteit van een grammatica
Vanuit het standpunt van de herschrijfregels leiden beide parse trees tot dezelfde zin 2 + 3 ∗ 5 uit de taal van de rekenkundige uitdrukkingen. Maar de parse trees leggen wel verschillende accenten. De linkse figuur toont dat de betekenis van de linkse afgeleide zin gelijk is aan 2 + (3 ∗ 5), en de rechtse figuur toont aan dat de betekenis van de rechtse afgeleide zin gelijk is aan (2+3)∗5.
Hier kan dus, via deze parse trees, de prioriteit van de ene wiskundige bewerking ten opzichte van de andere wiskundige bewerking vastgelegd wor- den. Op deze manier kan dus, bijvoorbeeld een computer, exact vaststellen hoe een rekenkundige bewerking correct uitgerekend dient te worden.
Formeel gezien komt het probleem dat een zin uit de taal L(G) van een grammatica G voortgebracht kan worden via twee verschillende parse trees overeen met de dubbelzinnigheid van de grammatica G.
Definitie 8.5.4 Een grammatica G wordt dubbelzinnig genoemd als er een zin in de taal L(G) van G bestaat die bekomen kan worden via twee verschil- lende parse trees.
119
￼
￼Figuur 8.6: Dubbelzinnige grammatica
Het is natuurlijk best om dubbelzinnigheid in grammatica’s te vermijden. Maar kan dit altijd vermeden worden? Zelfs in heel eenvoudige grammatica’s zitten er soms al dubbelzinnigheden.
Beschouw bijvoorbeeld de grammatica van de gebalanceerde haakjes uit Voorbeeld 8.1.4 met als verzameling herschrijfregels
R = {S → ε,S → SS,S → (S)},
en de twee bijhorende parse trees uit Figuur 8.6 die allebei leiden tot de zin (())() uit de taal L(G) van deze grammatica.
Het is zelfs zo dat er talen bestaan die de eigenschap hebben dat al hun grammatica’s dubbelzinnig zijn. We noemen dergelijke talen inherent dubbelzinnig.
Definitie 8.5.5 Een taal L noemen we inherent dubbelzinnig als elke gram- matica voor deze taal dubbelzinnig is.
Voorbeeld 8.5.6 De taal
L={anbncm :n,m≥0}∪{anbmcm :n,m≥0}
is inherent dubbelzinnig.
We tonen dit aan via een voorbeeld van  ́e ́en van zijn grammatica’s:
• S → S1|S2
• S1 → S1c|A
• A → aAb|ε (deze twee herschrijfregels genereren alle reeksen in {anbncm : n,m ≥ 0})
• S2 → aS2|B
• B → bBc|ε (deze twee herschrijfregels genereren alle reeksen in {anbmcm : n,m ≥ 0})
120
Maar beschouw nu de reeks anbncn uit de taal L. Deze reeks anbncn kan zowel via de eerste drie herschrijfregels, als via de eerste en de twee laatste herschrijfregels afgeleid worden. Er is hier dus altijd dubbelzinnigheid.
Deze taal
L={anbncm :n,m≥0}∪{anbmcm :n,m≥0} zal op het einde van Hoofdstuk 11 nog eens besproken worden.
Het probleem van de dubbelzinnigheid van grammatica’s is een heel moeilijk probleem. Om een idee hiervan te geven, vermelden we de vol- gende stellingen.
Stelling 8.2 De volgende twee problemen zijn onbeslisbaar:
• Gegeven een contextvrije grammatica G, is deze grammatica G dubbel-
zinnig?
• Gegeven een contextvrije taal L, is deze taal L inherent dubbelzinnig?
Het feit dat deze twee problemen onbeslisbaar zijn, betekent dat er geen algoritme voor het oplossen van deze twee problemen gegeven kan worden. Dit is dus slecht nieuws, maar gelukkig kunnen er wel enkele methodes toegepast worden die de dubbelzinnigheid in grammatica’s soms kunnen reduceren.
Hier bespreken we enkele van deze methodes:
Verwijderen van een ε-regel
Het volgend voorbeeld toont aan dat een ε-regel, dus een regel met enkel de nulreeks ε aan de rechterkant, veel dubbelzinnigheden kan introduceren in een grammatica.
Beschouw opnieuw de grammatica van de gebalanceerde haakjes (Voor- beeld 8.1.4) met als verzameling herschrijfregels
R = {S → ε,S → SS,S → (S)},
en de twee bijhorende parse trees die allebei leiden tot de zin (())() uit de taal L(G) van deze grammatica (Figuur 8.6).
De ε-regel, in combinatie met de tweede regel, impliceert dat een wille- keurig aantal keer het startsymbool ingevoerd kan worden en weer wegge- daan kan worden, om uiteindelijk op het einde dezelfde zin uit te komen.
We bespreken nu hoe deze ε-regels weggedaan kunnen worden. Hier- voor steunen we op de theorie van de nullable variabelen (nullable niet- terminalen).
121
Definitie 8.5.7 Een variabele X is nullable als en slechts als er ofwel:
1. een ε-regel X → ε is,
2. een herschrijfregel X → PQR··· is, met enkel nullable variabelen P, Q, R, . . ., in het rechtergedeelte.
De verzameling N van de nullable variabelen kan via het volgend algo- ritme berekend worden:
1. Stel de verzameling N gelijk aan de verzameling variabelen X die optreden in een ε-regel X → ε.
2. Herhaal tot er een volledige doorgang gemaakt is door alle herschrijf- regels zonder dat er variabelen toegevoegd worden aan de verzameling N:
(a) Evalueer alle variabelen niet in N met betrekking tot de her- schrijfregels 2. uit Definitie 8.5.7.
(b) Als er een variabele voldoet aan een herschrijfregel 2. uit Definitie 8.5.7, en deze variabele behoort nog niet tot de verzameling N, voeg dan deze variabele aan de verzameling N toe.
Nu dat het algoritme opgesteld is om de nullable variabelen binnen een grammatica G te vinden, kan het algoritme removeEps opgesteld worden om de ε-regels te verwijderen uit de grammatica G.
We geven eerst een voorbereidende definitie.
Definitie 8.5.8 Een herschrijfregel wordt aanpasbaar genoemd, als deze herschrijfregel van de vorm P → αQβ is, voor een zekere nullable varia- bele Q.
removeEps(G: CFG) =
1. Stel G′ = G.
2. Bepaal de verzameling N van de nullable variabelen in G′.
3. Herhaal totdat de grammatica G′ geen aanpasbare herschrijfregels meer heeft die niet behandeld geweest zijn:
Gegeven een (aanpasbare) herschrijfregel P → αQβ, met Q ∈ N, voeg de herschrijfregel P → αβ toe aan de grammatica G′ als αβ ̸= ε en P ̸= αβ, tenzij deze herschrijfregel P → αβ al aanwezig is.
4. Schrap uit de grammatica G′ alle herschrijfregels van de vorm X → ε.
5. Geef de grammatica G′ terug.
122
Er geldt nu dat:
BEWIJS: Bewijs dit als oefening. P
Op dit ogenblik hebben we een algoritme dat een grammatica G′ geeft zodat L(G′) = L(G) \ {ε}.
Maar wat als ε ∈ L(G)?
We lossen dit nu op via het volgend algoritme. Zij S het startsymbool van de grammatica G.
atmostoneEps(G: CFG) = 1. G′′ = removeEps(G).
2. Als S nullable is, dan
(a) Cre ̈eer in G′′ een nieuw startsymbool S∗.
(b) Voeg aan de herschrijfregels van G′′ de twee regels
S∗ → ε en S∗ → S 3. Geef de grammatica G′′ terug.
Via de nieuwe herschrijfregels S∗ → ε en S∗ → S kan het nieuwe start- symbool S∗ enkel herschreven worden tot de nulreeks ε via de herschrijfregel S∗ → ε, en heeft deze herschrijfregel geen invloed op andere afleidingen. Er geldt nu dat
L(G′′) = L(G).
Voorbeeld 8.5.9 Bekijken we opnieuw de grammatica van de gebalanceerde
haakjes. Origineel waren de herschrijfregels
R = {S → ε,S → SS,S → (S)}.
Na het verwijderen van de ε-regel bekomen we de herschrijfregels
{S∗ →ε,S∗ →S,S→SS,S→(S),S→()}.
Maar met het elimineren van de ε-regels is nog niet alle dubbelzinnigheid
ge ̈elimineerd. In de grammatica
{S∗ →ε,S∗ →S,S→SS,S→(S),S→()}
zitten er nog veel dubbelzinnigheden, en hier komt de dubbelzinnigheid niet van de ene ε-regel. We zien dit in Figuur 8.7.
123
toe.
L(G′) = L(G) \ {ε}.
￼￼￼￼Figuur 8.7: Nog altijd dubbelzinnigheid
De dubbelzinnigheid komt voor uit het symmetrisch karakter van het rechtergedeelte van de herschrijfregel S → SS. Uiteindelijk zul je elk voor- komen van het startsymbool S eens vervangen door de haakjes (), maar de volgorde waarin je de symbolen S vervangt door () is niet altijd uniek.
Om deze redenen, om geen dubbelzinnigheid te hebben omwille van sym- metrische herschrijfregels, is het goed om de symmetrie in herschrijfregels te breken, zodat zinnen op een unieke manier uit de herschrijfregels volgen.
Een concrete oplossing voor het breken van de symmetrie in Voorbeeld 8.5.9 is als volgt.
Vervang in Voorbeeld 8.5.9 de herschrijfregel S → SS door de twee herschrijfregels
S → SS1
S → S1S
Op deze manier wordt de volgende ondubbelzinnige grammatica voor de taal van de gebalanceerde haakjes bekomen: de grammatica met als herschrijfregels
Deze regels leiden nu op een unieke manier van het startsymbool S∗ tot de gebalanceerde reeks haakjes ()()(), zoals voorgesteld in Figuur 8.8.
We lossen nu de dubbelzinnigheid op in de grammatica van de reken- kundige uitdrukkingen uit Voorbeeld 8.1.12.
De voorgestelde rekenregels waren: E→E+E
E→E∗E 124
S∗ → ε S∗ → S
￼￼￼￼￼￼￼￼￼S → SS1 S → S1 S1 → (S) S1 → ()
￼￼￼￼￼
￼￼￼￼￼Figuur 8.8: Geen dubbelzinnigheid meer
E → (E) E → id
Maar deze rekenregels laten nog teveel problemen toe.
Probleem 1: Associativiteit
Het eerste probleem is dat deze rekenregels niet specifi ̈eren in welke volg- orde je producten a∗b∗c en sommen a+b+c berekent. Als (a∗b)∗c of als a∗(b∗c), en als (a+b)+c of als a+(b+c). We zien dit uitgedrukt in Figuur 8.9 in de twee parse trees voor de uitdrukking id ∗ id ∗ id, wat dus aantoont dat deze grammatica dubbelzinnig is.
Probleem 2: Prioriteit
Het tweede probleem is dat deze rekenregels niet de prioriteit van be- werkingen ten opzichte van andere bewerkingen vastleggen. We zien dit in Figuur 8.10 waar twee parse trees voor de uitdrukking id ∗ id + id getoond worden.
We weten dat de vermenigvuldiging prioriteit heeft ten opzichte van de optelling, maar we zien dit niet als we enkel rekening houden met de herschrijfregels. Bovendien, wat als de optelling in id ∗ id + id prioriteit had ten opzichte van de vermenigvuldiging, dan hadden er haakjes moeten staan. Er had dan namelijk id ∗ (id + id) moeten staan.
De volgende herschrijfregels lossen deze dubbelzinnigheden op. E→E+T
125
￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼Figuur 8.9: Dubbelzinnigheid voor id ∗ id ∗ id
￼Figuur 8.10: Dubbelzinnigheid voor id ∗ id + id
126
￼Figuur 8.11: Unieke afleiding van id + (id ∗ id)
E→T T→T∗F T→F F → (E) F → id
In deze herschrijfregels gebruiken we de niet-terminaal T, die voor een term binnen een som staat, en de niet-terminaal F, die voor een factor binnen een product staat. Ook worden er haakjes rond het startsymbool E in de herschrijfregel F → (E) geplaatst, zodat je prioriteit kan introduceren in de bewerkingen.
Op deze manier kan de uitdrukking id + id ∗ id = id + (id ∗ id) enkel via de parse tree in Figuur 8.11, dus enkel volgens de afleiding beschreven door deze parse tree, bekomen worden.
8.6 Informatica toepassingen 8.6.1 Booleaanse logica
De taal van de Booleaanse logica is contextvrij, maar niet regulier.
De Booleaanse logica kan gedefinieerd worden via de volgende context-
vrije grammatica G = (V, Σ, R, E), met
• V = {∧,∨,¬,⇒,(,),id,E,E1,E2,E3,E4}, • Σ = {∧,∨,¬,⇒,(,),id},
127
• R = {E → E ⇒ E1,E → E1,E1 → E1 ∨E2,E1 → E2,E2 → E2 ∧ E3,E2 → E3,E3 → ¬E3,E3 → E4,E4 → (E),E4 → id}.
Bemerk ook hoe in deze herschrijfregels er expliciet voor gezorgd wordt dat er geen symmetrie in de herschrijfregels te vinden is, zie bijvoorbeeld de herschrijfregel E1 → E1 ∨ E2, en er ook een herschrijfregel E4 → (E) is voor het introduceren van haakjes om prioriteit binnen de bewerkingen te kunnen vastleggen, en dus Booleaanse zinnen semantisch correct opgesteld te krijgen.
Nu tonen we aan dat de Booleaanse logica geen reguliere taal is. Dit kan aangetoond worden door gebruik te maken van het pompend lemma (zie Stelling 6.6).
Beschouw namelijk de parameter k uit de beschrijving van het pompend lemma, en pas de techniek van het pompend lemma toe op de zin w = ((· · · ((id)) · · · )), met precies k haakjes ”(” en k haakjes ”)”.
8.6.2 IF THEN ELSE instructies
Ook bij het opstellen van de herschrijfregels voor een IF THEN ELSE in- structie dient er opgelet te worden.
Stel dat de IF THEN ELSE instructie gedefinieerd wordt door de her- schrijfregels
<stmt>::= if <cond> then <stmt>
<stmt>::= if <cond> then <stmt> else <stmt>
Dan kan de volgende IF THEN ELSE instructie afgeleid worden. if cond1 then if cond2 then st1 else st2,
maar hoe moet dit nu geinterpreteerd worden? Als
if cond1 then (if cond2 then st1 else st2)
of als
if cond1 then (if cond2 then st1) else st2 Er zit opnieuw dubbelzinnigheid in deze herschrijfregels.
De volgende herschrijfregels uit JAVA lossen dit op.
<Statement> ::= <IfThenStatement> |  <IfThenElseStatement> |
             <IfThenElseStatementNoShortIf>
<StatementNoShortIf> ::= <block> |
                <IfThenElseStatementNoShortIf> | ...
<IfThenStatement> ::= if ( <Expression> )  <Statement>
128
￼￼￼￼￼￼Figuur 8.12: ShortIf en NoShortIf in JAVA
<IfThenElseStatement> ::= if ( <Expression> )
                 <StatementNoShortIf> else <Statement>
<IfThenElseStatementNoShortIf> ::=
        if ( <Expression> ) <StatementNoShortIf>
            else <StatementNoShortIf>
Hier wordt er dus expliciet een onderscheid gemaakt tussen een ShortIf, een if-instructie zonder een else-instructie, en een NoShortIf, een if-instructie met een else-instructie.
8.6.3 Welke betekenis?
Ook in gesproken en geschreven taal kunnen dubbelzinnige zinnen geformu- leerd worden.
Wat is de betekenis van de volgende zin?
Chris schoot de beer met het geweer.
Dubbelzinnigheden vinden we ook terug in de griekse mythologie bij uitspraken van het orakel van Delphi.
Zo kreeg een veldheer eens de volgende zin toen hij voor een belangrijke veldslag naar het orakel van Delphi ging om te vragen of hij deze veldslag ging winnen:
U zal de veldslag winnen niet verliezen.
Wat heeft het orakel van Delphi verteld tegen deze veldheer? Zal volgens het orakel van Delphi deze veldheer de veldslag winnen?
129
Hoofdstuk 9 Normale vormen
9.1 Inleiding
Ook bij de herschrijfregels van grammatica’s kunnen zogenaamde normale vormen gedefinieerd worden.
Normale vormen zijn een soort van standaardvormen die om een be- paalde reden belangrijk zijn. Zij kunnen belangrijk zijn omdat zij eenvoudig zijn, of omdat zij geschikt zijn voor het eenvoudig aantonen van bepaalde eigenschappen, of omdat zij handig zijn om op een eenvoudige manier te implementeren binnen een concrete toepassing.
Een formelere beschrijving van normale vormen is als volgt:
Een normale vorm F voor een verzameling C van objecten is een vorm, dwz. een verzameling van syntactisch geldige objecten, met de volgende twee eigenschappen:
• Voor elk element c uit de verzameling C, op een mogelijk eindig aantal uitzonderingen na, is er een element f in F zodat het element f equiva- lent is met het element c met betrekking tot een bepaalde verzameling taken.
• De vorm F is eenvoudiger dan de originele vorm waarin de elementen uit de verzameling C geschreven zijn.
Met eenvoudiger bedoelen we dat er een aantal taken eenvoudiger uit te voeren zijn op de elementen van F , dan moesten ze uitgevoerd worden op de elementen van C.
We bespreken nu in dit hoofdstuk twee normale vormen voor een con- textvrije grammatica: de Chomsky normale vorm en de Greibach normale vorm.
130
9.2 Chomsky normale en Greibach normale vorm voor contextvrije grammatica’s
Figuur 9.1: Noam Chomsky
Noam Chomsky werd in 1928 geboren in Philadelphia. Sinds 1955 werkt hij aan het Massachusetts Institute of Technology en hij heeft een theorie van generatieve grammatica’s ontwikkeld die een revolutie teweeg gebracht heeft in de wetenschappe- lijke studie van talen. Hij heeft zijn eerste abstracte analyse van talen uiteen gezet in zijn doctoraatsproefschrift (1955) en in Syntactic Structures (1957). In plaats van te starten met minimale geluiden, startte Chomsky van de rudimentaire of pri- mitieve zin. Startend van deze basis ontwikkelde hij het argument dat ontelbaar vele syntactische combinaties gegenereerd kunnen worden door middel van een complexe reeks van regels. Volgens de generatieve grammatica’s stemt elke verstaanbare zin in een specifieke taal niet enkel overeen met grammaticale regels specifiek voor deze taal, maar stemt deze ook overeen met een universele grammatica die in alle talen aanwezig is, en die correspondeert met een aangeboren capaciteit van het mense- lijk brein om talen te leren. Chomsky en andere taalkundigen, die op deze idee ̈en gewerkt hebben, hebben generatieve regels geformuleerd die een zin met een gege- ven grammaticale structuur (b.v. John ziet An) omzetten in een zin met een andere grammaticale structuur, maar met essentieel dezelfde betekenis (b.v. An werd gezien door John).
Generatieve taalkundigen zijn heel invloedrijk geweest in de taalpsychologie, in het bijzonder in de studie van hoe kinderen zich een taal eigen maken.
Als een productief schrijver was Chomsky een vroege en uitgesproken criticus over de betrokkenheid van de V.S. in de vietnamese oorlog, en hij heeft uitgebreid geschreven over vele politieke zaken. Zijn belangrijkste taalkundige werken, na Syn- tactic Structures, zijn o.a. Current Issues in Linguistic Theory (1964), The Sound Pattern of English (co-auteur Morris Halle) (1968), Language and Mind (1972), Studies on Semantics in Generative Grammar (1972), en Knowledge of Language (1986). Tot zijn politieke werken behoren American Power and the New Mandarins
131
￼
(1969), Peace in the Middle East? (1974), en Some Concepts and Consequences of the Theory of Government and Binding (1982).
(bron: http://www.encyclopedia.com/html/c/chomsky.asp)
Definitie 9.2.1 De Chomsky normale vorm voor een contextvrije gramma- tica G = (V, Σ, R, S) is een verzameling herschrijfregels voor deze context- vrije grammatica, waarin alle herschrijfregels  ́e ́en van de volgende gedaantes heeft:
• X → a, met a ∈ Σ, of
• X → BC, met B, C ∈ V \ Σ.
Voordelen aan de Chomsky normale vorm van de herschrijfregels zijn:
• De parse bomen zijn binaire bomen.
• De lengte |w| van een zin w uit de taal L(G) van deze grammatica is precies gekend.
Definitie 9.2.2 De Greibach normale vorm voor een contextvrije gramma- tica G = (V, Σ, R, S) is een verzameling herschrijfregels voor deze context- vrije grammatica, waarin alle herschrijfregels van de volgende gedaante zijn:
• X → aβ, met a ∈ Σ en met β ∈ (V \ Σ)∗.
Voordelen aan de Greibach normale vorm van de herschrijfregels zijn:
• Elke afleiding van een zin s uit de taal L(G) van deze grammatica G vereist precies |s| afzonderlijke afleidingen.
• Als de herschrijfregels van een contextvrije grammatica G in Greibach normale vorm geschreven zijn, dan kunnen deze herschrijfregels gemak- kelijk omgezet worden naar de corresponderende stapelautomaten, die geen ε-transities bevatten. Dit is heel interessant omdat dergelijke stapelautomaten zeker stoppen.
Zo zal voor de oplossing van  ́e ́en van de vragen in Sectie 12.2 de Grei- bach normale vorm van contextvrije grammatica’s gebruikt worden.
Na het invoeren van deze twee definities, tonen we nu aan dat deze normale vormen effectief bestaan voor contextvrije grammatica’s. We geven het bewijs voor de Chomsky normale vorm.
Stelling 9.1 Zij G een contextvrije grammatica, dan bestaat er een equiva- lente Chomsky normale vorm GC voor deze grammatica G zodat
L(GC ) = L(G) \ {ε}. 132
Stelling 9.2 Zij G een contextvrije grammatica, dan bestaat er een equiva- lente Greibach normale vorm GG voor deze grammatica G zodat
L(GG) = L(G) \ {ε}.
Bij het converteren van de herschrijfregels naar een normale vorm ge-
bruiken we de volgende stelling.
Stelling 9.3 Zij G een grammatica die de herschrijfregels: X → αY β
en bevat.
Y → γ1|γ2|···|γn
Vervang dan de herschrijfregel X → αY β door de herschrijfregels X → αγ1β,X → αγ2β,...,X → αγnβ,
dan wordt een nieuwe grammatica G′ bekomen die equivalent is aan de ori- ginele grammatica G.
Conversie naar Chomsky normale vorm
De volgende stappen worden ondernomen om de herschrijfregels van een contextvrije grammatica G om te zetten naar de Chomsky normale vorm.
1. Verwijder alle ε-regels, door het algoritme removeEps (Sectie 8.5).
2. Verwijder alle 1-producties, dus regels van de vorm A → B.
3. Verwijder alle herschrijfregels waarvan het rechtergedeelte een lengte groter dan 1 heeft, en ook een terminaal bevatten.
Bijvoorbeeld, verwijder de regels:
A → aB of A → BaC.
4. Verwijder alle herschrijfregels waarvan het rechtergedeelte een lengte groter dan 2 heeft.
Bijvoorbeeld, verwijder de regel:
A → BCDE.
We verduidelijken nu deze stappen.
Stap 1: Verwijder alle ε-regels
Dit wordt verwezenlijkt door het algoritme removeEps (Sectie 8.5).
133
• Als er een herschrijfregel P → αQβ is en de niet-terminaal Q is nulla- ble, dan wordt in feite de herschrijfregel P → αβ toegevoegd.
• Verwijder alle herschrijfregels Q → ε.
Stap 2: Verwijder alle 1-producties
Definitie 9.2.3 Een 1-productie is een herschrijfregel van de vorm A → B,
met A, B ∈ V \ Σ.
We verwijderen nu de 1-producties via het algoritme removeUnits.
removeUnits(G) =
1. Stel G′ = G.
2. Herhaal tot er geen 1-producties in G′ overblijven:
(a) Kies een 1-productie X → Y .
(b) Verwijder deze 1-productie uit G′.
(c) Beschouw enkel de regels die nog overblijven.
Voor elke herschrijfregel Y → β, met β ∈ V∗, doe: voeg de
herschrijfregel X → β toe aan G′, tenzij dit een herschrijfregel is die al een keer verwijderd werd.
3. Keer G′ terug.
De nieuwe grammatica G′ is equivalent aan de originele grammatica G.
Merk op dat na deze twee stappen, het verwijderen van de ε-producties en de 1-producties, alle herschrijfregels wiens rechtergedeelte lengte 1 heeft, in Chomsky normale vorm zijn.
Voorbeeld 9.2.4 We illustreren nu de eerste twee stappen uit het algo- ritme. Links staan de originele herschrijfregels uit de contextvrije gramma- tica G, en rechts staan de geconverteerde herschrijfregels uit de grammatica G′. Merk op dat er links vier 1-producties staan: X → A,A → B,Y → T,T →Y.
￼Herschrijfregels van G
Herschrijfregels van G′
￼￼￼S → XY X→A A → B|a B→b Y→T
T → Y |c
￼￼￼￼￼￼￼S → XY A → a|b B→b T→c X → a|b Y→c
￼￼￼￼￼￼￼￼￼￼￼￼￼134
Stap 3: Verwijderen van mixed herschrijfregels
Nu geven we het algoritme removeMixed om herschrijfregels te conver- teren die in het rechtergedeelte meer dan  ́e ́en symbool staan hebben, waar- onder minstens  ́e ́en terminaal.
removeMixed(G) =
1. Stel G′ = G.
2. Cre ̈eer een nieuw niet-terminaal symbool Ta voor elk terminaal sym- bool a in Σ.
3. Wijzig elke herschrijfregel waarvan het rechtergedeelte meer dan  ́e ́en symbool bevat, en minstens  ́e ́en terminaal bevat, door elke terminaal a die optreedt in het rechtergedeelte te vervangen door zijn correspon- derende niet-terminaal Ta.
4. VoegaandegrammaticaG′,voorelkenieuwgedefinieerdeniet-terminaal Ta, de herschrijfregel Ta → a toe.
5. Geef de grammatica G′ terug.
De nieuwe grammatica G′ is equivalent aan de originele grammatica G.
Voorbeeld 9.2.5 We illustreren nu het algoritme. Links staan de originele herschrijfregels uit de contextvrije grammatica G, en rechts staan de gecon- verteerde herschrijfregels uit de grammatica G′.
Stap 4: Verwijderen van lange regels
Nu geven we het algoritme removeLong om lange regels te verwijderen. Dit zijn herschrijfregels waarvan het rechtergedeelte bestaat uit meer dan twee symbolen, die allemaal niet-terminalen zijn.
removeLong(G) =
1. Stel G′ = G.
2. Voor elke herschrijfregel r van de vorm:
A → N1N2 ···Nn,n > 2,
cre ̈eer nieuwe niet-terminalen M2, M3, . . . , Mn−1. 135
￼Herschrijfregels van G
Herschrijfregels van G′
￼￼￼A→a
A → aB A → BaC A → BbC
￼￼￼￼￼￼￼A→a
A → TaB A → BTaC A → BTbC Ta → a
Tb → b
￼￼￼￼￼￼￼￼￼￼￼￼￼
3. Vervang de herschrijfregel r door de herschrijfregel A → N1M2.
4. Voeg de herschrijfregels
M2 → N2M3,
M3 → N3M4, ...,
Mn−1 → Nn−1Nn
toe.
5. Geef de grammatica G′ terug.
De nieuwe grammatica G′ is equivalent aan de originele grammatica G. Voorbeeld 9.2.6 We passen nu de vier algoritmes toe op een grammatica
G, met als herschrijfregels:
S → aACa A → B|a B → C|c C → cC|ε
Stap 1: removeEps geeft de volgende herschrijfregels terug:
S → aACa|aAa|aCa|aa A → B|a
B → C|c
C → cC|c
Stap 2: removeUnits.
1. Verwijder A→B en voeg A→C|c toe.
2. Verwijder B → C en voeg B → cC toe (B → c staat er al). 3. Verwijder A→C en voeg A→cC toe (A→c staat er al).
136
removeUnits geeft de volgende herschrijfregels terug:
S → aACa|aAa|aCa|aa A → a|c|cC
B → c|cC
C → cC|c
Stap 3: removeMixed geeft de volgende herschrijfregels terug:
S → TaACTa|TaATa|TaCTa|TaTa A → a|c|TcC
B → c|TcC
C → TcC|c
Ta → a
Tc → c
Stap 4: Tenslotte passen we removeLong toe die de volgende herschrijf- regels teruggeeft:
S → TaS1,S → TaS3,S → TaS4,S → TaTa S1 → AS2,S3 → ATa,S4 → CTa
S2 → CTa
A → a|c|TcC
B → c|TcC
C → TcC|c
Ta → a, Tc → c
Nu zijn de herschrijfregels in de Chomsky normale vorm.
Opmerking 9.2.7 De conversie van de herschrijfregels van een context- vrije grammatica naar de Chomsky normale vorm verandert niet de zwakke generatieve capaciteit van de grammatica, maar mogelijks wel de sterke ge- neratieve capaciteit van de grammatica.
137
Voorbeeld 9.2.8 Hierna volgt een tweede voorbeeld van een contextvrije grammatica die naar Chomsky normale vorm geconverteerd wordt.
Origineel bestaat de grammatica G uit de regels:
De conversie naar de Chomsky normale vorm leidt tot de volgende her- schrijfregels:
￼E→E+E E → (E)
E → id
￼￼￼E → EE′ E′ →PE E → LE′ E′′ → ER
￼￼￼￼￼￼E → id L→( R →) P→+
￼￼￼￼￼￼￼￼138
Hoofdstuk 10
Niet-deterministische stapelautomaten
10.1 Inleiding
Nu bespreken we de automaat die de contextvrije talen kan aanvaarden. Dit zal de niet-deterministische stapelautomaat zijn.
Deze automaat kan complexere talen aanvaarden dan de eindige determi- nistische automaten. De niet-deterministische stapelautomaat heeft name- lijk een geheugen, een stapel, die in principe een onbeperkt groot geheugen is, maar de toegang ertoe is wel beperkt in zijn mogelijkheden.
De naam van de machine zegt ook al dat zij niet-deterministisch is.
Verschillend van bij de eindige deterministische automaten waar de ein- dige niet-deterministische automaten equivalent zijn aan de eindige determi- nistische automaten, geldt dit niet meer bij de stapelautomaten. Determinis- tische stapelautomaten kunnen niet altijd hetzelfde als niet-deterministische stapelautomaten.
Het feit dat met de contextvrije talen niet-deterministische stapelauto- maten corresponderen, zal een aantal zaken complexer maken, en moeilijker om op te lossen. Daarnaast impliceert dit feit ook dat een grotere voor- zichtigheid geboden is bij het correct formuleren van problemen en hun oplossingen.
10.2 Definities
We beginnen met het defini ̈eren van een niet-deterministische stapelauto- maat.
Definitie 10.2.1 Een niet-deterministische stapelautomaat (PDA) M is een 6-tal M = (K,Σ,Γ,∆,s,A), met:
• K de eindige verzameling toestanden, 139
￼Figuur 10.1: Een stapel containers: het LIFO-principe in de praktijk
Figuur 10.2: Stapelautomaten in de haven van Hamburg
140
￼
• Σ het inputalfabet,
• Γ het stapelalfabet,
• s ∈ K de starttoestand,
• A ⊆ K de verzameling van de aanvaardende toestanden, en
• ∆ de transitierelatie. Het is een eindige deelverzameling van het pro- duct:
(K ×(Σ∪{ε})×Γ∗)×(K ×Γ∗).
Dit betekent dat een transitie een 5-tal (q, w, γ, q′, γ′) = ((q, w, γ), (q′, γ′))
is, met:
• q de toestand waarin de PDA M zich op dat ogenblik bevindt,
• w is het inputsymbool, of de nulreeks ε, die verwerkt wordt door de PDA M,
• γ is de reeks symbolen die van de top van de stapel gehaald dienen te worden (pop),
• q′ is de toestand waarnaar de PDA M zich dient te begeven, en
• γ′ is de reeks symbolen die op de top van de stapel geplaatst dienen
te worden (push).
Definitie 10.2.2 Een configuratie van de PDA M is een element (q, w, γ) van het product K × Σ∗ × Γ∗.
De initi ̈ele configuratie van de PDA M is het 3-tal (s,w,ε), met s de starttoestand van de PDA M, met w de input die verwerkt dient te worden door de PDA M, en met de stapel leeg, dus met de nulreeks ε op de stapel.
Het voorbeeld van de initi ̈ele configuratie toont al aan dat de configuratie (q,w,γ) aanduidt in welke toestand q de PDA M is, welke input w er nog dient verwerkt te worden, en welke reeks symbolen γ er opgeslagen is op de stapel van de PDA M.
De stapel van een PDA M is het geheugen van deze PDA M, en werkt volgens het LIFO-principe (Last In First Out). We zullen de stapel in vele gevallen grafisch voorstellen.
Als de stapel cab bevat, dan noteren we dat zoals in Figuur 10.3.
Belangrijk hier is dat het linkse karakter c zich bovenaan de stapel be- vindt, en het rechtse karakter a zich onderaan de stapel bevindt. Dus c is het laatst toegevoegd op de stapel.
Als we de reeks c1 · · · cn pushen op de stapel, dan ziet de stapel er nadien uit zoals op Figuur 10.4, en dus bevat de stapel de reeks c1 · · · cncab.
Nu modelleren we de werking van een PDA M. 141
￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼Figuur 10.3: Stapel die cab bevat
Figuur 10.4: Stapel die c1 · · · cncab bevat Definitie10.2.3 Zijc∈Σ∪{ε},zijγ1,γ2,γ∈Γ∗,enzijw∈Σ∗.
Dan wordt de leidt in  ́e ́en stap relatie ⊢M als volgt gedefinieerd: (q1,cw,γ1γ)⊢M (q2,w,γ2γ)⇔((q1,c,γ1),(q2,γ2))∈∆.
De relatie ⊢∗M is de reflexieve, transitieve sluiting van de  ́e ́en stapsrelatie ⊢M.
De configuratie C1 leidt tot de configuratie C2 als en slechts als C1 ⊢∗M C2.
In woorden kunnen we de afleiding (q1,cw,γ1γ)⊢M (q2,w,γ2γ)
als volgt beschrijven:
als de PDA M in de toestand q1 is, als c het linkse symbool is uit de input, en als de reeks symbolen γ1 boven op de stapel staat, dan mag de PDA M naar de toestand q2 gaan, de reeks symbolen γ1 van de stapel halen (pop), en daarna de reeks symbolen γ2 boven op de stapel plaatsen (push).
Nu defini ̈eren we een berekening uitgevoerd door een PDA M. Definitie 10.2.4 Een berekening uitgevoerd door een PDA M is een ein-
dige reeks configuraties C0, C1, . . . , Cn, n ≥ 0, zodat: 142
￼
• C0 is de initi ̈ele configuratie (s, w, ε),
• Cn is van de vorm (q,ε,γ), voor een zekere toestand q ∈ K van de
PDA M, en een zekere reeks γ ∈ Γ∗ van stapelsymbolen, en
• C0 ⊢M C1 ⊢M ···⊢M Cn.
Merk dus op dat bij een berekening de input w volledig verwerkt dient te zijn door de PDA M.
We hebben reeds in de inleiding benadrukt dat de automaten die de con- textvrije talen kunnen aanvaarden, gelijk zijn aan de niet-deterministische stapelautomaten. Zoals ook opgemerkt in de inleiding dient er heel voorzich- tig omgegaan te worden met dit niet-deterministisch aspect van een PDA. Dit kan al gezien worden bij de transities die een PDA M kan uitvoeren:
Als een PDA M in een bepaalde configuratie (q1,s,γ) is, dan is het mogelijk dat:
• de transitierelatie ∆ precies  ́e ́en transitie bevat die uitgevoerd kan wor- den op deze configuratie,
• de transitierelatie ∆ meer dan  ́e ́en transitie bevat die uitgevoerd kan worden op deze configuratie,
• de transitierelatie ∆ geen enkele transitie bevat die uitgevoerd kan wor- den op deze configuratie,
Dit niet-deterministisch aspect aan de PDA heeft ook zijn gevolgen in de definitie van wat deze PDA kan aanvaarden.
Definitie 10.2.5 Een berekening C van een PDA M is een aanvaardende berekening als en slechts als
•
en
• q ∈ A.
C = (s,w,ε) ⊢∗M (q,ε,ε),
De PDA M aanvaardt een inputreeks w als en slechts als minstens  ́e ́en van zijn berekeningen deze input aanvaardt.
In deze definitie zijn er verschillende details die een belangrijke rol spelen.
In de uitdrukking C = (s, w, ε) ⊢∗M (q, ε, ε) van de definitie van een aan- vaardende berekening toont het rechtergedeelte (q,ε,ε) aan dat bij een aan- vaardende berekening de input w volledig verwerkt dient te worden
143
(dit is de middelste ε), en dat de stapel ook leeg dient te zijn (dit is de rechtse ε).
Als een berekening niet aanvaardend is, dan kan zij op verschillende andere manieren eindigen:
• de berekening kan de input volledig gelezen hebben, maar gestopt zijn in een niet-aanvaardende toestand,
• de berekening kan de input volledig gelezen hebben en gestopt zijn in een aanvaardende toestand, maar de stapel is niet-ledig,
• de berekening kan in een oneindige lus terecht gekomen zijn,
• de berekening kan in een doodlopend punt terecht gekomen zijn, van
waaruit geen input meer gelezen kan worden.
Er dient met al deze mogelijkheden rekening gehouden te worden, waar- door de studie van de niet-deterministische stapelautomaten soms heel in- gewikkeld zal zijn.
Nu defini ̈eren we het verband met de taal aanvaard door een PDA M. Definitie 10.2.6 De taal L(M) aanvaard door een PDA M is de verzame-
ling van alle inputs aanvaard door deze PDA M.
Nu geven we de definitie van een verwerpende/weigerende berekening
uitgevoerd door een PDA M.
Definitie 10.2.7 Een berekening C uitgevoerd door een PDA M is een ver-
werpende/weigerende berekening als en slechts als: •
C = (s,w,ε) ⊢∗M (q,w′,α),
• C is geen aanvaardende berekening, en,
• de PDA M kan geen berekeningen meer uitvoeren op de configuratie (q, w′, α).
Een PDA M verwerpt/weigert een inputreeks w als en slechts als alle be- rekeningen die op deze inputreeks w uitgevoerd worden, weigerende/verwerpende berekeningen zijn.
Opmerking 10.2.8 Hier is het opnieuw belangrijk alle facetten uit de voor- gaande definities te bekijken.
Want, het is mogelijk dat, voor een bepaalde input w, een PDA M noch aanvaardt, noch verwerpt/weigert.
144
waarbij
Na deze definities geven we nu enkele voorbeelden van niet-deterministische stapelautomaten, en de talen die zij aanvaarden.
Voorbeeld 10.2.9 We geven eerst een PDA voor de taal van de gebalan- ceerde haakjes.
Figuur 10.5: PDA voor de taal van de gebalanceerde haakjes
Voorbeeld 10.2.10 Een PDA M voor de taal AnBn = {anbn : n ≥ 0}.
Figuur 10.6: PDA voor de taal AnBn = {anbn : n ≥ 0}
Hier kunnen we enkele van de labels in woorden verklaren.
Het label b/a/ε op de pijl van toestand s naar toestand f correspondeert met de transitie ((s,b,a),(f,ε)), en betekent dus: als de PDA in toestand s is, en b is het meest linkse symbool in de nog te verwerken input, en a bevindt zich boven op de stapel, dan mag de PDA dit linkse symbool b uit de input verwerken, a van de stapel halen, naar toestand f gaan, en niks (de nulreeks ε) op de stapel plaatsen.
Analoog correspondeert het label a/ε/a bij de lus bij de starttoestand s met de transitie ((s, a, ε), (s, a)), en betekent dit: als de PDA in toestand s is, en a is het meest linkse symbool in de nog te verwerken input, dan mag de PDA dit linkse symbool a uit de input verwerken, niks (de nulreeks ε) van de stapel halen, in toestand s blijven, en a op de stapel plaatsen.
Hier kan effectief gecontroleerd worden dat:
• bij evenveel a’s en b’s kan de input verwerkt worden door een aanvaar- dende berekening,
145
￼￼
• bij meer a’s dan b’s in de input kan de input niet verwerkt worden door een aanvaardende berekening, want de stapel kan nooit leeg gemaakt worden,
• bij minder a’s dan b’s kan de PDA deze input weigeren via een ver- werpende/weigerende berekening, want  ́e ́enmaal alle a’s uit de input van de stapel gehaald zijn, kan de PDA geen transities meer uitvoeren.
Voorbeeld 10.2.11 Een PDA voor de taal {wcwR : w ∈ {a, b}∗} van palin- dromen van oneven lengte met een c in het midden, en daarvoor en daarna enkel a’s en b’s.
Figuur 10.7: PDA voor de taal {wcwR : w ∈ {a, b}∗}
Merk op dat er hier een eenvoudig voorbeeld van een verwerpende/weigerende berekening gegeven kan worden. In de toestand f kan de PDA een letter a inlezen en de letter b bovenaan de stapel hebben, maar dan kan deze PDA geen volgende stap meer ondernemen.
Voorbeeld 10.2.12 Een PDA voor de taal {anb2n : n ≥ 0}.
Figuur 10.8: PDA voor de taal {anb2n : n ≥ 0}
Bemerk hoe deze PDA werkt: voor iedere a die ingelezen wordt, worden er twee a’s op de stapel geplaatst om daarna te kunnen controleren of het aantal b’s het dubbele is van het aantal a’s.
146
￼￼
10.3 Deterministische stapelautomaten
In de originele definitie voor stapelautomaten (Definitie 10.2.1) werden deze stapelautomaten gedefinieerd als niet-deterministische automaten. Nu geven we de definitie van een deterministische stapelautomaat.
Definitie 10.3.1 Een stapelautomaat M = (K, Σ, Γ, ∆, s, A) is determinis- tisch als en slechts als:
• de transitierelatie ∆ geen paar transities bevat die met elkaar in com- petitie kunnen treden,
• iedere keer dat de stapelautomaat M in een aanvaardende configuratie is, dan kan het geen verdere stappen meer uitvoeren.
Concreet betekent deze definitie:
als de toestand q een aanvaardende toestand is, dan is er geen transitie ((q,ε,ε),(p,a)) voor willekeurige p ∈ K en a ∈ Γ∗. Met andere woorden, de PDA M wordt nooit gedwongen om te kiezen tussen aanvaarden of ver- der doen. Alle transities die vertrekken vanuit een aanvaardende toestand moeten ofwel expliciet symbolen uit de input verwerken, of iets van de stapel afhalen.
Voorbeeld 10.3.2 Figuur 10.9 toont een PDA voor de taal PalEven = {wwR : w ∈ {a,b}∗} van de palindromen van even lengte, bestaande uit de letters a en b.
Merk op dat deze PDA niet-deterministisch is, omdat deze automaat niet kan weten waar het midden van een palindroom wwR is. Bij het Voorbeeld 10.2.11 van de taal van de palindromen {wcwR : w ∈ {a, b}∗} dient de PDA niet te gokken waar het midden van een dergelijke palindroom is. Het midden in een palindroom wcwR, w ∈ {a, b}∗, is de positie waar de letter c staat.
Het gokken waar het midden van een palindroom wwR staat, wordt uitge- drukt door het label ε/ε/ε op de pijl van de starttoestand s naar de toestand f: er wordt niks ingelezen van de input (linkse ε van label ε/ε/ε), er wordt niks van de stapel afgehaald (middenste ε van label ε/ε/ε), en er wordt niks op de stapel geplaatst (rechtse ε van label ε/ε/ε).
Voorbeeld 10.3.3 Figuur 10.10 toont een PDA voor de taal {w ∈ {a, b}∗ : #a(w) = #b(w)}.
10.4 Constructie van PDA
Nu construeren we een PDA om enkele idee ̈en te beschrijven hoe een PDA te maken die een bepaalde contextvrije taal aanvaardt.
147
￼￼￼￼￼￼￼￼￼￼￼￼Figuur 10.9: Niet-deterministische PDA voor PalEven = {wwR : w ∈ {a, b}∗}
Figuur 10.10: PDA voor de taal {w ∈ {a, b}∗ : #a(w) = #b(w)}
We nemen als voorbeeld de taal
L={ambn :m̸=n;m,n>0}.
Maak eerst de PDA die de reeksen ambn verwerkt, waarvoor m = n.
Figuur 10.11: Het geval m = n
Hier kunnen we al iets zeggen over de drie mogelijkheden: m = n, m > n,
en m < n.
• Als de stapel en de input allebei leeg zijn, dan zijn er evenveel a’s als
b’s, dus m = n: stop en weiger. 148
￼￼
￼￼￼￼￼￼￼￼￼￼￼Figuur 10.12: Het geval m > n
Figuur 10.13: Het geval m < n
• Als de input verwerkt is, maar de stapel is nog niet leeg, dan is m > n: aanvaard de input.
• Als de stapel leeg is, maar de input is nog niet volledig verwerkt, dan is m < n: aanvaard de input.
We voegen eerst een stuk bij aan de graaf om het geval m > n te behan- delen, gebaseerd op Figuur 10.12.
We voegen ook een stuk bij aan de graaf om het geval m < n te behan- delen, gebaseerd op Figuur 10.13.
Nu voegen we deze twee laatste stukken tesamen toe aan de graaf in Figuur 10.11 om de uiteindelijke PDA te bekomen die de taal L = {ambn : m ̸= n; m, n > 0} aanvaardt. Deze PDA is voorgesteld in Figuur 10.14.
10.5 Sterkte van niet-determinisme
De niet-deterministische stapelautomaten zijn performanter dan de eindige deterministische automaten. Zij kunnen de taal AnBn = {anbn : n ≥ 0} aanvaarden die niet regulier is. Dus we hebben al een complexer model van een automaat.
Maar kan een niet-deterministische stapelautomaat alle mogelijke talen aanvaarden?
Het antwoord is dat niet alle talen aanvaard kunnen worden door de niet-deterministische stapelautomaten.
149
￼
￼Figuur 10.14: PDA die L = {ambn : m ̸= n; m, n > 0} aanvaardt De taal
AnBnCn = {anbncn : n ≥ 0}
zal het klassiek voorbeeld zijn van een niet-contextvrije taal. Dit zal bewezen worden in Voorbeeld 11.2.3.
Maar deze taal is niet enkel interessant als het klassiek voorbeeld van een niet-contextvrije taal. Zij leert ons nog iets anders.
Beschouw namelijk de negatie van deze taal: L = ¬AnBnCn.
Deze taal L = ¬AnBnCn kan beschreven worden als de unie van twee andere talen, L = L1 ∪ L2, met:
•
L1 = {w ∈ {a, b, c}∗ : de letters staan niet in alfabetische volgorde},
en
•
Er geldt dat voor deze taal L = ¬AnBnCn een PDA gemaakt kan wor- den. Deze PDA wordt geillustreerd in Figuur 10.15.
Dit voorbeeld toont dus aan dat de contextvrije talen niet gesloten zijn onder complement.
150
L2 ={aibjck :i,j,k≥0en((i̸=j)of(j̸=k))}.
In de taal L2 vinden we dus een verschillend aantal a’s, b’s, of c’s.
￼Figuur 10.15: PDA voor ¬AnBnCn
Figuur 10.16: PDA die taal L = {ambn : m ̸= n; m, n > 0} aanvaardt 10.6 Reduceren van niet-determinisme
Het niet-deterministisch aspect van een stapelautomaat maakt het soms moeilijk om de correcte werking van deze PDA te begrijpen en te verklaren, en maakt het soms moeilijk om bepaalde zaken correct te formuleren.
Het is dus interessant om te kijken of er technieken bestaan om het niet-deterministisch aspect van een PDA te reduceren.
Dit zal nu in deze sectie besproken worden.
Beschouw de PDA uit Sectie 10.4 die de taal L = {ambn : m ̸= n;m,n > 0} aanvaardt.
Beschouw Figuur 10.16. In deze PDA dient er soms een keuze/gok ge- maakt te worden.
• Bij toestand 4, die het geval n > m dient te behandelen, is het nodig 151
￼
￼Figuur 10.17: PDA die einde van de stapel-symbool en einde van de input- symbool gebruikt
om de bodem van de stapel te vinden. Bij meer b’s dan a’s halen we alle a’s van de stapel en dan lezen we de overblijvende b’s in waarbij we niks meer op de stapel plaatsen zodat deze stapel leeg is als de laatste b ingelezen wordt.
Hier, in de originele PDA, wordt er in toestand 2 gegokt wanneer de stapel leeg is. Dit kunnen we vermijden door een symbool # te gebruiken dat op de stapel geplaatst wordt voor de PDA de input begint te verwerken. Dit symbool # heeft dan de betekenis van een einde van de stapel-symbool (end-of-stack marker), en kan de PDA dus duidelijk maken wanneer de stapel leeg wordt.
• Bij toestand 3, die het geval m > n dient te behandelen, is het nodig te weten wanneer de input stopt. Bij meer a’s dan b’s zijn er nog a’s op de stapel als de laatste b ingelezen is. Dan leest de PDA niks meer in als input, en haalt de PDA de overblijvende a’s van de stapel tot dat de stapel leeg wordt.
Hier, in de originele PDA, wordt er in toestand 2 gegokt wanneer de input volledig verwerkt is. Dit kunnen we vermijden door een symbool $ te gebruiken dat na de input geplaatst wordt, voor de PDA de input begint te verwerken. Dit symbool $ heeft dan de betekenis van een einde van de input-symbool (end-of-input-marker), en kan de PDA dus duidelijk maken wanneer de input verwerkt is.
Dit wordt geillustreerd in Figuur 10.17.
Merk op dat er een nieuwe starttoestand is, genummerd met 0, omdat eerst het einde van de stapel-symbool # op de stapel geplaatst dient te worden.
Voorbeeld 10.6.1 We hebben al vermeld dat de taal L = AnBnCn = {anbncn : n ≥ 0} niet contextvrij is, dus niet kan aanvaard worden door een PDA.
152
￼Figuur 10.18: PDA die {wwR : w ∈ {a, b}∗} aanvaardt
De taal {wwR : w ∈ {a, b}∗} is contextvrij, en kan dus aanvaard worden door een PDA.
Maar de taal {ww : w ∈ {a,b}∗} daarentegen is opnieuw niet meer contextvrij, en kan dus ook niet aanvaard worden door een PDA.
Het feit dat de taal {wwR : w ∈ {a, b}∗} wel aanvaard kan worden door een PDA, terwijl de taal {ww : w ∈ {a, b}∗} niet aanvaard kan worden door een PDA kan formeel bewezen worden.
Maar als er rekening gehouden wordt met het feit dat een PDA een stapel als geheugen gebruikt, en een stapel werkt volgens het LIFO-principe, dan kan dit al als intu ̈ıtieve verklaring gebruikt worden om te besluiten dat de taal {wwR : w ∈ {a,b}∗} wel aanvaard kan worden door een PDA, terwijl de taal {ww : w ∈ {a, b}∗} niet aanvaard kan worden door een PDA.
Dit zal ook besproken worden in Sectie 11.2 waar er gesproken zal worden van geneste en seri ̈ele afhankelijkheden/verbanden.
10.7 Equivalentie tussen PDA en CFG
Er is al een aantal keer vermeld dat de contextvrije talen gelijk zijn aan de talen die aanvaard kunnen worden door een niet-deterministische stapelau- tomaat M.
We zullen dit nu formeel bewijzen in deze sectie.
Stelling 10.1 De klasse van de talen aanvaard door de niet-deterministische stapelautomaten is gelijk aan de klasse van de contextvrije talen.
Deze stelling dient in twee stappen bewezen te worden. We bewijzen eerst dat elke contextvrije taal aanvaard kan worden door een PDA.
Lemma 1 Elke contextvrije taal L kan aanvaard worden door een PDA M.
BEWIJS: We zullen dit doen via twee bewijzen die twee verschillende benaderingen zullen gebruiken:
153
￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼Figuur 10.19: PDA voor top down parser
• een Top Down benadering, en
• een Bottom Up benadering.
BEWIJS 1: TOP DOWN benadering. We illustreren dit eerst via een voorbeeld.
Voorbeeld 10.7.1 Beschouw de grammatica van de rekenkundige uitdruk- kingen.
E→E+T E→T T→T∗F T→F
F → (E) F → id
Eerst stellen we de transitie ((p, ε, ε), (q, E)) op. We hervertalen dan de herschrijfregels tot de volgende transities voor een PDA M.
(1) (q,ε,E),(q,E+T)
(2) (q,ε,E),(q,T)
(3) (q,ε,T),(q,T ∗F)
(4) (q,ε,T),(q,F)
(5) (q,ε,F),(q,(E))
(6) (q,ε,F),(q,id)
(7) (q,id,id),(q,ε) (8) (q, (, (), (q, ε) (9) (q, ), )), (q, ε) (10) (q, +, +), (q, ε) (11) (q,∗,∗),(q,ε)
Deze herschrijfregels leiden tot de PDA M in Figuur 10.19.
Dit voorbeeld toont aan dat het eerste wat gedaan is, niks anders is dan het startsymbool E op de stapel zetten, en daarna worden alle herschrijfre- gels hervertaald naar de transities die opgesomd zijn.
Nu volgt de formele beschrijving van de Top Down parser. De PDA die de contextvrije taal L aanvaardt, is:
M = ({p,q},Σ,V,∆,p,{q}), waarbij de transitierelatie ∆ de volgende transities bevat:
154
￼Figuur 10.20: PDA voor top down parser
• De begintransitie
((p, ε, ε), (q, S)).
• Voor elke herschrijfregel X → s1 · · · sn in R, voeg de transitie
((q,ε,X),(q,s1 ···sn)) toe aan de transitierelatie ∆.
• Voor elke terminaal c ∈ Σ, voeg de transitie ((q, c, c), (q, ε))
toe aan de transitierelatie ∆.
Voorbeeld 10.7.2 We geven nu een volledig uitgewerkt voorbeeld in Figuur 10.21.
Eerst wordt de taal L gegeven, dan de herschrijfregels die in de linkse kolom opgesomd zijn, dan de hervertaling van deze herschrijfregels volgens het algoritme van de top down benadering, en eronder de verwerking van de input aabbaa door deze PDA.
BEWIJS 2: BOTTOM UP benadering.
We illustreren dit opnieuw eerst via een voorbeeld.
Voorbeeld 10.7.3 Beschouw de grammatica van de rekenkundige uitdruk- kingen, met de herschrijfregels:
E→E+T E→T T→T∗F T→F
F → (E) F → id
155
￼￼￼￼￼￼￼￼￼L = {anb*an} (1) S " !
(2) S " B (3) S " aSa (4) B " ! (5) B "bB
*
0 (p, !, !), (q, S)
1 (q, !, S), (q, !)
2 (q, !, S), (q, B)
3 (q, !, S), (q, aSa) 4 (q, !, B), (q, !)
5 (q, !, B), (q,bB) 6 (q, a, a), (q, !) 7 (q, b, b), (q, !)
input = a a b b a a
Trans state
p 0 q 3 q 6 q 3 q 6 q 2 q 5 q 7 q 5 q 7 q 4 q
unread input stack
aa b a a b aa b
b aa !
b aa S
b aa aSa
a a aa 6qaa 6q!!
a b b a a Sa
a b b a a aSaa
b b a a Saa b b a a Baa b b aa bBaa
b a a Baa b a a bBaa
a a Baa
Figuur 10.21: PDA die hoort bij taal L volgens top down benadering
Figuur 10.22: PDA voor bottom up parser
We hervertalen dan de herschrijfregels tot de volgende transities voor een PDA M.
￼(1) (p,ε,T +E),(p,E)
(2) (p,ε,T),(p,E)
(3) (p,ε,F ∗T),(p,T)
(4) (p,ε,F),(p,T)
(5) (p,ε,)E(),(p,F)
(7) (p, id, ε), (p, id) (8) (p, (, ε), (p, () (9) (p, ), ε), (p, )) (10) (p, +, ε), (p, +) (11) (p,∗,ε),(p,∗)
(6) (p,ε,id),(p,F)
Tenslotte stellen we de eindtransitie ((p, ε, E), (q, ε)) op. Deze herschrijfregels leiden tot de PDA M uit Figuur 10.22.
Dit voorbeeld toont aan dat het laatste wat gedaan is, niks anders is dan het startsymbool E van de stapel halen. In feite lopen we de transities die leidden van het startsymbool naar de zin uit de taal, in omgekeerde richting af. Bij bottom up starten we intu ̈ıtief bij de zin, en doorlopen we de transities in omgekeerde richting, om terug te komen bij het startsymbool dat, in de
156
￼Figuur 10.23: PDA voor bottom up parser
bijhorende PDA, als allerlaatste bewerking uitgevoerd door de PDA, van de stapel gehaald wordt.
Nu volgt de formele beschrijving van de Bottom Up parser. De PDA die de contextvrije taal L aanvaardt, is:
M = ({p,q},Σ,V,∆,p,{q}), waarbij de transitierelatie ∆ de volgende transities bevat:
• Voor elke terminaal c ∈ Σ, voeg de transitie ((p, c, ε), (p, c))
toe aan de transitierelatie ∆.
• Voor elke herschrijfregel X → s1 · · · sn in R, voeg de transitie
((p,ε,(s1 ···sn)R),(p,X)) toe aan de transitierelatie ∆.
• De eindtransitie
De betekenis van deze herschrijfregels is als volgt.
Zij w ∈ L(G), en zij
S⊢G ···⊢G ···⊢G w
de afleiding die van het startsymbool S naar de zin w ∈ L(G) geleid heeft. We plaatsen eerst de input w volledig op de stapel via de herschrijfregels ((p,c,ε),(p,c)). Daarna proberen we de herschrijfregels, die geleid hebben van het startsymbool S naar de input w, in omgekeerde volgorde te doorlo- pen om terug te keren naar het startsymbool S, dat dan op het einde door
de eindtransitie ((p, ε, S), (q, ε)) van de stapel gehaald wordt.
Dit besluit het bewijs van het eerste gedeelte: Elke contextvrije taal L kan aanvaard worden door een PDA M.
Nu blijft nog de omgekeerde implicatie over: Als een taal aanvaard wordt door een PDA M, dan is deze taal een contextvrije taal.
157
((p, ε, S), (q, ε)).
￼Figuur 10.24: Niet-deterministische PDA voor PalEven = {wwR : w ∈ {a, b}∗}
Lemma 2 Als een taal aanvaard wordt door een PDA M, dan is deze taal een contextvrije taal.
BEWIJS: Dit bewijs dient niet gekend te zijn. P 10.8 Besluiten
Tot besluit van dit hoofdstuk bespreken we nog enkele zaken, waaronder een equivalente definitie voor Definitie 10.2.5 voor een aanvaardende berekening.
1. Er zijn contextvrije talen die niet aanvaard kunnen worden door een deterministische PDA.
Hier zien we nogmaals een cruciaal verschil met de eindige automa- ten, waar de talen aanvaard door een eindige deterministische au- tomaat, samenvallen met de talen aanvaard door een eindige niet- deterministische automaat, namelijk de klasse van de reguliere talen.
Herhalen we eens Voorbeeld 10.3.2 van de taal PalEven van de even palindromen. Een PDA die PalEven aanvaardt, wordt getoond in Figuur 10.24.
Merk op dat deze PDA niet-deterministisch is, omdat deze automaat niet kan weten waar het midden van een palindroom wwR is. Hier heb je ook het gevoel dat het niet-deterministisch aspect van deze PDA niet ongedaan kan gemaakt worden.
Bij het Voorbeeld 10.2.11 van de verzameling van de palindromen {wcwR : w ∈ {a,b}∗} dient de PDA niet te gokken waar het mid- den van een dergelijke palindroom is. Het midden in een palindroom wcwR, w ∈ {a, b}∗, is de positie waar de letter c staat.
2. Het is mogelijk dat een PDA M 158
￼Figuur 10.25: PDA voor taal L(M) = {a}
• nooit stopt voor een bepaalde input, dus in een oneindige lus kan terechtkomen.
• nooit stopt met zijn input te lezen.
3. In tegenstelling tot bij de eindige deterministische automaten (Hoofd-
stuk 3) bestaat er geen algoritme om een PDA te minimaliseren.
Het probleem betreffende het minimaal zijn van een PDA is een onbe- slisbaar probleem.
Hier zien we opnieuw grote verschillen met de theorie van de eindige deterministische automaten.
Voorbeeld 10.8.1 We geven nu een voorbeeld van een PDA die
• nooit stopt voor een bepaalde input, dus in een oneindige lus kan te-
rechtkomen.
• nooit stopt met zijn input te lezen.
Stel Σ = {a} en beschouw de PDA M in Figuur 10.25.
Hier is de taal L(M) aanvaard door deze PDA M gelijk aan de taal L(M) = {a}.
De afleiding die tot a ∈ L(M) leidt is:
(1,a,ε) ⊢ (2,a,a) ⊢ (3,ε,ε).
Op elke andere input, verschillend van a, zal
• M nooit stoppen,
• M zal nooit stoppen met zijn input te lezen, tenzij de input gelijk is aan ε.
Nu bespreken we een alternatieve definitie voor een aanvaardende bere- kening. In Definitie 10.2.5 werd benadrukt dat bij een aanvaardende bere- kening de input w volledig verwerkt dient te worden, en dat de stapel ook leeg dient te zijn.
159
De vraag kan gesteld worden of het expliciet nodig is te eisen dat de stapel leeg dient te zijn, voor we mogen spreken over een aanvaardende berekening:
is het niet voldoende te spreken over een aanvaardende berekening als de PDA in een aanvaardende toestand is als de input volledig verwerkt is?
Formeel:
Als (s, w, ε) ⊢∗M (q, ε, γ) en q ∈ A, dan aanvaardt M in de nieuwe definitie.
Er geldt dat beide definities equivalent zijn.
We tonen hoe Definitie 10.2.5 voor aanvaardende berekening omgezet kan worden in de nieuwe definitie. De omgekeerde implicatie wordt overge- laten als oefening.
Van oude definitie naar nieuwe definitie:
1. Stel M′ = M.
2. Cre ̈eer een nieuwe starttoestand s′ en voeg de transitie
((s′ε, ε), (s, #))
toe.
3. Cre ̈eer een nieuwe aanvaardende toestand qa.
4. Voor elke aanvaardende toestand a in M doe, voeg de transitie
((a, ε, #), (qa, ε))
toe.
5. Maak qa de enige aanvaardende toestand in de PDA M′.
Hier kan je alles wat aanvaard wordt door de PDA M volgens de oude Definitie 10.2.5 (stapel dient leeg te zijn), nu laten aanvaarden door de nieuwe PDA M′ volgens de nieuwe definitie (alle input verwerkt en eindigen in een aanvaardende toestand).
Voorbeeld 10.8.2 We passen deze conversieregels toe op de PDA voor de gebalanceerde haakjes taal. Beschouw Figuur 10.26.
De linkse PDA aanvaardt deze taal volgens de oude Definitie 10.2.5, en de rechtse PDA aanvaardt deze taal volgens de nieuwe definitie.
160
￼Figuur 10.26: Van oude naar nieuwe definitie voor aanvaardende berekening
Opmerking 10.8.3 We hebben in dit hoofdstuk een gedetailleerde studie ge- maakt van een automaat die een stapel, die werkt volgens het LIFO-principe, gebruikt.
Stel dat er variaties op dit type automaat geconstrueerd worden, welk types automaten worden dan bekomen?
We beschouwen de volgende twee voorbeelden:
• Een EDA die ook een FIFO-queue mag gebruiken, is equivalent met een Turing machine, die in Deel 3 bestudeerd zal worden.
• Een EDA die twee stapels gebruikt, is ook equivalent met een Turing machine.
Dit zal aangetoond worden op het einde van Hoofdstuk 14.
In beide gevallen wordt dus een automaat bekomen die performanter is dan een niet-deterministische stapelautomaat.
161
Hoofdstuk 11
Contextvrije en niet-contextvrije talen
11.1 Inleiding
Op dit ogenblik hebben we al twee types talen besproken: • de reguliere talen. Bijvoorbeeld, de taal a∗b∗.
• de contextvrije talen. Bijvoorbeeld, de taal AnBn = {anbn : n ≥ 0} is contextvrij, maar niet-regulier.
Maar dit zijn natuurlijk niet de enige talen.
We hebben al een concreet voorbeeld gezien van een taal die niet con- textvrij is, namelijk de taal
AnBnCn = {anbncn : n ≥ 0}.
In dit hoofdstuk bespreken we algoritmes om te testen of een taal con- textvrij, respectievelijk niet-contextvrij, is.
Uit de inleiding en de voorbeelden hierboven weten we al dat de volgende stelling geldt.
Stelling 11.1 De verzameling van de reguliere talen is een stricte deelver- zameling van de verzameling van de contextvrije talen.
Op het vlak van de automaten toont deze stelling dus aan dat de niet- deterministische stapelautomaten performantere automaten zijn dan de ein- dige deterministische automaten.
162
11.2 Het pompend lemma voor contextvrije talen
Het aantonen dat een taal L contextvrij is, kan bijvoorbeeld op de volgende manieren:
• Geef een contextvrije grammatica voor de taal L.
• Geef een PDA die deze taal L aanvaardt.
• Gebruik de sluitingseigenschappen van contextvrije talen.
Er dient hier echter rekening gehouden te worden met het feit dat de sluitingseigenschappen voor contextvrije talen zwakker zijn dan deze voor de reguliere talen.
Als concreet voorbeeld, er is in het vorige hoofdstuk, in Sectie 10.5, al opgemerkt dat de taal L = AnBnCn = {anbncn : n ≥ 0} niet contextvrij is, terwijl zijn negatie ¬AnBnCn wel contextvrij is.
Voor het aantonen dat een taal L niet-contextvrij is, zullen we opnieuw een pompend lemma opstellen. Dit zal gebaseerd zijn op de parse trees van een grammatica. Om deze reden herhalen we de Definitie 8.5.2 van parse tree.
Definitie 11.2.1 Een parse tree, afgeleid door een grammatica G = (V, Σ, R, S), is een boom waarin:
• De wortel heeft het startsymbool S van G als label.
• Elk blad van de boom heeft een element uit Σ ∪ {ε}, dus een terminaal
of de nulreeks ε, als label.
• Elke andere knoop heeft een niet-terminaal als label, en
• als m een knoop is die geen blad is in de boom, die de niet-terminaal X als label heeft, en als de kinderen van de knoop m gelabeld zijn door x1,...,xn, dan moet de herschrijfregel X → x1 ···xn behoren tot de verzameling van herschrijfregels R.
Voor het opstellen van het pompend lemma voor contextvrije talen heb- ben we ook de begrippen hoogte en vertakkingsgetal van een boom nodig.
Definitie 11.2.2 De hoogte van een boom is de lengte van het langste pad van de wortel naar  ́e ́en van de bladeren van de boom.
Het vertakkingsgetal van een boom is het grootste aantal kinderen van een knoop, onmiddellijk adjacent met de gegeven knoop, binnenin de boom.
163
￼Figuur 11.1: Hoogte en vertakkingsgetal binnenin een boom
Deze twee begrippen worden geillustreerd door Figuur 11.1.
De volgende stelling wordt bewezen via inductie op de hoogte van een boom.
Stelling 11.2 De lengte van de basis van een boom T, met hoogte h en vertakkingsgetal b, is hoogstens bh.
Nu gaan we van de grammatica’s naar de bomen. Beschouw een contextvrije grammatica G en zij
• n het aantal niet-terminalen in de grammatica G, • b het vertakkingsgetal van de grammatica G.
Stel nu dat T een parse tree is, gegenereerd door de contextvrije gram- matica G, en stel dat elke niet-terminaal hoogstens  ́e ́en keer optreedt op elk pad binnen de boom T. Dan is
• de hoogte van de boom T hoogstens gelijk aan n, en,
• de maximale lengte van een woord uit de taal L(G) gegenereerd door
de boom T hoogstens gelijk aan bn.
Dus als een woord w uit de taal L(G) gegenereerd door de contextvrije grammatica G een lengte groter dan bn heeft, dan moet in de parse tree van dit woord w langs een bepaald pad een niet-terminaal X minstens twee keer optreden. Dit wordt verduidelijkt in Figuur 11.2.
Dit zal ons geleidelijk leiden naar het pompend lemma voor contextvrije grammatica’s.
Beschouw de parse tree van een woord w uit de taal L(G), met kleinste lengte groter dan bn. Dan is er een herhaling van een niet-terminaal X in de parse tree van dit woord w. Beschouw de niet-terminaal X die het vroegst herhaald is. We gebruiken nu Figuur 11.2 om de idee ̈en van het pompend lemma voor contextvrije grammatica’s uit te leggen. In deze figuur
164
￼￼￼￼￼￼Figuur 11.2: Herhaling van een niet-terminaal X binnenin een boom
is het woord w opgesplitst in de vijf opeenvolgende reeksen u, v, x, y, z. Dus w = uvxyz.
Bekijk het gedeelte vxy waarin de herhaling van de niet-terminaal X optreedt. Daar dit de eerste niet-terminaal is die herhaald wordt in de parse tree, moet |vxy| ≤ bn+1, want binnen een woord van lengte bn+1 treedt zeker een herhaling van een niet-terminaal op.
Bekijk de herschrijfregels die leiden van de eerste keer dat de niet- terminaal X optreedt, aangeduid met X[1], naar de tweede keer dat de niet-terminaal X optreedt, aangeduid met X[2]. Als je deze herschrijfregels nog eens uitvoert, startend in X[2], dan krijg je het woord uv2xy2z uit de taal L(G). Dan treedt de niet-terminaal X nog eens op, duid dit aan met X[3]. Herhaal dan in X[3] opnieuw de herschrijfregels die leidden van X[1] naar X[2], dan wordt het woord uv3xy3z uit de taal L(G) bekomen.
Door inductie zien we dat, voor alle q ∈ N \ {0}, het woord uvq xyq z tot de taal L(G) behoort.
Meer zelfs, pas de herschrijfregels die leidden van X[1] naar X[2] in Figuur 11.2 niet toe, dan bekom je het woord uv0xy0z = uxz uit de taal L(G).
We hebben bewezen dat in lange woorden w van een taal L(G) voort- gebracht door een contextvrije grammatica G een herhaling van de vorm uvqxyqz, q ∈ N, optreedt voor een geschikte partitie van het woord w in de vijf opeenvolgende delen u, v, x, y, z.
We formaliseren dit in de contextvrije versie van het pompend lemma.
Stelling 11.3 (Pompend lemma) Als de taal L een oneindig grote con- textvrije taal is, dan bestaat er een natuurlijk getal k ≥ 1, zodat voor alle reeksen w ∈ L, met |w| ≥ k,
∃u,v,x,y,z zodat w = uvxyz en vy ̸= ε en |vxy| ≤ k, en ∀q ≥ 0 : uvqxyqz ∈ L.
165
BEWIJS: Stel dat deze contextvrije taal L voortgebracht wordt door de contextvrije grammatica G = (V, Σ, R, S) met n niet-terminale symbolen en met vertakkingsgetal b. Dan is de lengte van het langste woord dat voort- gebracht kan worden door de grammatica G, zonder dat er niet-terminalen herhaald worden in de bijbehorende parse tree, hoogstens gelijk aan bn.
Stel het getal k = bn+1.
Opdat de taal L oneindig groot zou kunnen zijn, moet zeker het vertak- kingsgetal b ≥ 2. Dus bn+1 > bn.
Neem nu een willekeurig woord w uit de taal L(G) van lengte |w| ≥ k. Neem dan de kleinste parse tree T die het woord w genereert. Dan is de hoogte van deze parse tree minstens n + 1.
Kies een pad van lengte n + 1 in de parse tree T . Neem de laagste niet- terminaal X die herhaald wordt langs dit pad. Dan kunnen we opnieuw gebruik maken van Figuur 11.2.
We kunnen opnieuw w herschrijven als w = uvxyz. De boom die X[1] als wortel heeft, heeft hoogstens hoogte n + 1. Dan heeft het gedeelte vxy eronder hoogstens lengte bn+1. Dus |vxy| ≤ k.
In dit woord vxy is vy ̸= ε, want moest vy = ε, dan zou er een kortere parse tree zijn voor w, en dit kan niet want we kozen de parse tree T als de kleinste parse tree die het woord w genereert.
Het woord uxz = uv0xy0z behoort ook tot L, want de reeks herschrijfre- gels die leidde van X[1] naar X[2] kon ook niet uitgevoerd zijn, en dan was ook een woord uit de taal L(G) bekomen. Maar de reeks herschrijfregels die leiden van X[1] naar X[2] kan ook een willekeurig aantal keer q herhaald worden, leidend tot het woord uvqxyqz uit de taal L(G).
We hebben het pompend lemma voor contextvrije talen bewezen. P
Dit is de tweede keer dat we een pompend lemma bewezen hebben; in Stelling 6.6 voor reguliere talen, nu voor contextvrije talen. Er zijn gelijke- nissen en verschillen in de twee stellingen.
De grootste gelijkenis ligt in het gebruik van het pompend lemma. We gebruiken het pompend lemma voor contextvrije talen opnieuw om aan te tonen dat bepaalde talen L niet-contextvrij zijn. Hiertoe kiezen we een woord w uit de taal L en we tonen aan dat het onmogelijk is om dit woord te schrijven als w = uvxyz, zodat voor alle q ∈ N, uvqxyqz ∈ L. Als dit effectief bewezen kan worden, dan hebben we formeel, volledig correct, bewezen dat deze taal L niet-contextvrij is.
We vatten nu de gelijkenissen en de verschillen tussen de twee versies van het pompend lemma voor reguliere talen en contextvrije talen samen:
Gelijkenissen:
166
• we kiezen in beide gevallen een woord w dat we zullen oppompen.
• we zoeken een waarde voor q die aantoont dat het woord w niet opge-
pompt kan worden.
• er mogen voorbereidende sluitingseigenschappen toegepast worden om
een eenvoudiger gebruik van het pompend lemma toe te laten.
Verschillen:
• bij het pompend lemma voor contextvrije talen moeten twee woorden v en y gelijktijdig opgepompt worden.
• de preciese positie van deze twee woorden v en y is niet gekend, maar ze liggen wel redelijk dicht bij elkaar, want het pompend lemma zegt dat |vxy| ≤ k.
• hoogstens  ́e ́en van de woorden v en y mag de nulreeks ε zijn.
Nu geven we twee voorbeelden waarin het pompend lemma toegepast
wordt.
Voorbeeld 11.2.3 De taal L = AnBnCn = {anbncn : n ∈ N} is niet contextvrij.
Beschouw de constante k uit het pompend lemma, en beschouw het woord w = akbkck uit de taal AnBnCn.
Als de taal AnBnCn contextvrij is, dan moet het pompend lemma toe- pasbaar zijn op het woord w = akbkck. We tonen nu aan dat dit niet kan.
Probeer het woord w te schrijven als uvxyz, met |vxy| ≤ k.
Stel dat het woord v of het woord y verschillende letters gebruikt. Stel dan q = 2, dan zullen in het woord uv2xy2z, dus voor q = 2, de letters a, b, c niet meer in alfabetische volgorde staan, dus uv2xy2z ̸∈ AnBnCn.
Als de beide woorden v en y slechts  ́e ́en letter gebruiken, stel opnieuw q = 2, dan zullen in het woord uv2xy2z  ́e ́en of twee karakters meer optreden dan in uvxyz, maar er is zeker een derde karakter die nog evenveel keer als vroeger optreedt. Dus de letters a,b,c treden niet evenveel keer op in uv2xy2z, dus uv2xy2z ̸∈ AnBnCn.
We besluiten dat het onmogelijk is om het woord w te schrijven als uvxyz, zoals voorgeschreven in de formulering van het pompend lemma. Het pom- pend lemma voor contextvrije talen geldt niet voor de taal AnBnCn.
Dit toont aan dat de taal AnBnCn niet contextvrij is.
Voorbeeld 11.2.4 De taal L = {an2 : n ∈ N} is niet contextvrij. Beschouw de constante k uit het pompend lemma, stel n = k2, en be-
schouwhetwoordw=an2 =ak4 ∈L. 167
￼￼￼￼￼￼￼￼￼￼￼￼￼￼Als de taal L contextvrij is, dan moet het pompend lemma toepasbaar zijn op het woord w = ak4 . We tonen nu aan dat dit niet kan.
Probeer het woord w te schrijven als uvxyz, met |vxy| ≤ k, dan is vy = ap, voor een zekere p ∈ N \ {0}.
Stel q = 2 in het pompend lemma, dan is het woord uv2xy2z = ak4+p, en dit woord moet behoren tot de taal L.
Het eerstvolgende woord in de taal L, na het woord w = an2 = ak4, is het woord a(n+1)2 = a(k2+1)2 = ak4+2k2+1.
Dus opdat uv2xy2z = ak4+p ∈ L, moet p ≥ 2k2 + 1.
Maar, uit de voorwaarden van het pompend lemma, p = |vy| ≤ |vxy| ≤ k, dus p kan onmogelijk minstens gelijk zijn aan 2k2 + 1.
We besluiten dat het onmogelijk is om het woord w te schrijven als uvxyz, zoals voorgeschreven in de formulering van het pompend lemma. Het pom- pendlemmavoorcontextvrijetalengeldtnietvoordetaalL={an2 :n∈N}.
Dit toont aan dat de taal L = {an2 : n ∈ N} niet contextvrij is.
Hier volgt nu een hint die nuttig kan zijn om in te zien of een taal L al
dan niet contextvrij is.
De taal L = PalEven = {wwR : w ∈ {a, b}∗} is contextvrij. In deze taal
herkennen we geneste afhankelijkheden/verbanden (Figuur 11.3).
Figuur 11.3: Geneste afhankelijkheden
De taal L = WcW = {wcw : w ∈ {a,b}∗} is niet contextvrij. Ook hier herken je afhankelijkheden/verbanden in de woorden wcw uit de taal L, maar deze zijn seri ̈ele afhankelijkheden/verbanden (Figuur 11.4).
Figuur 11.4: Seri ̈ele afhankelijkheden
168
￼￼
Intu ̈ıtief zijn de afhankelijkheden/verbanden binnenin woorden uit con- textvrije talen genest. Bij het bekijken van Figuur 11.3 herkennen we het LIFO principe van een stapel als we het woord van links naar rechts lezen. Bij het bekijken van Figuur 11.4 herkennen we eerder het FIFO principe bij het lezen van het woord van links naar rechts.
Er kan via het pompend lemma formeel aangetoond worden dat de taal L = WcW = {wcw : w ∈ {a,b}∗} niet contextvrij is.
11.3 Sluitingseigenschappen voor contextvrije ta- len
Stelling 11.4 De contextvrije talen zijn gesloten onder:
• unie,
• concatenatie,
• Kleene ster,
• reverse/omkering,
• substitutie van letters.
BEWIJS: We geven het bewijs voor de sluiting onder reverse/omkering. Eerst en vooral:
LR ={w∈Σ∗ :w=xR vooreenzekerex∈L}.
Beschouw een contextvrije taal L, en beschouw een grammatica G = (V, Σ, R, S) voor de taal L in Chomsky normale vorm (Definitie 9.2.1).
Bij de Chomsky normale vorm zijn alle herschrijfregels in de grammatica G van de vorm
X → BC of X → a, met X, B, C ∈ V \ Σ en a ∈ Σ.
Op het vlak van de bijbehorende talen kunnen we dit schrijven als: • X→a:L(X)={a}, en{a}R ={a}.
• X → BC : L(X) = L(B)L(C), en (L(B)L(C))R = L(C)RL(B)R.
We construeren nu, startend van de grammatica G, een nieuwe gramma- tica G′, zodat L(G′) = LR.
Namelijk G′ = (V,Σ,R′,S), met V,Σ,S uit de grammatica G, en met de herschrijfregels uit R′ als volgt opgesteld:
169
• Voor elke herschrijfregel in G van de vorm X → BC, plaats in R′ de herschrijfregel X → CB.
• Voor elke herschrijfregel in G van de vorm X → a, plaats in R′ de herschrijfregel X → a.
Dan geldt effectief dat L(G′) = LR. P
Nu concentreren we ons op de eigenschappen: doorsnede en complement van contextvrije talen. Is de doorsnede van twee contextvrije talen nog steeds contextvrij, en is het complement van een contextvrije taal ook nog steeds contextvrij?
Het antwoord op beide vragen is neen.
Stelling 11.5 De doorsnede van twee contextvrije talen is niet altijd con- textvrij.
BEWIJS: De twee talen
L1 ={anbncm :n,m∈N}
en
L2 ={ambncn :n,m∈N} zijn allebei contextvrij, maar hun doorsnede
L1 ∩L2 ={anbncn :n∈N}
is het klassieke voorbeeld van een niet-contextvrije taal (Voorbeeld 11.2.3).
P
Stelling 11.6 Het complement van een contextvrije taal is niet altijd con- textvrij.
BEWIJS: Beschouw de taal ¬AnBnCn. Deze taal is contextvrij, want zij wordt aanvaard door de PDA in Figuur 11.5.
Maar de taal ¬¬(AnBnCn) = AnBnCn is opnieuw het klassieke voor- beeld van een niet-contextvrije taal. P
Analoog geldt de volgende stelling.
Stelling 11.7 Het verschil L1 \ L2 van twee contextvrije talen L1 en L2 is niet altijd contextvrij.
170
￼Figuur 11.5: PDA voor ¬AnBnCn
BEWIJS: Geef hier zelf een tegenvoorbeeld. P
De vorige stellingen tonen aan dat drie sluitingseigenschappen, die wel geldig waren voor reguliere talen, niet meer geldig zijn voor contextvrije talen.
E ́enmaal geweten was dat de drie voorgaande sluitingseigenschappen niet meer geldig waren voor contextvrije talen, zijn onderzoekers op zoek gegaan naar zwakkere versies, of bijzondere versies, van sluitingseigenschappen. We bespreken nu enkele van deze zwakkere/bijzondere versies.
Stelling 11.8 De doorsnede van een contextvrije taal met een reguliere taal is altijd contextvrij.
BEWIJS: Zij L = L(M1) de contextvrije taal, aanvaard door de PDA M1 = (K1, Σ, Γ1, ∆1, s1, A1), en zij R = L(M2) de reguliere taal, aanvaard door de EDA M2 = (K2,Σ,δ,s2,A2).
We maken nu een nieuwe PDA M3 die de doorsnede L ∩ R aanvaardt door een parallele uitvoering van de PDA M1 en de EDA M2 te simuleren.
Namelijk,
M3 =(K1 ×K2,Σ,Γ1,∆,(s1,s2),A1 ×A2), met als transitierelatie ∆:
• voor elke transitie ((q1, a, β), (p1, γ)) ∈ ∆1 en voor elke transitie (q2, a, p2) ∈ δ, voeg de transitie (((q1, q2), a, β), ((p1, p2), γ)) toe aan ∆.
• voor elke transitie ((q1, ε, β), (p1, γ)) ∈ ∆1 en voor elke toestand q2 ∈ K2, voeg de transitie (((q1, q2), ε, β), ((p1, q2), γ)) toe aan ∆.
171
Dan aanvaardt deze PDA M3 effectief de doorsnede L ∩ R. P
De reden voor het feit dat de doorsnede van de contextvrije taal L met de reguliere taal R herkend kan worden door de PDA M3 ligt in het feit dat de EDA geen stapel nodig heeft.
Stelling 11.9 Het verschil L1 \ L2 van een contextvrije taal L1 met een reguliere taal L2 is opnieuw contextvrij.
BEWIJS: Het verschil L1 \ L2 is gelijk aan L1 ∩ ¬L2.
Als de taal L2 regulier is, dan is ook het complement ¬L2 regulier. Toepassing van de vorige stelling op de contextvrije taal L1 en de regu-
liere taal ¬L2 leert ons dat de doorsnede L1 ∩ ¬L2 = L1 \ L2 regulier is. P Een mooie toepassing van de vorige stelling is geformuleerd in het vol-
gende voorbeeld.
Voorbeeld 11.3.1 Beschouw de contextvrije taal AnBn = {anbn : n ∈ N}. Stel nu dat je een contextvrije taal beschouwt, op een eindig aantal
uitzonderingen na. Bijvoorbeeld: beschouw de taal L={anbn :n∈N en n̸=1776},
dan is ook deze taal L contextvrij.
Want de taal L is te schrijven als L = AnBn \ {a1776b1776}.
De taal AnBn is het klassieke voorbeeld van een contextvrije taal, en de
taal {a1776b1776} is regulier, want elke eindige taal is regulier (Stelling 6.6). Dus de vorige stelling leert ons dat de taal L ook contextvrij is.
11.4 Heuristieke methodes om het contextvrij of niet-contextvrij zijn van talen aan te tonen
Net zoals bij reguliere talen kan er geen algoritme gegeven worden dat voor elke taal kan toegepast worden om aan te tonen dat deze taal contextvrij of niet-contextvrij is. Hier is het opnieuw belangrijk om voorbeelden te bekijken en oefeningen te maken om expertise op te bouwen in het aantonen of weerleggen van het contextvrij zijn van een taal.
We geven nu enkele voorbeelden van methodes om het niet-contextvrij zijn van talen aan te tonen, gebaseerd op de kennis van andere voorbeelden van talen.
Voorbeeld 11.4.1 Beschouw de taal W W = {ww : w ∈ {a, b}∗}.
In deze taal herkennen we seri ̈ele afhankelijkheden, dus intu ̈ıtief is deze
taal niet-contextvrij (Figuur 11.4).
172
Dit kan effectief, formeel correct, op de volgende manier aangetoond wor- den.
Stel dat de taal L = WW contextvrij is, dan is zijn doorsnede met de reguliere taal a∗b∗a∗b∗ ook contextvrij (Stelling 11.8).
Maar
L′ =WW ∩a∗b∗a∗b∗ ={anbmanbm :n,m∈N}.
En op deze taal L′ kan het pompend lemma voor contextvrije talen toe- gepast worden, via het woord w = akbkakbk, leidend tot de contradictie dat de taal L′ niet-contextvrij is.
Dus de onderstelling dat de taal L = W W contextvrij is, blijkt verkeerd te zijn.
Voorbeeld 11.4.2 Beschouw de taal
L = {w ∈ {a,b,c}∗ : #a(w) = #b(w) = #c(w)}.
Deze taal is niet-contextvrij. Intu ̈ıtief kan dit ingezien worden via het feit dat de taal AnBnCn zelf niet-contextvrij is.
Het niet-contextvrij zijn van de taal L kan effectief, formeel correct, aangetoond worden door gebruik te maken van het gekende feit dat de taal AnBnCn zelf niet-contextvrij is.
Want stel dat de taal L contextvrij is, dan is zijn doorsnede met de reguliere taal a∗b∗c∗ ook contextvrij (Stelling 11.8). Maar deze doorsnede L′ = L ∩ a∗b∗c∗ = AnBnCn, en deze taal is niet-contextvrij.
Dus de onderstelling dat de taal L = {w ∈ {a, b, c}∗ : #a(w) = #b(w) = #c(w)} contextvrij is, blijkt verkeerd te zijn.
11.5 Deterministische PDA
Uit de studie van de sluitingseigenschappen voor contextvrije talen, gemaakt in Sectie 11.3, kunnen we ons nu afvragen waarom de contextvrije talen niet gesloten zijn onder complement, doorsnede en verschil, terwijl de reguliere talen dit wel zijn.
Dit volgt heel sterk uit het feit dat elke niet-deterministische eindige au- tomaat een equivalente deterministische automaat heeft.
Beschouw de taal L aanvaard door een niet-deterministische eindige au- tomaat M, dan kan deze taal L aanvaard worden door een bijhorende equi- valente eindige deterministische automaat M′. Verwissel nu in deze EDA M′ de aanvaardende en niet-aanvaardende toestanden, dan hebben we een nieuwe EDA M′′ die het complement ¬L van de taal L aanvaardt.
Dus hier zien we dat het deterministisch karakter van EDAs een heel cruciale rol speelt, en in dit Deel 2 bespreken we niet-deterministische PDA.
Om deze redenen bekijken we nu eens deterministische PDA. 173
￼￼￼￼￼￼￼Definitie 11.5.1 Een PDA M is deterministisch als en slechts als:
• de transitierelatie ∆ van M bevat geen transities die met elkaar in
competitie kunnen treden,
• als M in een aanvaardende configuratie is, dan zijn er geen transities meer mogelijk.
Voorbeeld 11.5.2 Het volgende voorbeeld is een heel eenvoudig voorbeeld van een niet-deterministische PDA. Deze PDA kan namelijk kiezen tussen aanvaarden of een ε-transitie uitvoeren.
Figuur 11.6: Niet-deterministische PDA
Nu hebben we de definitie gegeven van een deterministische PDA, maar wat is nu de definitie van een deterministische contextvrije taal?
Definitie 11.5.3 Een taal L is deterministisch contextvrij als en slechts als de taal L$ aanvaard kan worden door een deterministische PDA.
Het symbool $ is een end-of-string marker, dus een einde-reeks-symbool. Dus in de taal L$ moet er na elke zin een end-marker staan.
Waarom voeren we een end-of-string marker in? We leggen dit uit via het volgende voorbeeld.
Beschouw de taal
L=a∗ ∪{anbn :n∈N\{0}}.
Deze taal L kan aanvaard worden door de niet-deterministische PDA in Figuur 11.7.
Deze PDA begint altijd met het lezen van letters a. Het moet deze letters a op de stapel plaatsen, want als deze letters a uit een woord anbn komen, dan moet deze PDA kunnen controleren dat het aantal b’s gelijk is aan het aantal a’s.
Maar als deze a’s uit een woord uit de taal a∗ komen, dan moet de PDA niet controleren hoeveel b’s er zijn; de PDA moet enkel de a’s van de stapel halen en de stapel leegmaken.
174
￼
￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼Figuur 11.7: Niet-deterministische PDA
Zonder een end-of-string-marker is er geen manier om dat afhalen/poppen van de a’s van de stapel te laten gebeuren als alle inputkarakters gelezen zijn.
De PDA in Figuur 11.8 is een deterministische PDA die de taal L$ = a∗$ ∪ {anbn$ : n ∈ N} aanvaardt. Controleer zeker dat deze PDA voldoet aan de voorwaarden van Definitie 11.5.1.
Figuur 11.8: DPDA voor L$
Nu kan er natuurlijk opgemerkt worden dat er een end-of-string marker $ gebruikt wordt in Definitie 11.5.1. De vraag kan gesteld worden of deze end-of-string marker $ mogelijks de eigenschappen van talen verandert. Dit is niet het geval bij de contextvrije talen. De end-of-string marker $ zal nooit een taal L die niet-contextvrij is, omzetten in een taal L$ die wel contextvrij is.
Het voorbeeld hieronder toont eerst een deterministische PDA voor de taal L met de end-of-string marker $, en daarna een niet-deterministische PDA voor de taal L. Het idee dat gebruikt wordt in de niet-deterministische
175
￼
￼￼￼￼￼￼￼￼￼￼￼PDA is dat je gokt waar het einde van de zin is, en dan doe je de a’s die nog overbleven op de stapel allemaal weg.
Figuur 11.9: L is contextvrij als en slechts als L$ is contextvrij
We hebben in de inleiding van deze sectie vermeld dat determinisme een heel cruciale rol speelt bij de sluitingseigenschap complement.
We tonen nu aan dat de deterministische contextvrije talen gesloten zijn onder complementering.
Stelling 11.10 De deterministische contextvrije talen zijn gesloten onder complementering.
BEWIJS: Het bewijs verloopt opnieuw via de PDA M die deze deter- ministische contextvrije taal aanvaardt.
Gegeven deze PDA M, wensen wij:
• M te vervolledigen,
• de aanvaardende en de niet-aanvaardende configuraties om te wisselen, • de taal (¬L)$ te aanvaarden.
Dit is nog altijd niet eenvoudig bij een deterministische PDA, want een deterministische PDA kan een inputreeks w niet aanvaarden om verschil- lende redenen:
• de berekening van deze PDA kan eindigen voor de inputreeks w volle- dig gelezen is.
176
￼￼￼￼￼
• de berekening van deze PDA kan eindigen in een aanvaardende toe- stand, maar de stapel is nog niet leeg.
• de berekening van deze PDA kan in een oneindige lus terechtkomen, bijvoorbeeld door ε-transities te volgen, zonder ooit te stoppen in een aanvaardende of niet-aanvaardende toestand.
• de berekening kan eindigen in een niet-aanvaardende toestand.
Als we enkel de aanvaardende en de niet-aanvaardende toestanden ver- wisselen in de PDA M, dan zullen alle zinnen uit de taal L$ niet meer aanvaard worden (dus dat is goed), maar we aanvaarden niet-noodzakelijk alle zinnen uit de taal (¬L)$.
Maar de problemen die hierbij optreden, kunnen opgelost worden zodat toch enkel de zinnen uit de taal (¬L)$ aanvaard worden. P
We hebben nu bewezen dat de DCFLs (deterministische contextvrije talen) gesloten zijn onder complementering. Maar hoe zit het met de slui- tingseigenschappen doorsnede en unie?
Stelling 11.11 De deterministische contextvrije talen zijn niet gesloten on- der de unie.
BEWIJS: We geven een tegenvoorbeeld. De twee talen
en
L1 ={aibjck :i,j,k∈Neni̸=j} L2 ={aibjck :i,j,k∈Nenj̸=k}
zijn deterministische contextvrije talen (DCFLs). We kijken of hun unie
L′ =L1∪L2 ={aibjck :i,j,k∈Nen((i̸=j)of(j̸=k))} deterministisch contextvrij is.
Als deze taal L′ deterministisch contextvrij is, dan is zijn complement
L′′ = ¬L′
= {aibjck :i,j,k∈Neni=j=k}∪
{w ∈ {a, b, c}∗ : de letters staan niet in alfabetische volgorde} ook deterministisch contextvrij (Stelling 11.10), en dus contextvrij.
Dan is de doorsnede L′′′ van L′′ met de reguliere taal a∗b∗c∗, dus L′′′ =L′′ ∩a∗b∗c∗ ={anbncn :n∈N}
177
￼￼￼￼￼￼￼￼￼￼￼￼ook contextvrij (Stelling 11.8).
Maar deze taal L′′′ is ons klassiek voorbeeld van een taal die niet-
contextvrij is.
Dus er is een verkeerde onderstelling gemaakt: de unie L′ = L1 ∪ L2 van
de twee deterministische contextvrije talen L1 en L2 is niet deterministisch contextvrij. P
Bemerk het subtiele verschil tussen de vorige stelling en Stelling 11.4:
de verzameling deterministische contextvrije talen is niet ge- sloten onder de unie, maar de verzameling van alle contextvrije talen is wel gesloten onder de unie.
Stelling 11.12 De deterministische contextvrije talen zijn niet gesloten on- der de doorsnede.
BEWIJS: We geven een tegenvoorbeeld. De twee talen
L1 ={aibjck :i,j,k∈Neni=j} L2 ={aibjck :i,j,k∈Nenj=k}
en
zijn deterministische contextvrije talen (DCFLs).
In Figuur 11.10 zien we een DPDA die de taal L1$ aanvaardt.
Figuur 11.10: DPDA die L1$ aanvaardt Hun doorsnede
L′ =L1 ∩L2 ={aibici :i∈N}
is ons klassiek voorbeeld van een taal die niet-contextvrij is. P
178
￼
Nu geven we een expliciet voorbeeld van een niet-deterministische con- textvrije taal, om expliciet aan te tonen dat de verzameling van de de- terministische contextvrije talen een strict kleinere verzameling is dan de verzameling van alle contextvrije talen.
Stelling 11.13 Er bestaan contextvrije talen (CFLs) die niet determinis- tisch zijn.
BEWIJS: We geven een expliciet voorbeeld. Beschouw de taal L = {aibjck : i,j,k ∈ N,i ̸= j of j ̸= k}
is contextvrij.
Stel dat deze taal L deterministisch contextvrij (DCFL) is, dan is ook
zijn complement
L′ = ¬L
= {aibjck :i,j,k∈Neni=j=k}∪
{w ∈ {a, b, c}∗ : de letters staan niet in alfabetische volgorde}
deterministisch contextvrij (Stelling 11.10).
Maar als L′ deterministisch contextvrij is, dan is deze taal L′ contextvrij,
en is zijn doorsnede met de reguliere taal a∗b∗c∗ ook contextvrij, dus L′′ =L′ ∩a∗b∗c∗ ={anbncn :n∈N}
is ook contextvrij (Stelling 11.8).
Maar deze taal L′′ is ons klassiek voorbeeld van een taal die niet-contextvrij
is.
Dus er is opnieuw een foutieve onderstelling gemaakt. De taal L die
contextvrij is, is niet-deterministisch contextvrij. P
Dus, via de vorige stelling, zijn we nu 100% zeker dat er niet-deterministische contextvrije talen bestaan. Daarnaast hebben we het begrip inherent dub- belzinnige grammatica ingevoerd. Ook hier zijn er subtiele verschillen, zoals
de volgende bespreking aantoont.
• De taal
L1 ={aibjck :i,j,k∈Nen((i=j)of(j=k))} is gelijk aan de taal
{anbncm :n,m∈N}∪{anbmcm :n,m∈N}.
Deze taal is inherent dubbelzinnig, want het woord aabbcc behoort tot de beide talen die de unie vormen, dus kan dit woord steeds via de herschrijfregels van deze beide talen bekomen worden.
179
• De taal
L2 ={anbncmd:n,m∈N}∪{anbmcme:n,m∈N}
is echter niet inherent dubbelzinnig, maar een deterministische PDA kan de taal L2$ niet aanvaarden, want een PDA moet, bijvoorbeeld, altijd gokken bij het verwerken van de eerste karakter van de input aabbccd. Bij het inlezen van de eerste a uit aabbccd kan deze PDA onmogelijk weten of het laatste symbool een d of een e is.
De hiervoor gevoerde bespreking toont opnieuw aan hoe voorzichtig er met de verschillende begrippen, gedefinieerd in dit deel over stapelautomaten en contextvrije talen, omgegaan dient te worden.
180
Hoofdstuk 12
Algoritmes en beslissingsprocedures voor contextvrije talen
12.1 Inleiding
Net zoals bij reguliere talen eindigen we dit deel over contextvrije talen met beslissingsprocedures voor contextvrije talen.
Bij de bespreking van de beslissingsprocedures voor contextvrije talen, maak steeds de vergelijking met de analoge beslissingsprocedures voor regu- liere talen om de verschillen in te zien. We herhalen eerst de definitie van een beslissingsprocedure.
Definitie 12.1.1 Een beslissingsprocedure is een algoritme voor de oplos- sing van een probleem, en waarvan het resultaat een Booleaanse waarde is.
12.2 Beslissingsprocedures voor contextvrije talen
Vraag 1: Gegeven een contextvrije taal L en een reeks w, behoort w tot deze taal L?
Deze vraag kan positief beantwoord worden voor elke contextvrije taal L. In principe kunnen er opnieuw twee benaderingen gebruikt worden, maar bij beide is er een probleem.
• Benadering 1: Als de taal L contextvrij is, dan bestaat er een con- textvrije grammatica G voor deze taal L. Probeer gewoon de her- schrijfregels toe te passen en kijk of er een eindige reeks herschrijfregels tot de reeks w leidt.
181
Dit idee is goed, maar stel dat je het toepast op de contextvrije taal L, met als enige herschrijfregel S → ST|a, en probeert te controleren of het woord aaa tot de taal L behoort.
• Benadering 2: Als de taal L contextvrij is, dan bestaat er een sta- pelautomaat M die deze taal aanvaardt. Laat deze stapelautomaat M de reeks w verwerken.
Dit idee is opnieuw goed, maar bij een PDA kun je in een oneindige lus terechtkomen. Wat dan?
Het is duidelijk dat er grondiger over deze vraag nagedacht dient te worden.
We geven eerst de oplossing voor benadering 1, via de procedure deci- deCFLusingGrammar.
decideCFLusingGrammar(L: CFL, w: string) =
1. Als er een PDA gegeven is voor de taal L, stel de grammatica G op
zodat L(G) = L(M).
2. Als w = ε, dan als het startsymbool SG nullable is, geef dan accept
terug, anders geef reject terug.
3. Alsw̸=ε,
(a) Construeer de grammatica G′ in Chomsky normale vorm (Defi- nitie 9.2.1) zodat L(G′) = L(G) \ {ε}.
(b) Als de grammatica G′ de reeks w genereert, dan zal deze gram- matica G′ dit doen in 2|w| − 1 stappen. (Bewijs dit als oefening). Probeer daarom alle afleidingen in de grammatica G′ die 2|w| − 1 stappen vereisen. Als  ́e ́en van hen de reeks w afleidt, geef dan accept terug, anders geef reject terug.
Nu bespreken we de tweede benadering, via een stapelautomaat.
Beschouw opnieuw het algoritme CFGtoPDAtopdown dat leidde van de contextvrije grammatica G naar de bijhorende PDA M (Sectie 10.7). Zie ook Figuur 12.1.
Hier is de PDA
M = ({p,q},Σ,V,∆,p,{q}), waarbij de transitierelatie ∆ de volgende transities bevat:
• de starttransitie ((p, ε, ε), (q, S)).
• VoorelkeherschrijfregelX→s1···sninR,detransitie((q,ε,X),(q,s1···sn)).
182
￼￼￼￼Figuur 12.1: CFGtoPDAtopdown
• Voor elke karakter c ∈ Σ, de transitie ((q, c, c), (q, ε)).
De vraag kan gesteld worden of dit ook gerealiseerd kan worden zonder ε-transities. Als elke transitie een karakter uit de input w moet verwerken, dan moet deze PDA M stoppen na |w| stappen.
Dit kan, maar dan dienen we de Greibach normale vorm (Definitie 9.2.2) te gebruiken.
In de Greibach normale vorm zijn alle herschrijfregels van de vorm:
X → aA,
meta∈ΣenA∈(V \Σ)∗.
Hier zien we dat het niet nodig is om eerst de karakter a op de stapel
te pushen en ze dan onmiddellijk te poppen van de stapel. We maken de herschrijfregels effici ̈enter:
M = ({p,q},Σ,V,∆,p,{q}), waarbij de transitierelatie ∆ de volgende transities bevat:
• de starttransities: Voor elke herschrijfregel S → cs2···sn in R, de transitie ((p, c, ε), (q, s2 · · · sn)).
• Voor elke herschrijfregel X → cs2 ···sn in R, met c ∈ Σ en s2,...,sn ∈ V \Σ, de transitie ((q,c,X),(q,s2 ···sn)).
Daar we weten dat een PDA, die geen ε-transities heeft, moet stoppen, kunnen we nu het volgende algoritme opstellen om te testen of de input w tot de contextvrije taal L behoort, via de bijhorende PDA M.
Voer de PDA M uit op de input w:
• Elk individueel pad van de PDA M moet stoppen na |w| stappen.
• Het totaal aantal paden dat de PDA M dient te volgen, is hoogstens gelijk aan P = B|w|, met B het maximaal aantal transities waaruit de PDA M kan kiezen in elke toestand.
• Het totaal aantal stappen dat deze PDA M dient uit te voeren, om te testen of de input w tot de taal L = L(M) behoort, is hoogstens gelijk aan P · |w|.
183
Dus dit algoritme zal zeker eindigen.
We formaliseren deze tweede benadering in het volgende algoritme deci-
deCFLusingPDA.
decideCFLusingPDA(L : CFL, w : string) =
1. Als de taal L gegeven is via zijn PDA, gebruik PDAtoCFG om een grammatica G op te stellen zodat L(G) = L(M).
2. Als de taal L gegeven is via zijn grammatica G, ga naar de volgende instructie met deze grammatica G.
3. Als w = ε, dan als SG nullable is, geef accept terug, anders geef reject terug.
4. Als w ̸= ε, dan:
(a) Construeer vanuit de grammatica G de grammatica G′ in Grei-
bach normale vorm zodat L(G′) = L(G) \ {ε}.
(b) Construeer vanuit deze grammatica G′ een PDA M′ zodat L(M′) =
L(G′) en zodat deze PDA M′ geen ε-transities bezit.
(c) Alle mogelijke paden die de PDA M′ kan doorlopen, zullen zeker eindigen. Laat deze PDA M′ de input w verwerken. Geef accept terug als de PDA M′ de input w aanvaardt, anders geef reject terug.
Vraag 2: Gegeven een contextvrije taal L, is L = ∅?
Deze vraag kan beantwoord worden via het volgende algoritme deci-
deCFLempty.
 decideCFLempty(G: contextvrije grammatica) =
    1. Stel G’=removeunproductive(G).
    2. Als het startsymbool S ontbreekt in G’, geef TRUE terug,
                                        anders geef FALSE terug.
Vraag 3: Gegeven een contextvrije taal L, is L oneindig groot?
Deze vraag kan beantwoord worden via het volgende algoritme deci-
deCFLinfinite.
decideCFLinfinite(G : contextvrije grammatica) =
1. Schrijf lexicografisch alle reeksen uit Σ∗ op met lengte groter dan bn en kleiner dan of gelijk aan bn+1 + bn.
184
2. Alsvoorminstens ́e ́endergelijkereeksw,hetalgoritmedecideCFL(L,w) TRUE teruggeeft, geef dan ook TRUE terug, want dan is de taal L oneindig groot.
3. Als voor al deze reeksen w, het algoritme decideCFL(L,w) FALSE teruggeeft, geef dan ook FALSE terug, want dan is de taal L niet oneindig groot.
Vraag: verklaar de grenzen op de grootte die gebruikt worden.
Vraag 4: Zijn twee deterministische contextvrije talen equivalent?
Voor deze vraag is er een beslissingsprocedure.
Stelling 12.1 Gegeven twee deterministische contextvrije talen L1 en L2, dan bestaat er een beslissingsprocedure om te bepalen of L1 = L2.
BEWIJS: Dit werd bewezen door S ́enizergues in 2001. Wegens de moei- lijkheidsgraad van het bewijs behandelen we dit niet in dit opleidingsonder- deel. P
Voor de vorige vragen over contextvrije talen zijn er beslissingsprocedu- res. Er zijn echter ook niet-beslisbare vragen betreffende contextvrije talen. Hierna vermelden we enkele van deze niet-beslisbare vragen.
Stelling 12.2 Volgende vragen over contextvrije talen zijn onbeslisbaar.
• Is L = Σ∗?
• Is L regulier?
• Is L1 = L2?
• Is L1 ⊆ L2?
• Is L1 ∩ L2 = ∅?
• Is L inherent dubbelzinnig? • Is G dubbelzinnig?
185
.
Deel 3
Turing machines, recursief aftelbare grammatica’s, en semibeslisbare talen
186
Hoofdstuk 13 Turing machines
13.1 Inleiding
Figuur 13.1: De Turing machine
Nu starten we in Deel 3 de studie van, volgens vele mensen, het beste computermodel dat er bestaat, de Turing machine. Deze machine werd in 1936 opgesteld door de engelse wiskundige Alan Turing.
De biografie over Alan Turing, die als pdf file beschikbaar gesteld is op minerva, is 8 blz. lang, en is zeker de moeite waard om te lezen. Heel veel kan verteld worden over het leven van Alan Turing, niet alleen over zijn werk als wiskundige en over zijn fundamentele bijdragen tot de ontwikkeling van de computer, maar ook over het (geheime) werk dat hij in de tweede wereldoorlog verricht heeft, samen met andere wiskundigen en vele andere mensen, in Bletchley Park, en ook over wat hij meegemaakt heeft op het einde van zijn leven.
Voortdurend wordt er hernieuwde aandacht aan Alan Turing besteed, of wordt om aandacht en waardering voor het werk van Alan Turing ge- vraagd. Dit komt soms uit totaal onverwachte hoek. Op woensdag 14 ja- nuari 2015 vond de premi`ere plaats van de film The imitation game over Alan Turing. De popgroep Pet Shop Boys schreven zelfs een werk over Alan Turing, dat de titel kreeg A Man from The Future. Op de website https://www.youtube.com/watch?v=bdzuwWM9sW0 hoort u Neil Tennant
187
￼
van Pet Shop Boys vertellen over het leven van Alan Turing en hoort u het muziekstuk He dreamed of machines uit A Man from The Future. Andrew Hodges schreef een boek over Alan Turing.
Lees nogmaals zeker de biografie over Alan Turing, en zoek zeker infor- matie op het internet over Alan Turing. Merk ook op dat je onbewust de machine zal gebruiken om deze informatie over Alan Turing te vinden op het internet, namelijk de computer.
Het doel dat Alan Turing vooropstelde en dat we ook zelf vooropstellen, is heel groot:
Kunnen we een nieuw soort automaat maken die de volgende twee eigen- schappen heeft:
• performant genoeg om alle berekenbare zaken te kunnen beschrijven (in tegenstelling tot EDA en PDA die dit niet kunnen),
• eenvoudig genoeg zodat we over deze nieuwe soort automaat formeel kunnen redeneren, zoals bij EDA en PDA, wat niet gedaan kan worden bij een echte computer.
Het tweede item volgt uit het feit dat sommige problemen beter bestu- deerd worden op een theoretisch model van een computer. Wij zullen als  ́e ́en van onze hoofddoelen stellen binnen Deel 3, het bewijzen van resultaten over berekenbaarheid en niet-berekenbaarheid. Dit zullen we doen op het theore- tisch model van de Turing machine. We zullen dit niet doen op een echte computer, want bij een computer is het geheugen beperkt in capaciteit, dus daar komt het probleem erbij van: heeft de computer wel voldoende geheu- gen om de berekeningen uit te voeren?, en bij een computer is er een limiet op de snelheid waarmee de berekeningen uitgevoerd kunnen worden, dus hier komt het probleem erbij van: hoeveel tijd zal de computer nodig hebben om de berekeningen uit te voeren?. Deze twee laatste vragen horen bij het probleem van de complexiteit, meer precies tijds- en ruimtecomplexiteit van een berekenbaar probleem, en dit zijn vragen die pas hoeven bestudeerd te worden als het zeker is dat een probleem berekenbaar is op een computer.
Een andere reden om te redeneren met het computermodel Turing ma- chine voor een echte computer is:
als we kunnen bewijzen dat bepaalde problemen niet opgelost kunnen wor- den met een Turing machine, dan kunnen we hieruit inzicht krijgen in wat een echte computer wel kan oplossen voor ons.
Want ook hier bij de Turing machine zal gelden: niet alle problemen zijn berekenbaar op een Turing machine. Het klassieke voorbeeld zal het stop probleem, ook halting problem genoemd, zijn.
Nu gaan we over tot de definitie van een Turing machine. 188
￼￼￼13.2 De Turing machine
De Turing machine is een automaat die een oneindige band gebruikt, onein- dig naar links en oneindig naar rechts. Deze band is verdeeld in vierkantjes, waarin een symbool opgeslagen kan worden. Als er geen symbool in een vier- kantje staat, dan zeggen we dat het blanco symbool binnen in het vierkantje staat.
Figuur 13.2: Oneindige band van Turing machine
Hier volgt nu al een belangrijke opmerking betreffende het gebruik van de Turing machine:
alhoewel de band zich oneindig uitstrekt naar links en zich oneindig uitstrekt naar rechts, mogen op ieder moment van de be- rekeningen, bij het begin, midden, of einde van de berekeningen, maar een eindig aantal vakjes een niet-blanco symbool bevatten.
Dus alle vierkantjes op de oneindig grote band, op een eindig aantal na, moeten blanco zijn.
Deze voorwaarde volgt uit het feit dat een echte computer een eindig geheugen heeft, en de Turing machine moet een model zijn voor de echte computers.
Nu kan de vraag gesteld worden:
waarom een oneindig grote band gebruiken, als je er maar een eindig gedeelte van mag gebruiken?
De verklaring ligt in het feit dat Alan Turing, en ook wij, ons geen zorgen willen maken over: zal het geheugen wel groot genoeg zijn om de berekenin- gen uit te voeren?. We wensen nogmaals de Turing machine te gebruiken om inzicht te krijgen in wat echte computers kunnen berekenen.
Hoe kunnen de vierkantjes gelezen worden? Intu ̈ıtief kunnen we dit voorstellen via een locomotief die zich beweegt op de oneindige band. De locomotief staat altijd op een vierkantje van de oneindige band, en we kunnen
189
￼￼￼
het vierkantje onder de locomotief lezen. Dit wordt geillustreerd door Figuur 13.3.
Figuur 13.3: Locomotief (read/write head) op oneindige band van Turing machine
Op Figuur 13.2 wordt de positie van deze locomotief door de pijl aange- duid.
Nu volgt de formele definitie van een Turing machine.
Definitie 13.2.1 Een Turing machine (TM) M is een 6-tal (K, Σ, Γ, δ, s, H),
met:
• K is de eindige verzameling toestanden,
• Σ is het inputalfabet, dat niet het blancosymbool P bevat,
• Γ is het tape alfabet van de symbolen die op de oneindige band geplaatst mogen worden. Hier moet het tape alfabet Γ het blanco symbool P bevatten, en moet het inputalfabet Σ een deelverzameling zijn van het tape alfabet Γ,
• s ∈ K is de starttoestand,
• H ⊆ K is de verzameling stoptoestanden,
• δ is de transitiefunctie die de werking van de Turing machine M be- schrijft:
δ : (K \ H) × Γ → K × Γ × {→, ←} Hier kan elke transitie beschreven worden als een 5-tal
((qi,Sj),(qk,Sl,→ of ←)),
met qi een niet-stoptoestand, Sj een tape karakter, en qk een toestand, Sl een tape karakter, en → of ← betekent dat de Turing machine  ́e ́en vierkantje naar rechts of naar links dient te gaan op de oneindige band.
Deze instructie ((qi,Sj),(qk,Sl,→ of ←)) wordt het eenvoudigst ge- lezen via een als ... dan zin:
als de Turing machine M zich in toestand qi bevindt en Sj is het sym- bool in het vierkantje onder de locomotief op de oneindige baan, dan
190
￼
mag de Turing machine zich naar toestand qk begeven, het symbool Sj in het vierkantje onder de locomotief schrappen en vervangen door het tape symbool Sl, en zich daarna  ́e ́en vierkantje naar rechts (→) of zich  ́e ́en vierkantje naar links (←) begeven.
Opmerking 13.2.2 Hier vestigen we nogmaals de aandacht op enkele be- langrijke zaken in de definitie van een Turing machine.
• De transitiefunctie δ is een functie, geen relatie. Dus deze definitie is de definitie van een deterministische Turing machine.
De niet-deterministische Turing machines zullen later bestudeerd wor- den.
• De transitiefunctie δ moet gedefinieerd worden voor alle (toestand, in- put) paren, tenzij de toestand een stoptoestand is.
• Turing machines stoppen niet altijd. Een Turing machine kan enkel stoppen in een stoptoestand. Bevindt de Turing machine zich niet in een stoptoestand, dan moet deze verder werken.
• Turing machines kunnen een output genereren, dus zij kunnen gebruikt worden om functies te berekenen.
Nu geven we een voorbeeld van een Turing machine. Opnieuw wordt de Turing machine voorgesteld door een graaf.
Voorbeeld 13.2.3 De Turing machine M krijgt als input een reeks uit de taal
{aibj :0≤j≤i},
en moet b’s aan het einde toevoegen om het aantal b’s gelijk te maken aan het aantal a’s.
De input voor M ziet er uit als op de eerste figuur in Figuur 13.4, en de output moet er uitzien zoals op de tweede figuur in Figuur 13.4. De feitelijke Turing machine staat beschreven als graaf in Figuur 13.5.
De Turing machine is een ingewikkelder machine dan een PDA, die zelf ingewikkelder is dan een EDA. We zien dit al als we gaan kijken of een Turing machine zeker stopt voor een input w. In de bespreking hieronder geven we het resultaat voor alle drie de types automaten.
• Een EDA M, die input w moet verwerken, stopt zeker na |w| stappen.
• Een PDA M, die input w moet verwerken, is niet zeker te stoppen voor input w. We hebben dit reeds besproken voor de PDA M in Figuur 10.25, zie Voorbeeld 10.8.1, die herhaald is in Figuur 13.6.
191
￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼Figuur 13.4: Input en output op de oneindige band
Figuur 13.5: Turing machine om aibj om te zetten in aibi
Maar bij PDAs kun je wel een algoritme toepassen dat de PDA omzet in een equivalente PDA M′ die zeker stopt. Dit algoritme steunde op de Greibach normale vorm voor contextvrije grammatica’s (zie Sectie 12.2).
• Een Turing machine M, die input w moet verwerken, is niet zeker te stoppen voor input w.
Er bestaat ook geen algoritme om een Turing machine M om te zetten in een equivalente Turing machine M′ die zeker zal stoppen.
Nu geven we opnieuw enkele definities om het correct redeneren met de Turing machines mogelijk te maken.
192
￼￼
￼￼￼Figuur 13.6: PDA voor taal L(M) = {a}
Figuur 13.7: Compacte notatie voor configuratie van Turing machine
Definitie 13.2.4 Een configuratie van een Turing machine M = (K, Σ, Γ, δ, s, H ) is een 4-tal uit
K ×(((Γ\{P})Γ∗)∪{ε})×Γ×((Γ∗(Γ\{P}))∪{ε}).
Concreet betekent de configuratie (q, s1, b, s2) van de Turing machine M
het volgende:
• q is de toestand waarin de Turing machine zich bevindt.
• s1 is wat er op de band staat links voor de locomotief.
• b is het symbool dat staat in het vierkantje onder de locomotief. • s2 is wat er op de band staat rechts van de locomotief.
We zullen de configuratie van een Turing machine M echter compacter voorstellen als een koppel. Dit wordt geillustreerd door Figuur 13.7.
Daarin zien we twee configuraties voorgesteld als 4-tal en, verkort, als koppel. We blijven de toestand waarin de Turing machine zich bevindt in de eerste positie schrijven. Daarna schrijven we s1, b, s2 na elkaar als s1bs2 waarbij we het symbool in het vierkantje onder de locomotief onderlijnen, zodat we de exacte positie van de locomotief op de oneindige band kennen.
Nu kunnen we ook de startconfiguratie defini ̈eren. 193
￼￼￼￼￼
Definitie 13.2.5 De startconfiguratie van een Turing machine is gelijk aan (s, Pw).
Uit de definitie van startconfiguratie zien we dat bij het begin van de berekeningen, de input w zich op de band bevindt, en dat de locomotief zich op het vierkantje links, net voor, de input w bevindt.
Nu geven we de definities om de werking van een Turing machine correct te beschrijven.
￼Definitie 13.2.6
genoteerd als
als de configuratie toepassen van  ́e ́en
Stel nu ⊢∗M de Definitie 13.2.7
dat:
De configuratie (q1 , w1 ) leidt tot de configuratie (q2 , w2 ), (q1,w1)⊢M (q2,w2),
(q2,w2) te bereiken is uit de configuratie (q1,w1) door het transitie uit de transitiefunctie δ.
reflexieve, transitieve sluiting van ⊢M .
De configuratie C1 leidt tot de configuratie C2 als er geldt
(q1,w1)⊢∗M (q2,w2).
Een pad uitgevoerd door een Turing machine M is een reeks configuraties C0,C1,...,Cn, voor een zekere n ≥ 0, zodat C0 de startconfiguratie is en zodat
C0 ⊢M C1 ⊢M ···⊢M Cn.
Een berekening uitgevoerd door de Turing machine M is een pad dat stopt, dus eindigt in een stoptoestand q ∈ H.
Als een berekening n stappen vereist, dan noteren we dit met: C0 ⊢nM Cn.
We hebben in Figuur 13.5 al een voorstelling gegeven van een Turing machine M. Deze figuur is al complex.
Om de grafen die Turing machines voorstellen overzichtelijk te houden, zullen we nu enkele notaties afspreken voor Turing machines die standaard- bewerkingen uitvoeren. We defini ̈eren eerst enkele heel basis Turing machi- nes.
• Turing machine die een symbool schrijft: Voor elke x ∈ Γ, defi- nieer Mx, ook verkort genoteerd met x, als de Turing machine die het symbool x op de band schrijft.
• Turing machines die bewegingen uitvoeren: 194
– R ( ́e ́en vakje naar rechts): voor elke x ∈ Γ: δ(s, x) = (h, x, →). – L ( ́e ́en vakje naar links): voor elke x ∈ Γ: δ(s, x) = (h, x, ←).
• Turing machines die stoppen:
– h: Turing machine die gewoon stopt.
– n: Turing machine die stopt en weigert.
– y: Turing machine die stopt en aanvaardt.
Nu maken we complexere Turing machines, gebouwd via eenvoudiger Turing machines die na elkaar uitgevoerd worden, of die uitgevoerd worden als een bepaalde voorwaarde voldaan is.
• TMM2 naTMM1
M1M2: begin in de starttoestand van TM M1, en laat M1 werken tot hij stopt. Stopt M1, begin dan TM M2 in zijn starttoestand zonder de locomotief (read/write head) te bewegen, en laat M2 werken tot hij stopt. Als M2 stopt, dan stopt de machine M1M2. Als echter minstens  ́e ́en van de machines M1 of M2 niet stopt, dan stopt ook de machine M1M2 niet.
• TM M2 na TM M1, mits voorwaarde voldaan <condition>
M1 −→ M2: begin in de starttoestand van TM M1, en laat M1 werken tot hij stopt. Stopt M1, controleer dan < condition >. Indien < condition > TRUE, begin dan TM M2 in zijn starttoestand zonder de locomotief (read/write head) te bewegen, en laat M2 werken tot hij stopt.
<condition>
Deze machine M1 −→ M2 stopt niet als: – ofwel M1 niet stopt, of
– < condition > is TRUE, maar M2 stopt niet. We geven een voorbeeld.
Voorbeeld 13.2.8 Beschouw de Turing machine in Figuur 13.8. De werking van de Turing machine in Figuur 13.8 gaat als volgt:
• Begin in de starttoestand van de TM M1.
• Laat TM M1 werken tot hij een stoptoestand bereikt (en dus stopt).
• Controleer het vierkantje onder de locomotief (read/write head). Als het gelezen symbool a is, laat TM M2 werken, en als het gelezen sym- bool b is, laat TM M3 werken.
195
￼￼￼￼￼Figuur 13.8: Compacte notatie voor Turing machine
• In beide gevallen begint de TM M2 of M3 in zijn starttoestand.
• Dan stopt de Turing machine als hij een stoptoestand bereikt.
• Als echter de TM M2 of M3, die uitgevoerd wordt, niet stopt, dan stopt de volledige Turing machine voorgesteld in Figuur 13.8 ook niet.
Nu geven we verdere verkorte notaties voor Turing machines. Hiervoor steunen we op de lespresentaties van E. Rich.
￼￼￼Figuur 13.9: Compacte notaties voor Turing machines I
Nu passen we deze verkorte notaties toe om twee concrete Turing ma- chines te construeren.
Voorbeeld 13.2.9 De eerste Turing machine krijgt een reeks  ́enen, w ∈ {1}∗, als input en dient deze input twee keer te copi ̈eren zodat w3 op de band komt te staan. Deze Turing machine is weergegeven in Figuur 13.12.
Voorbeeld 13.2.10 De tweede Turing machine (shifting machine), beschre- ven in Figuur 13.13, krijgt twee reeksen u en w als input op de band, ge- scheiden door  ́e ́en blanco P, en moet alle symbolen in de reeks w precies  ́e ́en vakje naar links opschuiven zodat dit blanco vierkantje tussen u en w verdwijnt.
196
￼￼￼￼￼Figuur 13.10: Compacte notaties voor Turing machines II
Figuur 13.11: Compacte notaties voor Turing machines III
Nu zullen we de definities geven van Turing machines als herkenners van talen.
We spreken af dat een input w zonder blanco symbolen op de band geschreven wordt. De startconfiguratie van de Turing machine is nogmaals gelijk aan (s, Pw).
De Turing machines die gebruikt worden als herkenners van talen hebben slechts twee stoptoestanden y (stop en aanvaard) en n (stop en weiger).
Beschouw de Turing machine M = (K, Σ, Γ, δ, s, H = {y, n}).
Definitie 13.2.11 De Turing machine M aanvaardt een inputreeks w als
￼￼￼en slechts als
voor een zekere reeks w′.
(s,Pw)⊢∗M (y,w′),
De Turing machine M weigert een inputreeks w als en slechts als
￼(s,Pw)⊢∗M (n,w′), 197
￼
￼￼￼￼￼￼Figuur 13.12: Compacte notatie voor Turing machine die input w omzet in w3
Figuur 13.13: Compacte notatie voor de shifting machine
voor een zekere reeks w′.
Definitie 13.2.12 Een Turing machine M beslist/decides een taal L ⊆ Σ∗
als en slechts als voor elke reeks w ∈ Σ∗ geldt dat:
• alsw∈L,danaanvaardtM deinputw,en
• alsw̸∈L,danweigertM deinputw.
Een taal L is beslisbaar als en slechts als er een Turing machine M bestaat die deze taal beslist. In dit geval noteren we dit met
L ∈ D,
met D de verzameling van alle beslisbare talen.
Merk op dat er een heel belangrijk feit staat in de definitie van een Tu- ring machine M beslist een taal L:
198
￼￼￼
￼￼￼De Turing machine M moet stoppen voor alle inputs w uit Σ∗, dus ook stoppen voor alle inputs w die niet tot L behoren, en TRUE teruggeven als w ∈ L en FALSE teruggeven als w ̸∈ L.
We geven nu twee voorbeelden van beslisbare talen.
Voorbeeld 13.2.13 Beschouw de taal
AnBnCn = {anbncn : n ∈ N}.
Deze taal wordt beslist door de Turing machine in Figuur 13.14.
Figuur 13.14: Turing machine die AnBnCn beslist
Voorbeeld 13.2.14 Beschouw de taal
WcW = {wcw : w ∈ {a,b}∗}.
Deze taal wordt beslist door de Turing machine in Figuur 13.15.
Zoals reeds opgemerkt, de definitie voor beslisbare taal L is een heel strenge definitie. De bijhorende Turing machine M die deze taal L beslist, moet voor alle inputs uit Σ∗, zowel zij die tot L behoren als zij die niet tot L behoren, stoppen en het correcte antwoord TRUE of FALSE geven.
We merken nu al op dat er talen zijn die niet beslisbaar zijn. Daarom is er een zwakkere definitie, van semibeslissen, ingevoerd.
Definitie 13.2.15 Een Turing machine M semibeslist een taal L ⊆ Σ∗ als en slechts als voor elke input w ∈ Σ∗:
• als w ∈ L, dan moet M de input w aanvaarden.
• als w ̸∈ L, dan mag M de input w niet aanvaarden. Als w ̸∈ L, dan moet M de input w weigeren of voor deze input w in een oneindige lus terechtkomen.
199
￼￼
￼￼￼￼￼￼Figuur 13.15: Turing machine die WcW beslist
Een taal L is semibeslisbaar als en slechts als er een Turing machine M bestaat die de taal L semibeslist.
We noteren met SD de verzameling van alle semibeslisbare talen.
We geven nu een voorbeeld van een Turing machine die een taal L semi-
beslist.
Voorbeeld 13.2.16 Beschouw de taal L = b∗a(a ∪ b)∗.
De Turing machine M in Figuur 13.16 semibeslist deze taal L.
Figuur 13.16: Turing machine die L = b∗a(a ∪ b)∗ semibeslist
Maar we kunnen deze taal ook beslissen. Dit wordt verwezenlijkt via de
Turing machine in Figuur 13.17.
We hebben reeds opgemerkt dat de Turing machine een output kan schrijven op de oneindige band. Dit impliceert dat een Turing machine ook functies kan berekenen.
We geven hiervoor nu de definities. Merk op dat in de definitie van een Turing machine die een functie berekent, er expliciet staat dat deze Turing machine maar  ́e ́en stoptoestand h bezit.
Definitie 13.2.17 Beschouw een Turing machine M = (K, Σ, Γ, δ, s, H = {h}) met starttoestand (s, Pw).
200
￼￼
￼￼￼￼￼￼￼￼Figuur 13.17: Turing machine die L = b∗a(a ∪ b)∗ beslist Definieer
M(w) = z ⇔ (s,Pw) ⊢∗M (h,Pz).
Zij Σ′ ⊆ Σ gelijk aan het outputalfabet van de Turing machine M.
Zij f een functie van Σ∗ naar Σ′∗.
Dan berekent de Turing machine M de functie f als en slechts als voor
alle w ∈ Σ∗:
• als w een input is waarop de functie f gedefinieerd is, dan moet M(w) =
f(w).
• Anders mag M niet stoppen voor input w.
Een functie f is berekenbaar/recursief als en slechts als er een Turing machine M bestaat die deze functie f berekent en altijd stopt.
Voorbeeld 13.2.18 We geven in Figuur 13.18 als voorbeeld van een bere- kenbare functie, de opvolgerfunctie succ(n) = n + 1.
We zullen de input n in binaire vorm voorstellen, zonder leidende nullen, dus n ∈ 0 ∪ 1{0, 1}∗.
Figuur 13.18: Turing machine die de opvolgerfunctie berekent
201
￼￼￼￼￼
Er zijn heel veel berekenbare functies. Maar niet alle functies zijn be- rekenbaar. Er zijn enkele klassieke voorbeelden. Zo zijn er de busy beaver functies S en Σ.
Beschouw de verzameling T van alle Turing machines die
• het tape alfabet Γ = {P, 1} hebben, en,
• stoppen met een volledig blanco band.
Dan worden de busy beaver functies S en Σ als volgt gedefinieerd:
• S(n): het maximum aantal stappen dat uitgevoerd wordt door een willekeurige Turing machine uit T met n niet-stoptoestanden, met een blanco band bij de start, voor zij stoppen.
• Σ(n): het maximum aantal 1 dat blijven staan op de band bij een willekeurige Turing machine uit T met n niet-stoptoestanden, wanneer zij stoppen.
De volgende tabel toont de waarden en ondergrenzen van S(n) en Σ(n) voor kleine n.
Er geldt nogmaals dat deze twee functies S en Σ niet berekenbaar zijn.
￼￼￼n
￼S (n)
￼Σ(n)
￼￼1 2 3 4 5 6
￼￼￼￼￼￼￼￼￼￼￼1
6 21 107
≥ 47176870 ≥ 3 · 101730
￼￼￼￼￼￼1
4
6
13
4098
≥ 1.29 · 10865
￼￼￼￼￼￼￼202
Hoofdstuk 14
Uitbreidingen van Turing machines
14.1 Inleiding
We hebben in het vorige hoofdstuk de deterministische Turing machine ge- definieerd.
Dit is een heel performante machine, ontworpen in 1936.
Maar natuurlijk hebben onderzoekers geprobeerd een betere machine te maken.
Tot op vandaag is er niemand die een beter model dan de Turing machine gevonden heeft. Vele andere machines kunnen exact hetzelfde als de Turing machine.
Sommige onderzoekers hebben het vermoeden geuit dat er geen beter model dan de Turing machine bestaat. Dit zal geformuleerd worden als de Church-Turing thesis die we zullen bespreken in Hoofdstuk 16.
We zullen in dit hoofdstuk enkele van deze alternatieve modellen bespre- ken, en aantonen dat
elk alternatief model een equivalente basismachine heeft.
We zullen ons concentreren op twee alternatieve Turing machines: • Turing machines met meerdere banden,
• Niet-deterministische Turing machines.
14.2 Turing machines met meerdere banden
Nu bespreken we Turing machines met een eindig aantal k aan banden. Figuur 14.1 toont een Turing machine met drie banden.
203
￼￼￼￼￼￼Figuur 14.1: Turing machine met drie banden
Om een correcte studie te kunnen maken van Turing machines met meer- dere banden, geven we eerst de definitie van een dergelijke Turing machine.
Definitie 14.2.1 De transitiefunctie voor een Turing machine met k ban- den wordt als volgt gedefinieerd:
(K \ H , Γ1 to (K , Γ1, {←, →, ↑} ,Γ2 ,Γ2,{←,→,↑}
.
, Γk)
, Γk, {←, →, ↑}).
Verder moet de input die deze Turing machine met k banden dient te verwerken, steeds geplaatst te worden op de eerste band, voor dat alle bere- keningen beginnen. Bij het begin van alle berekeningen dienen de tweede tot de kde band allemaal volledig blanco te zijn.
De output dient net zoals vroeger op de eerste band opgeslagen te worden. Wat er op de tweede tot de kde band staat als de Turing machine gestopt is, wordt niet in rekening gebracht.
Bemerk de subtiele details in de definitie van een Turing machine met meerdere banden. Op elke band mag een ander tape alfabet gebruikt wor- den. Verder mag de locomotief (read/write head) op een band ook ter plaatse blijven bij een transitie.
Voorbeeld 14.2.2 We geven nu een voorbeeld van een Turing machine met twee banden die een input w copieert:
input: PwP
output: PwwP
In het eerste gedeelte van de berekeningen copieert de Turing machine de
input w naar de tweede band (Figuur 14.2). 204
￼￼
￼￼￼￼￼￼￼￼￼￼Figuur 14.2: Copi ̈eren van een reeks via twee banden I
Dan wordt de locomotief (read/write head) op de tweede band opnieuw op het begin van de reeks w geplaatst (Figuur 14.3).
Figuur 14.3: Copi ̈eren van een reeks via twee banden II
Daarna wordt de reeks w van de tweede band naar de eerste band geco- pieerd, en exact rechts van de input w op band 1 geplaatst (Figuur 14.4).
Voorbeeld 14.2.3 Het tweede voorbeeld van een Turing machine met twee banden telt twee binaire getallen op (zie Figuur 14.5).
Op de bovenste band staan de twee binaire getallen, van elkaar gescheiden door ;
De eerste berekeningen copi ̈eren het eerste binaire getal naar de tweede band (zie derde en vierde band in Figuur 14.5), en daarna, op de onderste twee banden, worden de twee binaire getallen opgeteld, startend bij de rechtse minst significante bits, waarbij er natuurlijk rekening gehouden wordt met carry bits tijdens de optelling.
205
￼￼￼
￼￼￼￼￼￼￼￼￼Figuur 14.4: Copi ̈eren van een reeks via twee banden III
We hebben dus een extensie aangebracht aan de originele definitie van deterministische Turing machine. Hebben we nu een machine die meer kan dan een deterministische Turing machine met slechts  ́e ́en band? Bestaan er functies die berekenbaar zijn op een Turing machine met meer dan  ́e ́en band die niet berekend kunnen worden op een deterministische Turing machine met  ́e ́en band?
Het antwoord is neen: wat op een deterministische Turing machine met meerdere banden kan berekend worden, kan ook berekend worden op een deterministische Turing machine met precies  ́e ́en band.
Stelling 14.1 Zij M een Turing machine met k banden, k ≥ 1. Dan is er een Turing machine M′ met precies  ́e ́en band, zodat er geldt:
voor elke mogelijke input x: de Turing machine M stopt met output z op de eerste band als en slechts als de Turing machine M′ stopt in dezelfde toestand met z op zijn band.
BEWIJS: We geven hier het basisidee om de werking van een Turing machine met k banden te modelleren op een Turing machine met precies  ́e ́en band.
Een Turing machine met k banden kan k symbolen gelijktijdig bewerken. Dit kunnen we modelleren als een bewerking op  ́e ́en symbool door in plaats van het alfabet Γ, het alfabet Γk van de k-tallen over Γ te gebruiken.
Maar dit lost niet alles op.
Bij de originele Turing machine met k banden zijn er k locomotieven (read/write heads) die zich elk afzonderlijk bewegen op  ́e ́en van de k banden. We dienen ook hun posities te kennen en te modelleren binnen een Turing machine met  ́e ́en band.
We lossen dit als volgt op.
206
￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼Figuur 14.5: Optellen van twee binaire getallen via twee banden
We voegen bij elk van de k banden van M een extra band bij. Elk van deze extra banden heeft {0,1} als tape alfabet, en op elk van deze extra banden staat er precies  ́e ́en keer de bit 1. Deze bit 1 geeft de positie van de locomotief op de bijhorende band van de originele Turing machine M aan (zie Figuur 14.6).
De twee hierboven vermelde oplossingen voegen we nu samen door het originele tape alfabet Γ van de Turing machine M met k banden te veran- deren in het alfabet Γ ∪ (Γ × {0, 1})k voor de nieuwe Turing machine M ′ met precies  ́e ́en band.
Door deze verandering van het alfabet kunnen we nu op  ́e ́en band de werking van de originele Turing machine M modelleren. P
Figuur 14.6: Extra band bij elke band om de posities van de locomotieven vast te leggen
207
￼
￼￼￼￼￼￼￼14.3 Niet-deterministische Turing machines
We voeren nu niet-deterministische Turing machines in. Net zoals als bij de eindige deterministische automaten zullen we echter kunnen bewijzen dat er voor elke niet-deterministische Turing machine een equivalente determinis- tische Turing machine bestaat.
Maar toch is er voorzichtigheid geboden. Een niet-deterministische Tu- ring machine kan soms keuzes maken. Dit zal tot subtielere definities voor beslisbaarheid, semi-beslisbaarheid en berekenbaarheid leiden.
Definitie 14.3.1 Een niet-deterministische Turing machine M is een 6-tal (K,Σ,Γ,∆,s,H), met de transitierelatie ∆ een deelverzameling van
((K \H)×Γ)×(K ×Γ×{←,→}).
Het feit dat een niet-deterministische Turing machine keuzes kan maken bij het verwerken van een input kunnen we voorstellen in een boom die de verschillende mogelijkheden weergeeft waarop deze Turing machine een bepaalde input kan verwerken. Dit illustreren we in Figuur 14.7 voor een niet-deterministische Turing machine met als startconfiguratie (s, Pabab).
Figuur 14.7: Weergave van keuzes van niet-deterministische Turing machine in een boom
Definitie 14.3.2 Zij M = (K,Σ,Γ,∆,s,{y,n}) een niet-deterministische Turing machine en zij w ∈ Σ∗.
• M aanvaardt de input w als en slechts als minstens  ́e ́en van de bere- keningen die M kan uitvoeren op de input w, deze input w aanvaardt, dus eindigt in de y toestand.
• M weigert de input w als en slechts als alle berekeningen die M kan uitvoeren op de input w, deze input w weigeren.
• M beslist een taal L ⊆ Σ∗ als en slechts als, voor alle w ∈ Σ∗:
– er is een eindig aantal paden dat de Turing machine M kan volgen voor input w,
208
￼￼
– al deze paden zijn eindig, en,
– w ∈ L als en slechts als M aanvaardt w.
Nu geven we een voorbeeld van niet-deterministisch beslissen.
Voorbeeld 14.3.3 Beschouw de taal
L = {w ∈ {0, 1}∗ : w is de binaire representatie van een niet-priemgetal}.
De volgende Turing machine M beslist deze taal L door de volgende bewerkingen uit te voeren op de input w:
1. Kies niet-deterministisch twee positieve binaire getallen p en q waar- voor 2 ≤ p, q ≤ w.
2. Schrijf deze twee getallen p en q na w, gescheiden door ; P110011; 111; 1111PP
3. Vermenigvuldig p met q, en schrijf het product A = p · q op de band, in de plaats van p en q.
P110011; 1011111PP
4. Vergelijk A met w. Als zij gelijk zijn, ga naar toestand y, anders ga
naar toestand n.
Controleer dat deze Turing machine M effectief de taal L niet-deterministisch
beslist.
Nu geven we de definitie van niet-deterministisch semibeslissen.
Definitie 14.3.4 Zij M = (K, Σ, Γ, ∆, s, H) een niet-deterministische Tu- ring machine. Dan semibeslist deze niet-deterministische Turing machine M detaalL⊆Σ∗ alsenslechtsalsvoorelkew∈Σ∗:
w ∈ L als en slechts als de startconfiguratie (s,Pw) leidt tot minstens  ́e ́en aanvaardende configuratie.
Voorbeeld 14.3.5 Beschouw de taal
L = {w ∈ {a, b, c, d}∗ : minstens 1 letter treedt minstens twee keer op.}
De niet-deterministische Turing machine in Figuur 14.8 semibeslist deze taal.
Maar hier kun je ook een niet-deterministische Turing machine maken die deze taal beslist.
209
￼￼￼
￼￼￼￼￼￼￼￼￼Figuur 14.8: Niet-deterministische Turing machine die L semibeslist
Nu geven we een voorbeeld van een taal L die semibeslist kan worden door een niet-deterministische Turing machine, maar die niet beslist kan worden door een niet-deterministische Turing machine.
Voorbeeld 14.3.6 Beschouw de taal
L = {beschrijving van een Turing machine die stopt voor minstens  ́e ́en
input}.
Zij ⟨M⟩ de reeks die een Turing machine M beschrijft.
Dan semibeslist de volgende niet-deterministische Turing machine S de input ⟨M⟩.
1. Kies niet-deterministisch een input w ∈ Σ∗ en schrijf deze input w op de band.
2. Laat M de input w verwerken.
3. Aanvaard.
Nu geven we de definitie van het niet-deterministisch berekenen van een functie.
Definitie 14.3.7 De niet-deterministische Turing machine M berekent een functie f als en slechts als voor elke input w ∈ Σ∗:
• alle berekeningen van M voor input w stoppen, en,
• alle berekeningen van M voor input w resulteren in output f(w).
210
￼￼￼￼￼￼￼Nu geven we het bewijs dat deterministische Turing machines en niet- deterministische Turing machines equivalent zijn.
Stelling 14.2 Als een niet-deterministische Turing machine M een taal be- slist of semibeslist, of een functie berekent, dan is er een deterministische Turing machine M′ die dezelfde taal beslist of semibeslist, of dezelfde functie berekent.
BEWIJS: Het bewijs verloopt constructief, maar er dienen aparte con- structies uitgevoerd te worden voor beslissen/semibeslissen, en voor het be- rekenen van een functie.
BESLISSEN/SEMIBESLISSEN:
We hebben reeds opgemerkt in Figuur 14.7, zie ook Figuur 14.9, dat de verschillende manieren waarop een niet-deterministische Turing machine een input w kan verwerken, beschreven kunnen worden in een boom.
Figuur 14.9: Weergave van keuzes van niet-deterministische Turing machine in een boom
Dus als eerste oplossing om een equivalente deterministische Turing ma- chine te construeren, kan voorgesteld worden om een depth-first search op deze boom uit te voeren.
Maar dit is een oplossing die niet altijd zal werken. Wat als het eerste pad oneindig lang is omdat dit pad correspondeert met de Turing machine in een oneindige lus, dan zal nooit een volgend pad geprobeerd worden.
De betere suggestie is om deze boom via breadth-first search te doorlo- pen.
Dit is inderdaad een betere suggestie, maar deze vraagt soms heel veel meer werk.
Stel namelijk dat de boom vertakkingsgetal b heeft en dat het kortste pad dat de input w aanvaardt de lengte h heeft. Dan kan dit tot bh+1 stappen vereisen voor de deterministische Turing machine.
Dus hier zien we een (complexiteits)probleem: We kunnen het niet- deterministisch gedrag van de niet-deterministische Turing machine deter- ministisch maken, maar ten koste van heel veel bewerkingen, soms een veel grotere complexiteit.
￼Kan dit verholpen worden?
211
￼￼￼￼￼￼￼￼￼Dit probleem is nog open: het is verwant aan het beroemde
Is P = NP?
probleem.
Dit is het centrale probleem binnen de complexiteitstheorie.
We zullen hier nog een alternatieve manier bespreken om het niet-deterministisch
gedrag van een niet-deterministische Turing machine, deterministisch te ma- ken. Deze manier heet iterative deepening.
iterative deepening:
1. d = 1.
2. Herhaal tot een oplossing gevonden wordt.
(a) Start in de wortel van de boom, verken alle paden die starten in de wortel en lengte d hebben.
(b) Als een oplossing gevonden wordt, stop. (c) Andersd:=d+1.
Figuur 14.10: Weergave van iterative deepening
Dit algoritme iterative deepening kunnen we realiseren op een Turing machine met drie banden.
Figuur 14.11: Realisatie van iterative deepening op Turing machine met drie banden
Nu schrijven we expliciet de procedure P op. 212
￼￼
￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼Figuur 14.12: Procedure P voor iterative deepening
Figuur 14.13: Procedure P voor iterative deepening
Het idee van iterative deepening is als volgt: We leggen dit uit via Figuur 14.13.
De input die verwerkt dient te worden door de Turing machine M staat op band (tape) 0. Bij iterative deepening worden er verschillende manieren geprobeerd om deze input te verwerken. Bij iedere manier waarop de input verwerkt kan worden, copi ̈eren we de input naar band (tape) 1. Dan wordt deze manier uitgeprobeerd op de input. De derde band (tape) 2 geeft aan via de getallen die op band 2 staan, welke keuzes er bij iedere stap genomen dienen te worden. Namelijk, de volgorde 1 3 2 6 5 4 3 6 op band 2 duidt aan dat bij de eerste instructie de eerste keuze dient gemaakt te worden, bij de tweede instructie de derde keuze, bij de derde instructie de tweede keuze, ...
Als de Turing machine voor een bepaalde volgorde van de keuzes, be- schreven op band 2, de input aanvaardt, dan aanvaardt de Turing machine de input en stopt de Turing machine. In het andere geval wordt de lexicogra- fisch volgende reeks op band 2 gegenereerd, en herstart de Turing machine vanaf het begin. De Turing machine copieert opnieuw de input van band 0 naar band 1, en nu worden de instructies uitgevoerd volgens de nieuwe reeks keuzes opgesomd op band 2.
Bij iterative deepening worden dus eerst alle mogelijke manieren om de input te verwerken via  ́e ́en instructie (d = 1) geprobeerd. Wordt de input nooit aanvaard door  ́e ́en instructie, dan wordt d := d + 1, dus d = 2 gesteld, en worden alle mogelijke manieren om de input te verwerken via twee instructies (d = 2) geprobeerd. Wordt de input nooit aanvaard door een keuze van twee opeenvolgende instructies, dan wordt d := d + 1, dus d = 3 gesteld, en worden alle mogelijke manieren om de input te verwerken
213
￼
via drie instructies (d = 3) geprobeerd.
Om dit iteratief proces op te starten, wordt band 2 bij het begin geini-
tialiseerd met ε.
Samengevat beschrijven we de deterministische beschrijving M′ via itera- tive deepening van een niet-deterministische Turing machine M die gebruikt wordt als beslissingsmachine op de volgende manier.
De deterministische Turing machine M′ dient te stoppen van zodra  ́e ́en van de volgende gevallen optreedt:
• De Turing machine M ′ ontdekt een pad waarlangs de niet-deterministische Turing machine M stopt en aanvaardt. In dit geval zal ook M′ de in- put aanvaarden.
• De Turing machine M′ heeft alle mogelijke paden gecontroleerd tot zij stopten, maar alle paden weigerden de input. In dit geval zal ook M′ de input weigeren.
Dit idee beschrijft hoe de Turing machine M′ dient te werken. Maar hoe weet de Turing machine M′ in het tweede geval dat alle mogelijke paden gecontroleerd zijn tot het einde?
Dit wordt opgelost via een booleaanse variabele nothalted die op FALSE geinitialiseerd wordt. Als de Turing machine M′ een pad van lengte d pro- beert, en de Turing machine M′ detecteert dat dit pad nog niet in een st- optoestand gekomen is (dus nog niet stopt), dan wordt nothalted op TRUE gezet. Zo wordt onthouden dat als geen enkel pad van lengte d de input aanvaardt, dat dan de Turing machine M′ ook de paden van lengte d + 1 dient te controleren.
We vatten dit nu samen in het volgende algoritme voor de werking van de Turing machine M′. Hier stelt e de nulreeks ε voor.
1. Schrijf e op band 2.
2. Stel nothalted gelijk aan FALSE.
3. Tot M’ de input aanvaardt of weigert, doe:
   3.1 Copieer de input w van band 0 naar band 1.
   3.2 Laat M’ de input w verwerken volgens de keuzes voor de
       instructies voorgeschreven door de getallen op band 2.
   3.3 Als M’ ontdekt dat M de input zou aanvaarden, aanvaard.
   3.4 Als M’ ontdekt dat M niet gestopt is volgens dit pad,
       zet nothalted gelijk aan TRUE.
   3.5 Als de lexicografisch volgende reeks op band 2 langer
       zou zijn dan de reeks er net voor, doe:
       3.5.1 Controleer de waarde van nothalted.
       3.5.2 Is deze FALSE, weiger dan de input.
214
￼￼￼￼￼￼￼       3.5.3 Anders, zet nothalted gelijk aan FALSE.
   3.6 Genereer de lexicografisch volgende reeks op band 2.
Op deze manier kunnen we via iterative deepening op een correcte manier de werking van de niet-deterministische Turing machine M op de input w, hervertalen naar een deterministische Turing machine M′.
14.4 Andere alternatieve definities van Turing ma- chines
14.4.1 Band die slechts oneindig lang is in  ́e ́en richting
Stel dat de oneindige band begrensd wordt aan  ́e ́en zijde, en oneindig lang is in de andere richting. Dan kun je dit toch hervertalen naar de originele Turing machine die een band heeft die oneindig doorloopt in beide richtin- gen.
Dit tonen we als volgt aan.
Eerst en vooral, we gebruiken het symbool Q om de muur aan te duiden die de begrenzing van de band aanduidt. Wij zullen deze begrenzing aan de linkerzijde plaatsen, dus de band loopt oneindig door naar rechts.
De betekenis van het symbool Q is dat de Turing machine zich niet links voorbij het symbool Q kan bewegen. Dus de transitiefunctie δ van de Turing machine voldoet aan:
1. Als het inputsymbool Q is, dan moet de Turing machine naar rechts (→) bewegen, en
2. het symbool Q kan nooit op de band geschreven worden.
Figuur 14.14: Oneindige band die begrensd is aan  ́e ́en zijde
Nu hervertalen we deze Turing machine met een band die zich slechts oneindig verder zet in  ́e ́en richting naar een Turing machine met een band die zich in beide richtingen oneindig verder zet.
We gebruiken hiervoor Figuur 14.15.
Bekijk band 1 en band 2. Beide zijn links begrensd, de verbinding er- tussen bestaat feitelijk niet.
Via band 3 houdt de Turing machine het aantal uitgevoerde bewegingen (vierkant naar rechts of naar links) bij. Zo weet de Turing machine op ieder
215
￼
￼￼￼￼￼￼￼￼￼Figuur 14.15: Hervertaling tussen beide types oneindige banden
moment van de berekeningen op welk vierkant op band 1 of op band 2 hij staat. De beginpositie is de positie waarop de Turing machine stond bij de startconfiguratie. Als de Turing machine op band 1 staat, dan staat hij op de beginpositie of rechts van de beginpositie. Als de Turing machine op band 2 staat, dan staat hij links van de beginpositie.
Hoe schrijft de Turing machine op band 1 en op band 2? Op band 1 wordt er rechts aangevuld zoals op de oneindige band in beide richtingen, en op band 2 vul je ook rechts aan omdat dit correspondeert met links bijvoegen op de oneindige band in beide richtingen.
Als de Turing machine M gebruikt wordt om een functie te berekenen, dan willen we steeds dat de output op band 1 staat. Als de output op het einde verdeeld is over band 1 en band 2, dan schuift de Turing machine alle outputsymbolen op band 1 naar rechts totdat er voldoende plaats vrijgeko- men is om de outputsymbolen op band 2 te verplaatsen van band 2 naar band 1.
14.4.2 Stapels versus banden
We hebben nu reeds twee machines besproken die een geheugen hebben: de PDA met een stapel als geheugen, en de Turing machine met een band als geheugen.
Van de PDA naar de Turing machine
Er geldt dat een band effici ̈enter is dan een stapel als geheugen. We tonen dit aan door de werking van een PDA te simuleren op twee banden.
We illustreren dit via Figuur 14.16.
216
￼￼￼￼￼￼￼Figuur 14.16: Simulatie van PDA op Turing machine
Een niet-deterministische stapelautomaat heeft de volgende componen- ten:
• een eindige toestandscomponent die bijhoudt in welke toestand de PDA is,
• een inputreeks, en • een stapel.
Ook een Turing machine bevindt zich altijd in een bepaalde toestand, dus de eindige toestandscomponent is in orde.
Om de inputreeks en de stapel bij te houden, gebruiken we een Turing machine met twee banden. Band 1 bevat de inputreeks en zijn locomotief (read/write head) gebruiken we om de inputreeks in te lezen. Band 2 mo- delleert de stapel. We gebruiken hiervoor de end-of-stack marker #. Om de top van de stapel te kennen, blijft de locomotief (read/write head) op band 2 steeds op het karakter dat zich op de top van de stapel bevindt. Dit is het meest rechtse karakter verschillend van blanco, als de end-of-stack marker # links geplaatst wordt op band 2.
Dus een Turing machine kan gebruikt worden om een stapelautomaat te modelleren.
Van de Turing machine naar PDAs
Er geldt dat een Turing machine gemodelleerd kan worden door een stapelautomaat die twee stapels mag gebruiken. Figuur 14.17 modelleert dit.
Stapel 1 bevat alle karakters op de band links van de positie waar de locomotief (read/write head) staat, de positie van de locomotief inclusief, en de tweede stapel bevat alle karakters op de band rechts van de positie van de locomotief, de positie van de locomotief niet inbegrepen. Afhankelijk
217
￼￼￼￼￼￼Figuur 14.17: Turing machine is PDA met twee stapels
van de bewegingen van de locomotief (read/write head) worden er symbo- len, mogelijks met bijhorende wijziging zoals aangegeven in de transitie die uitgevoerd wordt, gepopt van de ene band en gepusht op de andere band.
218
Hoofdstuk 15
De universele Turing machine
15.1 Inleiding
Op dit ogenblik hebben we een Turing machine M gedefinieerd voor een specifieke taak op een specifieke input via de bijhorende transitiefunctie δ die in de definitie (K, Σ, Γ, δ, s, H ) van deze Turing machine M staat.
We hebben ook reeds opgemerkt dat de Turing machine het beste model is voor een echte computer.
Maar een echte computer is niet opgesteld voor een specifieke taak die op een specifieke input uitgevoerd dient te worden.
Een echte computer is programmeerbaar. Een echte computer krijgt een programma, geschreven in een bepaalde programmeertaal, en een input voor dit programma, als input, en dient dit programma op deze input uit te voeren, en een output te geven.
De vraag is of dit ook gerealiseerd kan worden op de Turing machine U. Het antwoord is ja; dit is de universele Turing machine.
15.2 De encodering van Turing machines M voor opslag op de universele Turing machine U
Om de universele Turing machine U te construeren die een programma M kan uitvoeren op een input w, om een output te genereren, dienen we:
• een manier te defini ̈eren om Turing machines M te encoderen op deze universele Turing machine U, en,
• een manier te defini ̈eren om, als de universele Turing machine de enco- dering ⟨M, w⟩ krijgt van de Turing machine M en de input w die deze Turing machine M dient te verwerken, de universele Turing machine
219
effectief in staat te stellen deze Turing machine M de input w te laten verwerken.
Dit klinkt ingewikkeld, maar bekijk hoe een echte computer werkt. De computerprogramma’s die een echte computer uitvoert, zijn in binaire vorm opgeslagen binnen in het geheugen van de echte computer, de inputs w die deze computerprogramma’s dienen te verwerken zijn ook in binaire vorm opgeslagen, en de echte computer weet hoe hij dit computerprogramma, in binaire vorm, de input w, ook in binaire vorm, kan laten verwerken.
Om deze reden dienen we de Turing machine M = (K, Σ, Γ, δ, s, H) die de input w dient te verwerken, voor te stellen als een lange reeks die:
• de toestanden uit K,
• de symbolen uit het tape alfabet Γ, en, • de transities uit de transitiefunctie δ
beschrijft.
We zullen dit in verschillende stappen doen. Encodering van de toestanden uit K:
• Stel
• Nummer de toestanden uit K van 0 tot |K| − 1 in binaire vorm, met
i = ⌈log2(|K|)⌉. – het nummer 0 voor de starttoestand s,
– een nummer groter dan nul voor de andere toestanden. Hier speelt de volgorde van de toestanden, verschillend van de start- toestand, geen rol.
• Als t′ het binair getal is dat gegeven is aan toestand t, dan:
– Als t de stoptoestand y is, associeer dan met deze toestand de
reeks yt′.
– Als t de stoptoestand n is, associeer dan met deze toestand de
reeks nt′.
– Als t een andere toestand is dan y en n, associeer dan met deze
toestand de reeks qt′.
220
Voorbeeld 15.2.1 Stel dat de Turing machine M precies 9 toestanden heeft, dan is i = 4, is s = q0000, en zijn de overige toestanden gelijk aan
q0001, q0010, y0011, n0100,
q0101, q0110, q0111, q1000.
In deze ordening van de toestanden heeft de toestand y het nummer 3 en
heeft de toestand n het nummer 4.
Encodering van de symbolen uit het tape alfabet Γ:
• Kies j het kleinste getal zodat 2j ≥ |Γ|.
• Elk symbool a ∈ Γ wordt geassocieerd aan de reeks ay, met y ∈ {0, 1}∗,
waarbij y steeds moet bestaan uit j bits.
Voorbeeld 15.2.2 Stel dat Γ = {P, a, b, c}. Dan is hier j = 2, dus alle nummers moeten door twee bits voorgesteld worden.
Hier kiezen we de volgende nummering
Een transitie omvat ook een verplaatsing naar links (←) of naar rechts (→). Hiervoor wordt er ook een encodering voor gezocht, in feite voldoen hiervoor twee symbolen die niks anders voorstellen. We zullen voor de een- voud de pijlen ← en → blijven gebruiken.
Op deze manier kunnen alle transities
(toestand, input, toestand, output, beweging)
uit de transitiefunctie δ van een Turing machine M voorgesteld worden in de gedaante
(q000, a000, q110, a000, →),
met de bijhorende afspraak dat q000 de starttoestand voorstelt.
Eveneens dient er een manier gezocht te worden om de stoptoestanden uit H te specifi ̈eren bij de encodering van de Turing machine M binnen de
universele Turing machine U.
Nu kunnen we een Turing machine M volledig encoderen voor opslag
op de universele Turing machine U. We illustreren dit met het volgende voorbeeld.
221
￼P = a00 a = a01 b = a10 c = a11
￼￼￼￼￼
￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼Voorbeeld 15.2.3 Beschouw de Turing machine
M = ({s,q,h},{a,b,c},{P,a,b,c},δ,s,{h}).
Deze wordt ge ̈encodeerd voor opslag op de universele Turing machine U, zoals weergegeven in Figuur 15.1.
Figuur 15.1: Encodering op universele Turing machine
Na de tabel zien we in feite dat elke Turing machine opgeslagen kan worden als een reeks 5-tallen op de universele Turing machine U.
Opmerking 15.2.4 De voorgaande zin die stelt dat elke Turing machine opgeslagen kan worden als een reeks 5-tallen op de universele Turing machine U , is correct, maar er is  ́e ́en Turing machine die geen instructies nodig heeft.
Dit is de Turing machine M die alles aanvaardt. Dus met L(M) = Σ∗.
Figuur 15.2: Turing machine die taal L(M) = Σ∗ aanvaardt
Ook voor deze heel bijzondere Turing machine, zonder transities, dient een aparte encodering gezocht te worden voor opslag op de universele Turing machine U.
222
￼￼
Het feit dat we nu een manier hebben opgesteld om Turing machines M te encoderen voor opslag op de universele Turing machine U, bijvoor- beeld in de gedaante van een lijst 5-tallen, impliceert dat het mogelijk is de verschillende Turing machines M op te sommen, dus te nummeren.
Dit wordt formeel beschreven in de volgende stelling.
Stelling 15.1 Er bestaat een lexicografische opsomming van
1. alle syntactisch correct opgestelde Turing machines,
2. alle syntactisch correct opgestelde Turing machines met een vooropge- geven inputalfabet Σ,
3. alle syntactisch correct opgestelde Turing machines met een vooropge- geven inputalfabet Σ en een vooropgegeven tape alfabet Γ.
BEWIJS: Fixeer het alfabet
Σ = {(,),a,q,y,n,0,1, komma ,→,←}.
Dit is het alfabet om alle Turing machines te encoderen als reeksen 5-tallen op de universele Turing machine, zoals geillustreerd in Voorbeeld 15.2.3.
Om de syntactisch correct opgestelde Turing machines te nummeren, gaan we als volgt tewerk:
1. Schrijf alle eindige reeksen uit Σ∗ in een bepaalde lexicografische volg- orde na elkaar.
2. Als een dergelijke eindige reeks s uit Σ∗ gegenereerd wordt, controleer of deze reeks s een syntactisch correct opgestelde beschrijving is van een Turing machine M als een reeks 5-tallen, zoals geillustreerd in Voorbeeld 15.2.3.
Als dit effectief zo is, geef deze reeks s als output.
Als dit effectief zo is, en deze reeks s is de ide output die gegenereerd wordt, geef dan de corresponderende Turing machine voorgesteld door deze reeks s het nummer i. We beschrijven deze Turing machine dan ook als de ide Turing machine.
Dit bewijst deel 1 van deze stelling.
Om deel 2 en deel 3 te bewijzen uit deze stelling, kijk naar de groottes van het vooropgegeven inputalfabet Σ en het vooropgegeven tape alfabet Γ. Uit de grootte van deze alfabetten Σ en Γ kunnen we afleiden hoe lang de binaire reeksen zijn die een inputsymbool voorstellen en hoe lang de binaire reeksen zijn die een tape symbool voorstellen (zie het item Encodering van de symbolen uit het tape alfabet hierboven), en hou hiermee rekening in stap 2 van het algoritme zodat enkel reeksen s die de syntactisch correct opgestelde beschrijving van een Turing machine M zijn, met de correcte groottes voor hun input en tape alfabet naar de output gestuurd worden. P
223
15.3 De universele Turing machine U
Na deze voorbereidende beschouwingen kunnen we de formele beschrijving en werking geven van de universele Turing machine U die een Turing machine M zal uitvoeren op een input w. Om notaties te vereenvoudigen, spreken we af dat de notatie
⟨x1,x2,...,xn⟩
een enkele reeks voorstelt die de individuele encoderingen van de indivi- duelewaardenx1,x2,...,xn voorstelt.
De taak van de universele Turing machine U is duidelijk:
Bij het krijgen van de input ⟨M,w⟩ dient de universele Turing machine
U:
• te stoppen als en slechts als de Turing machine M stopt voor input w.
• Als de Turing machine M een beslissende of semibeslissende machine is, dan:
– Als M de input w aanvaardt, dan aanvaardt U ook. – Als M de input w weigert, dan weigert U ook.
• Als M een functie berekent, dan moet U (⟨M, w⟩) gelijk zijn aan M (w). We realiseren dit op de volgende manier:
De universele Turing machine U zal drie banden gebruiken om de werking van de Turing machine M op de input w te simuleren:
• Band 1: dit is de band van de universele Turing machine U. Op deze band wordt de input ⟨M, w⟩ opgeslagen. Zo is dit in overeenstemming met de afspraak, gemaakt bij Turing machines met meerdere banden, dat de input origineel opgeslagen wordt op de eerste band, voor alle berekeningen beginnen.
• Band 2: hier zal de encodering ⟨M⟩ van de Turing machine M opge- slagen worden. Dit correspondeert met het computerprogramma dat opgeslagen is in het geheugen van je echte computer als je dit compu- terprogramma een input laat verwerken.
• Band 3: op deze band wordt de toestand bijgehouden waarin de Turing machine M is, als de universele Turing machine U deze Turing machine M de input w laat verwerken. Zo weet de universele Turing machine U altijd in welke toestand de Turing machine M is bij de verwerking van de input w. Deze toestand wordt bijgehouden via zijn encodering
224
￼￼￼￼￼￼als q gevolgd door een binair getal. Zo is dit in overeenstemming met de Encodering van de toestanden uit K, besproken in de vorige sectie.
We illustreren dit in Figuur 15.3.
Figuur 15.3: Beschrijving van de universele Turing machine
Op deze figuur zie je 6 banden in plaats van 3, omdat bij elk van de 3 banden de bijhorende band staat met precies  ́e ́en 1 die de positie van de locomotief (read/write head) op de bijhorende band aangeeft (zie Sectie 14.2).
We zien ook op deze figuur dat de input ⟨M,w⟩ bij het begin van de berekeningen opgeslagen is op de eerste van de drie banden.
Nu voeren we een voorbereidende initialisatie uit op de universele Turing machine U, om daarna de universele Turing machine U in staat te stellen de Turing machine M de input w te laten verwerken.
Initialisatie van de universele Turing machine U
1. Copieer de encodering ⟨M⟩ van de Turing machine M van band 1 naar band 2. Zo heeft de universele Turing machine U altijd de encodering van de Turing machine M ter beschikking.
2. Bekijk de encodering ⟨M⟩ van de Turing machine M en bepaal de kleinste waarde i zodat 2i groter dan of gelijk is aan het aantal toe- standen van M. Zo weten we dat elke toestand in M geencodeerd wordt via q en een eropvolgende reeks van i bits.
3. Schrijf nu de encodering s = q0i op de derde band, want de berekenin- gen van de Turing machine M beginnen in de starttoestand s = q0i, en, zoals afgesproken, de universele Turing machine U houdt de toe- stand waarin de Turing machine M is steeds bij op de derde band.
De werking van de universele Turing machine U
225
￼
￼￼￼￼Figuur 15.4: Initialisatie van de universele Turing machine
Nu kunnen we de werking van de universele Turing machine, het laten verwerken van de input w door de Turing machine M, beschrijven. We illu- streren dit opnieuw via Figuur 15.4.
Simulatie van de bewerkingen van de Turing machine M op de input w: 1. Tot de Turing machine M zou stoppen, doe:
(a) Scan de tweede band voor een 5-tal dat een transitie voorstelt die overeenkomt met de huidige toestand (opgeslagen op band 3) en het huidige inputsymbool (opgeslagen op band 1 op de positie van de locomotief (read/write head)).
(b) Voer de bijhorende transitie uit, met de bijhorende aanpassingen van band 1 (het inputsymbool onder de locomotief) en band 3 (aanpassing van de toestand door de transitie). Indien nodig, gebruik meer vierkantjes op band 1.
(c) Als geen bijhorende transitie gevonden wordt, dan stopt de uni- versele Turing machine U, anders gaat deze terug naar het begin van deze lus.
2. De universele Turing machine U geeft nu hetzelfde resultaat terug als wat M zou geven als output (bij input w).
Opmerking 15.3.1 Als een universele Turing machine zo een goed idee was, waarom proberen we dan niet om een universele eindige determinis- tische automaat te construeren?
Een dergelijke universele eindige deterministische automaat dient de vol- gende taal
L={⟨F,w⟩:F iseenEDAenw∈L(F)}
te aanvaarden.
Kan deze universele eindige deterministische automaat geconstrueerd wor-
den?
226
Hoofdstuk 16
De Church-Turing thesis
16.1 Inleiding
In de voorgaande hoofdstukken hebben we achtereenvolgens eindige determi- nistische automaten, niet-deterministische stapelautomaten en Turing ma- chines besproken.
Kunnen we nu alle problemen oplossen? Het antwoord is neen, want:
• Er zijn een oneindig aftelbaar aantal Turing machines. We hebben dit bewezen in Stelling 15.1, waar we lexicografisch alle reeksen hebben opgesomd die corresponderen met correct opgestelde Turing machines.
• Er zijn echter een oneindig niet-aftelbaar aantal talen over een eindig, niet-ledig, alfabet.
Dus er zijn veel meer talen dan dat er Turing machines zijn. Een Turing machine kan niet alle problemen oplossen.
Dit leidt tot de vraag:
welke problemen kunnen opgelost worden door een Turing machine, en welke problemen kunnen niet opgelost worden door een Turing machine?
De alternatieve formulering voor deze vraag is:
wat kunnen algoritmes doen?
Dit wordt ook onderzocht in de logica. Binnen de logica zijn de volgende vragen gesteld:
1. Kunnen van alle ware uitspraken stellingen gemaakt worden, dus een bewijs gegeven worden?
227
2. Kunnen we beslissen of een uitspraak een stelling is?
Kurt Go ̈del bewees in 1931 in zijn bewijs voor zijn onvolledigheidsstelling dat het antwoord op Vraag 1 negatief is. Hij toonde namelijk in het bijzonder aan dat er geen beslisbare axiomatisering bestaat voor de Peano rekenkunde die zowel consistent als compleet is.
16.2 Het beslisbaarheidsprobleem
Beschouw de volgende vragen:
• Bestaat er een algoritme om, gegeven een willekeurige uitspraak w in 1ste orde logica, te beslissen of deze uitspraak w geldig is in deze logica?
• Gegeven een verzameling axioma’s A en een uitspraak w, bestaat er een algoritme om te beslissen of deze uitspraak w afgeleid kan worden uit de verzameling axioma’s A?
• Gegeven een verzameling axioma’s A en een uitspraak w, bestaat er een algoritme om te beslissen of deze uitspraak w bewezen kan worden uit de verzameling axioma’s A?
Om deze vragen te beantwoorden, dient de definitie van een algoritme geformaliseerd te worden.
Verschillende onderzoekers hebben geprobeerd de definitie van een algo- ritme te formaliseren. Zo ontwikkelde:
• Alan Turing de Turing machines, en • Alonzo Church de lambda calculus.
Alan Turing bewees dat de Turing machines equivalent zijn aan de lambda calculus.
Analoog werd de equivalentie tussen al de volgende formalismen aange- toond:
• Moderne computers, met een onbegrensd geheugen.
• Lambda calculus.
• Parti ̈ele recursieve functies.
• Grammatica’s van type 0 in de Chomsky hi ̈erarchie: hier worden er geen restricties op de herschrijfregels opgelegd.
• Post productiesystemen.
228
￼￼￼￼￼• Markov algoritmes.
• Conway’s game of life.
• 1-dimensionale cellulaire automata.
• DNA-gebaseerde computing.
• Lindenmayer systemen.
Nemen we bijvoorbeeld Conway’s game of life, voorgesteld in Figuur 16.1.
Figuur 16.1: Conway’s game of life
In dit spel wordt op iedere stap van de berekeningen, de waarde van een cel bepaald door de volgende regels:
Bekijk de buren van een cel (dit zijn er hoogstens 8), en
• een dode cel met precies drie levende buren wordt een levende cel (ge- boorte),
• een levende cel met twee of drie levende buren blijft leven (overleven),
• in alle andere gevallen sterft een cel of blijft de cel dood (overbevolking
of eenzaamheid).
We zeggen dat het game of life stopt als en slechts als het een stabiele configuratie bereikt.
We kunnen dit spel zien als een computer die een initi ̈ele startconfiguratie voor het bord heeft, een bewerking kan uitvoeren, en die al dan niet kan stoppen. Als de computer stopt, dan heeft hij een stabiele configuratie bereikt die hij als output kan geven.
Het is aangetoond dat, via een aangepaste encodering, de bewerkingen van een Turing machine gesimuleerd kunnen worden door een game of life, en vice versa, dat een game of life hervertaald kan worden naar een Turing machine.
Dus het game of life is equivalent met een Turing machine. 229
￼
16.3 De Church-Turing thesis
In de vorige sectie hebben we verschillende formalismen opgesteld die al- lemaal equivalent blijken te zijn aan elkaar. Dit heeft onderzoekers doen vermoeden dat er een soort van universele definitie voor een algoritme vast- ligt.
Dit is gekend onder de naam Church-Turing thesis:
alle formalismen sterk genoeg om alles te beschrijven wat wij, als mensen, beschouwen als een computationeel algoritme, zijn equivalent.
Merk op dat deze uitspraak nog niet bewezen is, dus we mogen niet zeggen dat dit een stelling is. Het is meer een filosofische uitspraak over algoritmes.
Het is nu aan ieder van jullie om akkoord of niet-akkoord te gaan met deze uitspraak.
230
Hoofdstuk 17
Het stopprobleem
17.1 Inleiding
In het vorige hoofdstuk hebben we al opgemerkt dat een Turing machine niet alle problemen kan oplossen.
Het bewijs hiervoor gebruikte de begrippen aftelbaarheid en niet-aftelbaarheid. Er zijn een oneindig aftelbaar aantal Turing machines, maar er zijn een on- eindig niet-aftelbaar aantal problemen.
Dit bewijs, via de begrippen aftelbaarheid en niet-aftelbaarheid, geeft ons echter nog niet een concreet voorbeeld van een probleem dat niet opge- lost kan worden door een Turing machine.
In dit hoofdstuk zullen we een concreet voorbeeld geven van een pro- bleem dat niet opgelost kan worden door een Turing machine, namelijk het stopprobleem, ook halting problem genoemd.
Hier is de formulering van het stop probleem heel belangrijk.
Om het probleem exact te situeren, herhalen we de begrippen beslissen en semibeslissen uit Hoofdstuk 13.
Definitie 17.1.1 Een Turing machine M beslist/decides een taal L ⊆ Σ∗ als en slechts als voor elke reeks w ∈ Σ∗ geldt dat:
• alsw∈L,danaanvaardtM deinputw,en
• alsw̸∈L,danweigertM deinputw.
Een taal L is beslisbaar als en slechts als er een Turing machine M bestaat die deze taal beslist. In dit geval noteren we dit met
L ∈ D,
met D de verzameling van alle beslisbare talen.
Definitie 17.1.2 Een Turing machine M semibeslist een taal L ⊆ Σ∗ als en slechts als voor elke input w ∈ Σ∗:
231
• als w ∈ L, dan moet M de input w aanvaarden.
• als w ̸∈ L, dan mag M de input w niet aanvaarden. Als w ̸∈ L, dan moet M de input w weigeren of voor deze input w in een oneindige lus terechtkomen.
Een taal L is semibeslisbaar als en slechts als er een Turing machine M bestaat die de taal L semibeslist.
We noteren met SD de verzameling van alle semibeslisbare talen. 17.2 De taal H van het stopprobleem
Het stopprobleem (halting problem) betreft de taal H, als volgt gedefinieerd: H = {⟨M,w⟩ : TM M stopt voor input w}.
Het stopprobleem betreft het feit dat de taal H semibeslisbaar is, maar niet beslisbaar.
Stelling 17.1 De taal
H = {⟨M,w⟩ : TM M stopt voor input w}
is semibeslisbaar, maar niet beslisbaar.
Het bewijs van deze stelling bestaat uit twee delen: een eenvoudig en een moeilijk gedeelte. Het eenvoudige gedeelte is het bewijs dat de taal H semibeslisbaar is.
Stelling 17.2 De taal
H = {⟨M,w⟩ : TM M stopt voor input w}
is semibeslisbaar.
BEWIJS: We tonen de stelling aan door een Turing machine MH op te stellen die de taal H semibeslist:
M_H(<M,w>) =
  1.  Laat M de input w verwerken.
  2.  Aanvaard.
Bekijk dit algoritme. De Turing machine MH aanvaardt zijn input ⟨M,w⟩ als en slechts als de Turing machine M stopt voor input w. In
232
het andere geval stopt MH niet voor input ⟨M,w⟩. Dus, in overeenstem- ming met Definitie 17.1.2, deze Turing machine MH semibeslist de taal H. P
Dit is het eenvoudige gedeelte voor het bewijs van Stelling 17.1. Nu volgt het moeilijke gedeelte in Stelling 17.3. Hier is het belangrijk dat steeds de correcte formulering gegeven wordt in het bewijs van Stelling 17.3, en dat de juiste stappen op het juiste moment toegepast worden.
Stelling 17.3 De taal
H = {⟨M,w⟩ : TM M stopt voor input w}
is niet-beslisbaar.
BEWIJS: Stel dat de taal H beslisbaar is, dan bestaat er een Turing machine MH die deze taal H kan beslissen. Deze Turing machine MH zou de implementatie zijn van de volgende procedure:
halts(<M: reeks, w: reeks>) =
  Als <M> de beschrijving is van een Turing machine,
  en M stopt voor input w,
     dan aanvaard,
     anders weiger.
Belangrijk hier is dat halts altijd stopt voor zijn input ⟨M,w⟩.
We willen nu aantonen dat dit programma halts in feite niet bestaat. We tonen dit aan door een nieuw programma Trouble op te stellen dat halts op een bijzondere manier oproept.
Trouble(x: reeks) =
  Als halts(x,x) dan start een oneindige lus op,
  anders stop het programma.
Wat is nu Trouble(<Trouble>)? Dit komt neer op de vraag: wat is halts(Trouble,Trouble)?
• Als halts rapporteert dat Trouble(<Trouble>) stopt, dan wordt Trou- ble in een oneindige lus gestuurd. Dus halts kan niet rapporteren dat Trouble(<Trouble>) stopt.
• Als halts rapporteert dat Trouble(<Trouble>) niet stopt, dan stopt Trouble. Dus halts kan niet rapporteren dat Trouble(<Trouble>) niet stopt.
233
Dus welke van de twee mogelijkheden we ook controleren, beide leiden tot een contradictie.
Ergens is er een verkeerde onderstelling gemaakt. De enige onderstelling die gemaakt was, is dat de taal H beslisbaar was.
We dienen deze onderstelling te corrigeren: de taal H is niet-beslisbaar. P
Opmerking 17.2.1 Zoals opgemerkt net voor het bewijs van de vorige stel- ling, is het belangrijk dat in het bewijs van deze stelling de juiste stappen op het juiste moment toegepast worden.
De idee ̈en die achter de schermen gebruikt worden, zijn:
• We zorgen voor een tegengesteld effect in de code van Trouble.
• We zorgen dat Trouble zichzelf controleert door Trouble(<Trouble>) op te roepen.
Uit de logica weten we dat deze idee ̈en tot de gewenste tegenstrijdigheid zullen leiden, want uit de logica weten we dat een programma zichzelf niet kan controleren.
17.3 Wat als de taal H toch beslisbaar zou geweest zijn?
Er is onderzocht geweest wat de gevolgen zouden zijn indien de taal H toch beslisbaar zou geweest zijn. Dan zouden de begrippen semibeslisbaarheid en beslisbaarheid samenvallen, zoals bewezen wordt door de volgende stelling.
Stelling 17.4 Als de taal
H = {⟨M,w⟩ : TM M stopt voor input w}
beslisbaar zou zijn, dan zou elke semibeslisbare taal ook beslisbaar zijn.
BEWIJS: Zij L een semibeslisbare taal, dus L ∈ SD. Dan bestaat er een Turing machine ML die de taal L semibeslist.
Stel nu dat de taal H beslisbaar zou zijn, dan bestaat er een Turing machine O die de taal H beslist.
Nu maken we een Turing machine M′ die de taal L beslist.
M’(w: reeks) =
  1. Laat de Turing machine O de input <M_L,w> verwerken.
  2. Als de Turing machine O deze input <M_L,w> aanvaardt
    (dus M_L zal stoppen voor input w), dan
234
        2.1 Laat de Turing machine M_L de input w verwerken.
        2.2 Als M_L de input w aanvaardt, dan aanvaard, anders weiger.
  3. Als de Turing machine O deze input <M_L,w> weigert
    (dus M_L zal niet stoppen voor input w), dan weiger.
Dan hebben we dus een Turing machine M′ die de taal L beslist.
Dus dit toont aan dat, moest de taal H beslisbaar zijn (H ∈ D), dan zijn alle semibeslisbare talen ook beslisbaar. P
235
Hoofdstuk 18
Beslisbare en semibeslisbare talen
18.1 Inleiding
In het vorige hoofdstuk hebben we bewezen dat de taal
H = {⟨M,w⟩ : TM M stopt voor input w}
semibeslisbaar is, maar niet beslisbaar.
Dit toont aan dat sommige talen ingewikkelder zijn dan andere talen,
want semibeslissen is een zwakkere vorm van beslissen.
Daar er een verschil is tussen semibeslissen en beslissen, is het belang-
rijk dat wij inzicht hebben in welke talen beslisbaar zijn, en welke talen semibeslisbaar, maar niet beslisbaar zijn.
In dit hoofdstuk en de volgende hoofdstukken zullen we dit onderzoeken.
E ́en van de zaken die we zullen bewijzen is dat er zelfs talen zijn die niet semibeslisbaar zijn. Dus er zijn talen/problemen die te ingewikkeld zijn voor Turing machines om zelfs maar te semibeslissen.
18.2 Inleidende stellingen
We bewijzen eerst een stelling die ons een verzameling talen geeft waarvan we zeker zijn dat ze beslisbaar zijn.
Stelling 18.1 De verzameling van de contextvrije talen is een stricte deel- verzameling van de verzameling D van alle beslisbare talen.
BEWIJS: Alle contextvrije talen zijn beslisbaar, dus de verzameling van de contextvrije talen is een deelverzameling van de verzameling D van alle beslisbare talen.
236
Maar de taal AnBnCn is ook beslisbaar, en is het klassieke voorbeeld van een niet-contextvrije taal.
Dus de verzameling van de contextvrije talen is een stricte deelverzame- ling van de verzameling D van alle beslisbare talen. P
Maar laten we ons nu concentreren op algemene beslisbare en semibe- slisbare talen. Kunnen we inzicht krijgen in welke talen semibeslisbaar zijn, maar niet beslisbaar, want bijna elke klassieke/evidente taal die semibeslis- baar is, is ook beslisbaar. Neem namelijk de volgende voorbeelden:
•
•
•
AnBnCn = {anbncn : n ∈ N}. {wcw : w ∈ {a,b}∗}.
{ww : w ∈ {a,b}∗}.
{w = x ∗ y = z : x, y, z ∈ {0, 1}∗},
•
met als x, y, z gezien worden als binaire getallen, dat dan x · y gelijk
is aan z.
Maar we weten dat er talen in SD zijn, die niet tot D behoren, zoals de
taal
H = {⟨M,w⟩ : TM M stopt voor input w}.
We kunnen daardoor het verband tussen de verzameling D van de be- slisbare talen en de verzameling SD van de semibeslisbare talen voorstellen zoals in Figuur 18.1. Waarbij we opmerken dat het gedeelte SD\D niet-ledig is, want de taal H behoort tot SD \ D.
Op Figuur 18.1 zien we ook de notatie ¬SD, die staat voor de verza- meling van de talen die niet-semibeslisbaar zijn. Ook deze verzameling is niet-ledig. We bewijzen dit opnieuw op twee manieren: eerst via gebruik van de begrippen aftelbaarheid en niet-aftelbaarheid. Later zullen we een concreet voorbeeld geven van een taal die niet-semibeslisbaar is.
Stelling 18.2 Er bestaan talen die niet semibeslisbaar zijn.
BEWIJS: Er zijn een oneindig aftelbaar aantal talen die semibeslisbaar zijn over een eindig, niet-ledig, alfabet Σ. Dit volgt uit het feit dat een semibeslisbare taal semibeslist wordt door een Turing machine, en er zijn een oneindig aftelbaar aantal Turing machines (Stelling 15.1).
237
￼￼￼￼￼￼Figuur 18.1: De verzamelingen D en SD
Maar het aantal talen over een eindig, niet-ledig, alfabet Σ is oneindig niet-aftelbaar.
Dus zijn er meer talen dan er semibeslisbare talen zijn; er bestaat min- stens  ́e ́en taal die niet semibeslisbaar is. P
Nu dat we zeker zijn dat er een taal bestaat die niet-semibeslisbaar is, zullen we stellingen proberen te vinden die ons helpen om een concreet voorbeeld van een niet-semibeslisbare taal te vinden. De eerste stellingen die we bewijzen, handelen over het al dan niet gesloten zijn van de verzameling D van de beslisbare talen en de verzameling SD van de semibeslisbare talen onder complementering.
Stelling 18.3 De verzameling D van de beslisbare talen is gesloten onder complementering.
BEWIJS: Het bewijs is een constructief bewijs.
Als een taal L tot D behoort, dan bestaat er een deterministische Turing machine M die de taal L beslist.
Maar hieruit kunnen we eenvoudig een deterministische Turing machine M′ maken die de taal ¬L beslist.
Neem namelijk de Turing machine M en verwissel de rol van de aan- vaardende en niet-aanvaardende toestanden y en n. Dan bekomen we een nieuwe deterministische Turing machine M′ die de taal ¬L beslist. P
Bemerk in het constructieve bewijs ook de redenen waarom dit bewijs lukt. Het bewijs lukt omdat de Turing machine M:
• deterministisch is, en
• een complete machine is.
Hiermee bedoelen we dat de Turing machine M voor elke input w, goed of slecht, een beslissing (aanvaarden of weigeren) neemt.
238
Als we het bewijs bekijken voor het gesloten zijn van de verzameling D onder complementering, zou dan de verzameling SD van de semibeslisbare talen ook gesloten zijn onder complementering? Het antwoord is neen.
Stelling 18.4 De verzameling SD van de semibeslisbare talen is niet geslo- ten onder complementering.
BEWIJS: Stel dat L een semibeslisbare taal is, wiens complement ¬L ook semibeslisbaar is.
Dan bestaat er een Turing machine ML die de taal L semibeslist en een Turing machine M¬L die de taal ¬L semibeslist.
Maar dan kan je een Turing machine M maken die de taal L beslist. (Verklaar dit.)
Dus als de verzameling SD van de semibeslisbare talen gesloten zou zijn onder complementering, dan zou elke semibeslisbare taal ook beslisbaar zijn. Maar we weten dat dit niet waar is, want de taal H is semibeslisbaar, maar niet beslisbaar (Stelling 17.1).
Dus de verzameling SD van de semibeslisbare talen is niet gesloten on- der complementering. P
In feite hebben we in het bewijs van de vorige stelling, de volgende stelling bewezen die de beslisbare talen karakteriseert binnen de verzameling van de semibeslisbare talen.
Stelling 18.5 Een taal L behoort tot D als en slechts als de taal L zelf en zijn complement ¬L beide tot SD behoren.
BEWIJS: DEEL 1. Stel de taal L is beslisbaar, dus behoort tot D, dan tonen we aan dat zowel L als ¬L tot SD behoren.
Daar L behoort tot D, behoort L ook tot SD.
Nu is de verzameling D gesloten onder complementering (Stelling 18.3). Dus ook de negatie ¬L behoort tot D, en behoort dus ook tot SD.
DEEL 2: Als L en ¬L tot SD behoren, dan behoort L tot D.
Daar L tot SD behoort, is er een Turing machine M1 die de taal L semibeslist.
Analoog, daar ¬L tot SD behoort, is er een Turing machine M2 die de taal ¬L semibeslist.
Om de taal L nu te beslissen, laat:
• beide Turing machines M1 en M2 in parallel de input w verwerken.
• Uiteindelijk zal ofwel M1 of M2 stoppen en aanvaarden, en hieruit kan dan beslist worden of de input w al dan niet tot de taal L behoort.
239
￼￼￼￼￼￼￼￼Dus we hebben een Turing machine gemaakt die de taal L beslist. P Via de hiervoor afgeleide stellingen, kunnen we nu een concreet voorbeeld
geven van een taal die niet-semibeslisbaar is.
Stelling 18.6 De taal
¬H={⟨M,w⟩: TMMstoptnietvoorinputw}
is niet-semibeslisbaar.
BEWIJS: We weten dat de taal H tot SD behoort (Stelling 17.2).
Moest de taal ¬H ook tot SD behoren, dan zou de taal H tot D behoren (Stelling 18.5).
Maar de taal H is niet beslisbaar (Stelling 17.1), dus de onderstelling dat ¬H tot SD behoort, is verkeerd.
Dus ¬H behoort niet tot SD. P Dus nu hebben we een concreet voorbeeld van een taal die niet-semibeslisbaar
is.
Onderzoekers hebben ook nog andere idee ̈en ontwikkeld om inzicht te
krijgen in beslisbare en semibeslisbare talen. E ́en van deze idee ̈en gebruikt het idee van opsommingen.
Definitie 18.2.1 Een Turing machine M telt af/somt op een taal L als en slechts als er, voor een zekere toestand p van de Turing machine M, geldt dat:
L = {w : (s,ε) ⊢∗M (p,w)}.
Een taal L is Turing-opsombaar als en slechts als er een Turing machine
M voor deze taal L bestaat die deze taal L opsomt.
De voorgaande definitie stelt dus dat een Turing machine M een taal L opsomt als het de reeksen uit de taal L, in een bepaalde volgorde, kan opsommen.
Voorbeeld 18.2.2 De Turing machine in Figuur 18.2 somt de taal L = a∗ op.
Figuur 18.2: TM die de taal L = a∗ opsomt
240
￼
￼￼￼￼￼￼￼E ́en van de redenen voor het invoeren van het begrip van opsommen/aftellen is dat Turing-opsombaar equivalent is met het semibeslisbaar zijn van talen.
Stelling 18.7 Een taal L is semibeslisbaar als en slechts als deze taal L Turing-opsombaar is.
BEWIJS: DEEL 1: Turing-opsombaar impliceert semibeslis- baar.
Zij M een Turing machine die de taal L opsomt. We converteren nu deze Turing machine M naar een Turing machine M′ die de taal L semibeslist.
• Sla de input w op.
• Laat de Turing machine M de taal L opsommen. Elke keer dat een element uit de taal L opgesomd wordt, vergelijk dit element met de input w. Als zij gelijk zijn, aanvaard dan de input w.
Op deze manier hebben we een Turing machine M′ bekomen die de taal L semibeslist. We illustreren dit in Figuur 18.3.
Figuur 18.3: Turing-opsombaar impliceert semibeslisbaar
DEEL 2: Semibeslisbaar impliceert Turing-opsombaar.
Als de taal L ⊆ Σ∗ semibeslisbaar is, dan is er een Turing machine M die de taal L semibeslist.
Nu geven we een eerste voorstel voor een procedure E die de taal L kan opsommen, maar er kan hier echter een probleem optreden.
• Som alle reeksen w ∈ Σ∗ lexicografisch op. Bijvoorbeeld, in de volg- orde:
ε,a,b,aa,ab,ba,bb,...
• Naarmate een reeks opgesomd wordt, laat deze semibeslissen door de Turing machine M.
241
￼￼￼
￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼Figuur 18.4: Eerste voorstel voor semibeslisbaar impliceert Turing- opsombaar
Dit eerste voorstel wordt voorgesteld in Figuur 18.4.
Deze procedure ziet er goed uit, maar er kunnen problemen optreden. Bij semibeslissen kan de Turing machine voor een slechte reeks in een oneindige lus terechtkomen. Dus dit dienen we te vermijden.
Een mogelijke oplossing om oneindige lussen te vermijden, is door do- vetailing te gebruiken via een Turing machine M′. Dit wordt geillustreerd door Figuur 18.5.
Figuur 18.5: Dovetailing
Bij dovetailing:
• roept de Turing machine M′ een copie M1 van de Turing machine M
op om precies  ́e ́en instructie uit te voeren op de eerste reeks w1.
• Daarna roept de Turing machine M′ een copie M2 van de Turing machine M op om precies  ́e ́en instructie uit te voeren op de tweede reeks w2, en mag Turing machine M1 een volgende instructie uitvoeren op de eerste reeks w1.
• Daarna roept de Turing machine M′ een copie M3 van de Turing machine M op om precies  ́e ́en instructie uit te voeren op de derde reeks w3, mag Turing machine M2 een volgende instructie uitvoeren op de tweede reeks w2, en mag Turing machine M1 een volgende instructie uitvoeren op de eerste reeks w1.
• Doe verder op deze manier om volgende Turing machines Mi op te starten die volgende reeksen wi verwerken.
242
￼
Van zodra een Turing machine Mi een input wi aanvaardt, geef dan wi als output.
Op deze manier hebben we een Turing machine M′ gemaakt die de taal L opsomt. P
We hebben in de vorige stelling een verband gevonden tussen Turing- opsombaarheid en semibeslisbaarheid.
Nu kan de vraag gesteld worden of er ook een analoog verband kan gevonden worden voor beslisbaarheid van een taal. Dit verband is gevonden en heet lexicografisch opsommen/aftellen.
Definitie 18.2.3 Een Turing machine M somt op/telt af een taal L op lexicografische wijze als en slechts als M de elementen van L in een bepaalde geordende, lexicografische, volgorde opsomt.
Een taal L is lexicografisch Turing-opsombaar als en slechts als er een Turing machine bestaat voor deze taal L die deze taal L lexicografisch op- somt.
De term lexicografisch opsommen betekent dat reeksen in een bepaalde volgorde opgesomd worden. Hiervan zijn er verschillende voorbeelden:
• reeksen letters kunnen alfabetisch en volgens lengte opgesomd worden.
• binaire reeksen kunnen per lengte en leidende nullen opgesomd worden.
• willekeurige reeksen over een eindig alfabet kunnen per lengte opge- somd worden: eerst de reeksen van lengte nul, dan de reeksen van lengte 1, dan deze van lengte 2, . . ..
Nu bewijzen we de stelling die het verband geeft tussen lexicografisch opsommen en beslisbaarheid van talen.
Stelling 18.8 Een taal L is beslisbaar als en slechts als zij lexicografisch Turing-opsombaar is.
BEWIJS: Deel 1: Beslisbaar impliceert lexicografisch Turing- opsombaar.
Zij M een Turing machine die de taal L beslist.
Dan stellen we een nieuwe Turing machine M′ op die eerst alle reeksen uit Σ∗ lexicografisch opsomt, en de reeksen  ́e ́en voor  ́e ́en test door ze te laten verwerken door de Turing machine M.
De Turing machine M beslist de taal L, en stopt dus voor elke reeks uit Σ∗, en aanvaardt of weigert deze reeks.
243
￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼￼Figuur 18.6: Beslisbaar impliceert lexicografisch Turing-opsombaar
De Turing machine M′ output enkel de reeksen die door de Turing ma- chine M aanvaard worden. Op deze manier worden de reeksen uit de taal L lexicografisch opgesomd. We illustreren dit in Figuur 18.6.
Deel 2: Lexicografisch Turing-opsombaar impliceert beslisbaar.
Zij M een Turing machine die de taal L lexicografisch opsomt. Dan, voor input w, start de Turing machine M′ de Turing machine M op en wacht tot:
• M genereert w, dus M′ aanvaardt de input w.
• M genereert een reeks die na de reeks w komt in de lexicografische
volgorde, en dan weigert M′ de input w. • M stopt, en dan weigert M′ de input w.
Op deze manier hebben we een Turing machine M′ die de taal L beslist. We illustreren dit in Figuur 18.7.
Figuur 18.7: Lexicografisch Turing-opsombaar impliceert beslisbaar
￼￼244
P
Hoofdstuk 19
Beslisbaarheids- en niet-beslisbaarheidsbewijzen
19.1 Inleiding
Nu geven we een methode om het niet-beslisbaar zijn van talen te bewijzen. De methode heet reductie.
Binnen de reductiemethode wordt er gebruik gemaakt van een andere taal waarvan we reeds weten dat zij niet-beslisbaar is, om aan te tonen dat een opgegeven taal ook niet-beslisbaar is.
De methode is heel subtiel, en dient natuurlijk op correcte wijze toe- gepast te worden. Daarom geven we een formele definitie van reductie in termen van Turing machines, en illustreren we de reductiemethode via en- kele, in detail uitgewerkte, voorbeelden.
19.2 De reductiemethode
Definitie 19.2.1 Een reductie R van een taal L1 naar een taal L2 bestaat uit  ́e ́en of meerdere Turing machines zodat:
Als er een Turing machine Oracle bestaat die de taal L2 beslist (of semi- beslist), dan kunnen de Turing machines in de verzameling R met de Turing machine Oracle samengesteld worden om een nieuwe Turing machine te ma- ken die de taal L1 beslist (of semibeslist).
De notatie
betekent dat P reduceerbaar is tot P′.
P ≤P′
Hoe wordt de reductiemethode nu gebruikt?
245
We gebruiken de reductiemethode om de niet-beslisbaarheid van de taal L2 via contrapositie aan te tonen.
Namelijk, de volgende implicatie geldt:
((Als R een reductie is van L1 naar L2) ∧ (L2 ∈D))→(L1 ∈D).
Maar stel dat je weet dat de taal L1 niet beslisbaar is, dan moet minstens  ́e ́en van de antecedenten van de implicatie vals zijn. Dus, als
(Als R een reductie is van L1 naar L2) waar is, dan moet
(L2 ∈ D)
vals zijn.
En op deze manier is het niet-beslisbaar zijn van de taal L2 aangetoond. We vatten de methode om het niet-beslisbaar zijn van een taal via de
reductiemethode nu samen in het volgende algoritme:
Methode om het niet-beslisbaar zijn van een taal L2 via reduc- tie aan te tonen.
• Kies een taal L1 waarvan geweten is dat zij niet-beslisbaar is, en die tot de taal L2 gereduceerd kan worden.
• Definieer de reductie R.
• Beschrijf de samenstelling C van de reductie R met de Turing machine
Oracle die, per onderstelling de taal L2 beslist.
• Toon aan dat de samenstelling C op correcte wijze de taal L1 beslist als en slechts als Oracle bestaat. We tonen dit aan via de volgende stappen:
– R kan geimplementeerd worden door Turing machines, – C is correct:
∗ als x ∈ L1, dan aanvaardt C(x), en ∗ als x ̸∈ L1, dan weigert C(x).
Maar het laatste geeft de gewenste tegenstrijdigheid. De laatste twee lijnen impliceren dat de samenstelling C de taal L1 beslist. Maar dit kan
246
niet, want, bij onderstelling was het geweten dat de taal L1 niet-beslisbaar was.
Dit betekent dat Oracle, de Turing machine die de taal L2 beslist, niet kan bestaan, en dus kunnen we besluiten dat de taal L2 niet-beslisbaar is.
Definitie 19.2.2 Een taal L1 is mapping reduceerbaar tot de taal L2, ge- noteerd met L1 ≤M L2, als en slechts als er een berekenbare functie f bestaat zodat:
∀x∈Σ∗(x∈L1 ⇔f(x)∈L2).
Bij mapping reduceerbaarheid kunnen we bij de vraag of x tot de taal L1 behoort, de input x via de functie f omzetten in een nieuw object f(x) en onderzoeken of dit nieuwe object f(x) tot de taal L2 behoort.
Nu geven we een concreet voorbeeld van de reductiemethode. We tonen aan dat de taal
Hε = {⟨M⟩ : TM M stopt voor input ε} semibeslisbaar is, maar niet-beslisbaar.
19.2.3 Voorbeeld 1
De taal Hε = {⟨M⟩ : TM M stopt voor input ε} is semibeslisbaar. Dit tonen we constructief aan via de volgende Turing machine T die de
taal Hε semibeslist. In de code stelt e de nulreeks ε voor.
 T(<M>) =
   1. Laat M de input e verwerken.
   2. Aanvaard.
Dan aanvaardt de Turing machine T de input ⟨M⟩ als en slechts als de Turing machine M stopt voor input ε. Dus semibeslist de Turing machine T de taal Hε.
De taal Hε = {⟨M⟩ : TM M stopt voor input ε} is niet-beslisbaar.
We tonen dit aan via de reductiemethode.
We onderstellen dat de taal Hε beslisbaar is. We onderstellen dat de Turing machine Oracle bestaat die de taal Hε beslist.
Nu komt de reductie vanuit de taal H, waarvan we weten dat deze niet-beslisbaar is.
247
￼￼￼￼H = {⟨M,w⟩ : TM M stopt voor input w}
R↓
Hε = {⟨M⟩ : TM M stopt voor input ε}
De mapping reductie R van de taal H naar de taal Hε wordt als volgt
gedefinieerd:
R(<M,w>) =
1. Construeer de Turing machine <M#>, waarbij M#(x) als volgt werkt:
  1.1 Wis de band.
  1.2 Schrijf w op de band.
  1.3 Laat de Turing machine M de input w verwerken.
2. Geef de Turing machine <M#> terug.
Nu tonen we aan dat als de Turing machine Oracle bestaat, die per onder- stelling de taal Hε beslist, dat dan de samenstelling C =Oracle(R(⟨M,w⟩)) de taal H beslist. Dit wordt geillustreerd in Figuur 19.1. Maar dit kan niet, want de taal H is niet-beslisbaar. Dus dan hebben we de gewenste contradictie.
Figuur 19.1: Blok diagram voor de samenstelling C =Oracle(R(⟨M,w⟩))
De samenstelling C is correct. We zien dat de Turing machine M# zijn input x niet gebruikt. Dus M# stopt voor alle inputs x of stopt voor geen enkele van zijn inputs x.
Nu kunnen we de volgende bespreking doen:
• stel ⟨M,w⟩ ∈ H: dus M stopt voor input w. Dan zal M# stoppen
voor al zijn inputs x. In het bijzonder stopt M# voor input x = ε. 248
￼
Dit kan gecontroleerd worden door Oracle. Oracle zal zien dat M# stopt voor input ε en dus zal Oracle de input M# aanvaarden.
• stel ⟨M,w⟩ ̸∈ H: dus M stopt niet voor input w. Dan zal M# voor geen enkele van zijn inputs x stoppen. In het bijzonder stopt M# dus ook niet voor input x = ε. Dit kan gecontroleerd worden door Oracle. Oracle zal zien dat M# niet stopt voor input ε en dus zal Oracle de input M# weigeren.
Maar bekijk de twee punten uit de voorgaande opsomming eens in detail. We zien dat M stopt voor input w als en slechts als Oracle de input M# aanvaardt.
Dus we kunnen het antwoord dat Oracle geeft op de vraag: stopt M# voor input ε? ook gebruiken om het correcte antwoord te vinden op de vraag: stopt M voor input w?
Dus in feite kan de Turing machine Oracle de taal H beslissen.
Dit is echter vals: er is geen enkele Turing machine die de taal H beslist.
Dus we hebben de gewenste contradictie. Onze onderstelling dat er een Turing machine Oracle bestaat die de taal Hε beslist, is verkeerd. Er bestaat geen Turing machine die de taal Hε beslist.
Dus we hebben bewezen dat de taal Hε niet-beslisbaar is.
Opmerking 19.2.4 Bekijken we opnieuw de reductie die wij uitgevoerd
hebben in de vorige oefening.
R(<M,w>) =
1. Construeer de Turing machine <M#>, waarbij M#(x) als volgt werkt:
  1.1 Wis de band.
  1.2 Schrijf w op de band.
  1.3 Laat de Turing machine M de input w verwerken.
2. Geef de Turing machine <M#> terug.
Hoeveel Turing machines worden er gebruikt in deze reductie? Er zijn:
• Oracle: de hypothetische Turing machine die de taal Hε kan beslissen.
• R: de Turing machine die de reductie uitvoert.
• C: de samenstelling van de reductie R met de Turing machine Oracle.
• M#: de Turing machine die we als input aan Oracle zullen geven. Merk op dat de Turing machine M# in feite nooit uitgevoerd wordt.
• M: de Turing machine waarvan we willen weten of ⟨M,w⟩ tot H behoort.
249
￼￼￼￼Vraag: verklaar in de opsomming hierboven wat er bedoeld wordt met: Merk op dat de Turing machine M# in feite nooit uitgevoerd wordt.
19.2.5 Voorbeeld 2
In het tweede voorbeeld tonen we via reductie aan dat de taal
HANY = {⟨M⟩ : er bestaat minstens 1 input waarop de TM M stopt}
semibeslisbaar, maar niet-beslisbaar is.
HAN Y is semibeslisbaar.
We construeren een Turing machine T die de taal HANY semibeslist. Deze Turing machine past dovetailing (zie bewijs Stelling 18.7 en Figuur 19.2) toe op de elementen uit Σ∗ zodat onderzocht kan worden of de Turing machine M stopt voor minstens  ́e ́en input.
Figuur 19.2: Dovetailing
T(<M>) =
1. Pas dovetailing toe om te onderzoeken of de TM M
   stopt voor minstens 1 element.
2. Als minstens 1 copie M_i van M stopt voor zijn input w_i,
   laat T stoppen en aanvaarden.
Dus zal de Turing machine T aanvaarden als en slechts als de Turing machine M stopt voor minstens  ́e ́en reeks. Dus T semibeslist de taal HANY .
HAN Y is niet-beslisbaar.
We tonen dit aan via de reductiemethode.
We onderstellen dat de taal HANY beslisbaar is. We onderstellen dat de Turing machine Oracle bestaat die de taal HANY beslist.
Nu komt de reductie vanuit de taal H, waarvan we weten dat deze niet-beslisbaar is.
250
￼
H = {⟨M,w⟩ : TM M stopt voor input w} R↓
HANY = {⟨M⟩ : er bestaat minstens 1 input waarop de TM M stopt} DemappingreductieRvandetaalHnaardetaalHANY wordtalsvolgt
gedefinieerd:
R(<M,w>) =
1. Construeer de Turing machine <M#>, waarbij M#(x) als volgt werkt:
   1.1 Bekijk de input x.
   1.2 Als x=w, laat de TM M de input w verwerken,
       anders start een oneindige lus op.
2. Geef de Turing machine <M#> terug.
Nu tonen we aan dat als de Turing machine Oracle bestaat, die per onder- stellingdetaalHANY beslist,datdandesamenstellingC =Oracle(R(⟨M,w⟩)) de taal H beslist. Maar dit kan niet, want de taal H is niet-beslisbaar. Dus dan hebben we de gewenste contradictie.
De samenstelling C is correct. We zien dat de Turing machine M# hoogstens voor input w kan stoppen. Bijgevolg kunnen we de volgende besluiten treffen:
• stel ⟨M,w⟩ ∈ H: dus M stopt voor input w. Dan zal M# stoppen voor input w. In het bijzonder stopt M# voor minstens  ́e ́en van zijn inputs. Dit kan gecontroleerd worden door Oracle. Oracle zal zien dat M# stopt voor minstens  ́e ́en van zijn inputs en dus zal Oracle de input M# aanvaarden.
• stel ⟨M,w⟩ ̸∈ H: dus M stopt niet voor input w. Dan zal M# voor geen enkele van zijn inputs x stoppen. Dit kan gecontroleerd worden door Oracle. Oracle zal zien dat M# voor geen enkele van zijn inputs stopt en dus zal Oracle de input M# weigeren.
Maar bekijk de twee punten uit de voorgaande opsomming eens in detail. We zien dat M stopt voor input w als en slechts als Oracle de input M# aanvaardt.
Dus we kunnen het antwoord dat Oracle geeft op de vraag: stopt M# voor minstens  ́e ́en van zijn inputs? ook gebruiken om het correcte antwoord te vinden op de vraag: stopt M voor input w?.
251
Dus in feite kan de Turing machine Oracle de taal H beslissen.
Dit is echter vals: er is geen enkele Turing machine die de taal H beslist.
Dus we hebben de gewenste contradictie. Onze onderstelling dat er een Turing machine Oracle bestaat die de taal HANY beslist, is verkeerd. Er bestaat geen Turing machine die de taal HANY beslist.
Dus we hebben bewezen dat de taal HANY niet-beslisbaar is. 19.3 Andere voorbeelden
De twee voorgaande voorbeelden tonen hoe de reductiemethode werkt. Sa- mengevat dienen de volgende stappen uitgevoerd te worden:
• Kies een niet-beslisbare taal om de reductie van te doen.
• Definieer de reductie R.
• Toon aan dat de samenstelling C van de reductie R met Oracle correct gedefinieerd is.
We illustreren deze stappen in een derde voorbeeld.
19.3.1 HALL is niet beslisbaar Beschouw de taal
HALL = {⟨M⟩ : TM M stopt voor alle inputs}.
We tonen via reductie aan dat deze taal niet-beslisbaar is.
We onderstellen dat de taal HALL beslisbaar is. We onderstellen dat de Turing machine Oracle bestaat die de taal HALL beslist.
Nu komt de reductie vanuit de taal Hε, waarvan we reeds weten dat deze niet-beslisbaar is. (Zie Subsectie 19.2.3.)
Hε = {⟨M⟩ : TM M stopt voor input ε}
R↓
HALL = {⟨M⟩ : TM M stopt voor alle inputs}
De mapping reductie R van de taal Hε naar de taal HALL wordt als volgt gedefinieerd:
252
R(<M>) =
1. Construeer de TM <M#>, waarbij M#(x) als volgt werkt:
   1.1 Wis de band.
   1.2 Laat de TM M de input op de band, dus de nulreeks e, verwerken.
2. Geef de Turing machine <M#> terug.
Nu tonen we aan dat als de Turing machine Oracle bestaat, die per onder- stelling de taal HALL beslist, dat dan de samenstelling C =Oracle(R(⟨M, w⟩)) de taal Hε beslist. Maar dit kan niet, want de taal Hε is niet-beslisbaar (Sub- sectie 19.2.3). Dus dan hebben we de gewenste contradictie.
De samenstelling C is correct. We zien dat de Turing machine M# zijn input x in feite niet gebruikt. Dus zal de Turing machine M# voor al zijn inputs x stoppen of voor geen enkele van zijn inputs x stoppen. Bijgevolg kunnen we de volgende besluiten treffen:
• stel ⟨M⟩ ∈ Hε: dus M stopt voor input ε. Dan zal M# stoppen voor al zijn inputs x. Dit kan gecontroleerd worden door Oracle. Oracle zal zien dat M# stopt voor al zijn inputs en dus zal Oracle de input M# aanvaarden.
• stel ⟨M⟩ ̸∈ Hε: dus M stopt niet voor input ε. Dan zal M# voor geen enkele van zijn inputs x stoppen. Dit kan gecontroleerd worden door Oracle. Oracle zal zien dat M# voor geen enkele van zijn inputs stopt en dus zal Oracle de input M# weigeren.
Maar bekijk de twee punten uit de voorgaande opsomming eens in detail. We zien dat M stopt voor input ε als en slechts als Oracle de input M# aanvaardt.
Dus we kunnen het antwoord dat Oracle geeft op de vraag: stopt M# voor al zijn inputs? ook gebruiken om het correcte antwoord te vinden op de vraag: stopt M voor input ε?
Dus in feite kan de Turing machine Oracle de taal Hε beslissen.
Dit is echter vals: er is geen enkele Turing machine die de taal Hε beslist.
Dus we hebben de gewenste contradictie. Onze onderstelling dat er een Turing machine Oracle bestaat die de taal HALL beslist, is verkeerd. Er bestaat geen Turing machine die de taal HALL beslist (Subsectie 19.2.3).
Dus we hebben bewezen dat de taal HALL niet-beslisbaar is. Opmerking 19.3.2 Er is zelfs meer geweten over de taal HALL. Deze taal
is zelf niet-semibeslisbaar.
19.3.3 Reductie op talen die aanvaarden
Nu zullen we de reductiemethode toepassen op een ander type talen. De vorige voorbeelden handelden over Turing machines die dienden te stoppen
253
voor inputs. Nu zullen we kijken naar voorbeelden van Turing machines die inputs dienen te aanvaarden.
Als eerste voorbeeld bekijken we de taal
A = {⟨M,w⟩ : w ∈ L(M)}.
Deze taal A is niet-beslisbaar. We tonen dit opnieuw aan via een reductie vanuit de taal H.
We onderstellen dat de taal A beslisbaar is. We onderstellen dat de Turing machine Oracle bestaat die de taal A beslist.
Nu komt de reductie vanuit de taal H, waarvan we weten dat deze niet-beslisbaar is.
H = {⟨M,w⟩ : TM M stopt voor input w}
R↓
A = {⟨M,w⟩ : w ∈ L(M)}
De mapping reductie R van de taal H naar de taal A wordt als volgt
gedefinieerd:
R(<M,w>) =
1. Construeer de TM <M#>, waarbij M#(x) als volgt werkt:
   1.1 Wis de band.
   1.2 Schrijf w op de band.
   1.3 Laat de TM M de input w verwerken.
   1.4 AANVAARD.
2. Geef <M#,w> terug.
Nu tonen we aan dat als de Turing machine Oracle bestaat, die per onder- stelling de taal A beslist, dat dan de samenstelling C =Oracle(R(⟨M,w⟩)) de taal H beslist. Maar dit kan niet, want de taal H is niet-beslisbaar. Dus dan hebben we de gewenste contradictie.
De samenstelling C is correct. We zien dat de Turing machine M# zijn input x niet gebruikt. Dus M# stopt voor alle inputs x of stopt voor geen enkele van zijn inputs x.
• stel ⟨M,w⟩ ∈ H: dus M stopt voor input w. Dan zal M# stoppen voor al zijn inputs x. In het bijzonder stopt M# voor input x = w, en dus dan wordt instructie 1.4 (AANVAARD) uitgevoerd. Dus M# aanvaardt de input w. Dit kan gecontroleerd worden door Oracle. Oracle zal zien dat M# de input x = w aanvaardt en dus zal Oracle de input ⟨M#,w⟩ aanvaarden.
254
• stel ⟨M,w⟩ ̸∈ H: dus M stopt niet voor input w. Dan zal M# voor geen enkele van zijn inputs x stoppen. In het bijzonder stopt M# dus ook niet voor input x = w. Dus wordt instructie 1.4 (AANVAARD) niet uitgevoerd. Dus M# zal de input x = w niet aanvaarden. Dit kan gecontroleerd worden door Oracle. Oracle zal zien dat M# de input x = w niet aanvaardt en dus zal Oracle de input ⟨M #, w⟩ weigeren.
Maar bekijk de twee punten uit de voorgaande opsomming eens in detail. We zien dat M stopt voor input w als en slechts als Oracle de input ⟨M #, w⟩ aanvaardt.
Dus we kunnen het antwoord dat Oracle geeft op de vraag: aanvaardt M# de input w? ook gebruiken om het correcte antwoord te vinden op de vraag: stopt M voor input w?
Dus in feite kan de Turing machine Oracle de taal H beslissen.
Dit is echter vals: er is geen enkele Turing machine die de taal H beslist.
Dus we hebben de gewenste contradictie. Onze onderstelling dat er een Turing machine Oracle bestaat die de taal A beslist, is verkeerd. Er bestaat geen Turing machine die de taal A beslist.
Dus we hebben bewezen dat de taal A niet-beslisbaar is. 19.3.4 Drie andere voorbeelden
Bewijs de volgende stellingen via de reductiemethode.
Stelling 19.1 De taal
Aε = {⟨M⟩ : TM M aanvaardt ε}
is niet-beslisbaar. Stelling 19.2 De taal
AANY = {⟨M⟩ : TM M aanvaardt minstens 1 van zijn inputs} is niet-beslisbaar.
Stelling 19.3 De taal
AALL = {⟨M⟩ : TM M aanvaardt al zijn inputs}
is niet-beslisbaar.
255
Hoofdstuk 20
De stelling van Rice
20.1 Inleiding
In het vorige hoofdstuk hebben we de reductiemethode opgesteld waarmee van bepaalde talen kan aangetoond worden dat zij niet-beslisbaar zijn.
De vraag kan gesteld worden of er een algemene stelling bestaat die van een verzameling talen verzekert dat alle talen in die verzameling niet- beslisbaar zijn.
Een dergelijke stelling bestaat. Zij is gekend onder de naam: de stelling van Rice. Deze stelling zegt dat geen enkele niet-triviale eigenschap van de verzameling van de semibeslisbare talen beslisbaar is.
In de volgende sectie geven we de exacte formulering van de stelling van Rice.
20.2 De stelling van Rice
Beschouw de verzameling SD van de semibeslisbare talen.
Semibeslisbare talen kunnen semibeslist worden door een Turing ma- chine, dus we kunnen de talen L uit SD beschrijven als L = L(M), met M
een Turing machine die deze taal L semibeslist.
Op de semibeslisbare talen kunnen eigenschappen P onderzocht worden.
Een eigenschap P bestudeerd op de talen uit de verzameling SD leidt tot een bijhorende verzameling talen; namelijk de verzameling van de semibeslisbare talen waarvoor de eigenschap P geldig/waar is:
L = {⟨M⟩ : P(L(M)) = TRUE}.
Nu kunnen we de niet-triviale eigenschappen P defini ̈eren.
Definitie 20.2.1 Een eigenschap P op de verzameling SD van de semibe- slisbare talen is niet-triviaal als en slechts als
256
• de eigenschap P niet waar is voor alle semibeslisbare talen, en • de eigenschap P niet vals is voor alle semibeslisbare talen.
Dus voor een niet-triviale eigenschap P bestaat er altijd minstens  ́e ́en semibeslisbare taal waarvoor de eigenschap P waar is, en minstens  ́e ́en se- mibeslisbare taal waarvoor de eigenschap P vals is.
Voorbeeld 20.2.2 Beschouw de volgende eigenschap P op de verzameling SD van de semibeslisbare talen:
P = de taal L(M) bevat enkel reeksen van even lengte.
Hier is het eenvoudig om een semibeslisbare taal te geven die voldoet aan eigenschap P en een semibeslisbare taal te geven die niet voldoet aan eigenschap P.
Namelijk, L1 = (ab)∗ is een semibeslisbare taal die enkel bestaat uit reeksen van even lengte, en L2 = {a} is een semibeslisbare taal die niet volledig bestaat uit reeksen van even lengte.
Opmerking 20.2.3 Hier is het opnieuw belangrijk alle details in rekening te brengen bij de stelling van Rice.
• De eigenschap P wordt gedefinieerd en beschouwd op de verzameling SD van alle semibeslisbare talen.
• De eigenschap P dient niet-triviaal te zijn, dus dient er een semibe- slisbare taal L1 gegeven te worden waarvoor de eigenschap P geldt, en dient er een semibeslisbare taal L2 gegeven te worden waarvoor de eigenschap P niet geldt.
Stelling 20.1 (stelling van Rice) Zij P een niet-triviale eigenschap op de verzameling SD van de semibeslisbare talen.
Zij
dan is deze taal L niet-beslisbaar.
BEWIJS: We tonen aan dat de taal L niet-beslisbaar is door de reduc- tiemethode toe te passen. We starten de reductie vanuit de taal H waarvan we weten dat deze niet-beslisbaar is. We onderstellen dat de Turing machine Oracle de taal L = {⟨M⟩ : P(L(M)) = T} beslist.
H = {⟨M,w⟩ : TM M stopt voor input w}
R↓ 257
L={⟨M⟩:P(L(M))= TRUE},
L = {⟨M⟩ : P(L(M)) = T}.
Nu dienen we echter het bewijs in twee delen op te splitsen. Ofwel is P (∅) = T , ofwel is P (∅) = F .
Hierna geven we het bewijs voor P(∅) = F. Het bewijs voor P(∅) = T wordt overgelaten als oefening.
Stel P(∅) = F.
Daar eigenschap P niet-triviaal is, bestaat er een semibeslisbare taal LT waarvoor P (LT ) = T . Zij K een Turing machine die deze taal LT semibeslist.
De mapping reductie R van de taal H naar de taal L wordt als volgt gedefinieerd:
R(<M,w>) =
1. Construeer de Turing machine <M#>, waarbij M#(x) als volgt werkt:
   1.1 Copieer de input x van de Turing machine M# naar een
       andere band voor later gebruik.
   1.2 Wis de input op de band.
   1.3 Schrijf w op de band.
   1.4 Laat de Turing machine M de input w verwerken.
   1.5 Plaats de input x van M# opnieuw op de band en laat de
       Turing machine K deze input verwerken.
2. Geef de Turing machine <M#> terug.
Nu tonen we aan dat als de Turing machine Oracle bestaat, die per on- derstelling de taal L beslist, dat dan de samenstelling C =Oracle(R(⟨M, w⟩)) de taal H beslist. Maar dit kan niet, want de taal H is niet-beslisbaar. Dus dan hebben we de gewenste contradictie.
• stel⟨M,w⟩∈H:dusMstoptvoorinputw.DanzalM#totinstructie 1.5 geraken. Dus in feite wordt de Turing machine M# equivalent aan de Turing machine K. Dus L(M#) = L(K) en P(L(M#)) = P (L(K )).
Maar P(L(K)) = T, dus ook P(L(M#)) = T.
Het feit of eigenschap P geldig is voor een semibeslisbare taal kan gecontroleerd worden door Oracle. Oracle zal zien dat P (L(M #)) = T en dus zal Oracle de input L(M#) aanvaarden.
• stel ⟨M,w⟩ ̸∈ H: dus M stopt niet voor input w. Dan zal M# in in- structie 1.4 in een oneindige lus terechtkomen, en dus wordt instructie 1.5 niet opgestart. Dus zal de Turing machine M# niks aanvaarden. Dus L(M#) = ∅.
258
We onderstellen dat P(∅) = F, dus P(L(M#)) = F.
Het feit of eigenschap P geldig is voor een semibeslisbare taal kan gecontroleerd worden door Oracle. Oracle zal zien dat P (L(M #)) = F en dus zal Oracle de input L(M#) weigeren.
Maar bekijk de twee punten uit de voorgaande opsomming eens in detail. We zien dat M stopt voor input w als en slechts als Oracle de taal L(M#) aanvaardt.
Dus we kunnen het antwoord dat Oracle geeft op de vraag: aanvaardt Oracle de taal L(M#)? ook gebruiken om het correcte antwoord te vinden op de vraag: stopt M voor input w?.
Dus in feite kan de Turing machine Oracle de taal H beslissen.
Dit is echter vals: er is geen enkele Turing machine die de taal H beslist.
Dus we hebben de gewenste contradictie. Onze onderstelling dat er een Turing machine Oracle bestaat die de taal L beslist, is verkeerd. Er bestaat geen Turing machine die de taal L = {⟨M⟩ : P(L(M)) = T} beslist.
Dus we hebben bewezen dat de taal L = {⟨M⟩ : P(L(M)) = T} niet- beslisbaar is.
Equivalent, we hebben aangetoond dat de niet-triviale eigenschap P op de verzameling SD van de semibeslisbare talen niet-beslisbaar is. P
20.3 Enkele voorbeelden
Nu geven we twee voorbeelden van toepassingen van de stelling van Rice.
Voorbeeld 20.3.1 Beschouw de verzameling SD van de semibeslisbare ta- len.
Beschouw de eigenschap P:
P: is L(M) regulier?
Dan kan de vraag gesteld worden: als taal, is {⟨M⟩ : L(M) is regulier} ∈ D?
Het antwoord is neen. We passen gewoon de stelling van Rice toe. Dit kan, want:
• de eigenschap P wordt beschouwd op de volledige verzameling SD van de semibeslisbare talen.
• de eigenschap P is niet-triviaal, want: – P(a∗)=T,en
259
– P(AnBn)=F.
Dus P is wel degelijk een niet-triviale eigenschap op de verzameling SD van de semibeslisbare talen. Dus de stelling van Rice verzekert ons dat deze eigenschap niet beslist kan worden door een Turing machine.
Voorbeeld 20.3.2 Beschouw de verzameling SD van de semibeslisbare ta- len.
Beschouw de eigenschap P:
P: is L(M) contextvrij?
Dan kan de vraag gesteld worden: als taal, is {⟨M⟩ : L(M) is contextvrij} ∈ D?
Het antwoord is opnieuw neen, door gebruik te maken van de stelling van Rice.
Als oefening vragen we een concrete verklaring hiervoor.
Opmerking 20.3.3 De stelling van Rice kan op vele eigenschappen P van de verzameling SD van de semibeslisbare talen toegepast worden.
Geef zelf een zo eenvoudig mogelijk voorbeeld van een niet-triviale eigen- schap P op de verzameling SD van de semibeslisbare talen.
260

